
warning: ~/.gdbinit.local: No such file or directory
warning: File "/home/dalegebit/Documents/system_learning/final/.gdbinit" auto-loading has been declined by your `auto-load safe-path' set to "$debugdir:$datadir/auto-load:/home/dalegebit/Documents/system_learning/lab2/.gdbinit".
To enable execution of this file add
	add-auto-load-safe-path /home/dalegebit/Documents/system_learning/final/.gdbinit
line to your configuration file "/home/dalegebit/.gdbinit".
To completely disable this security protection add
	set auto-load safe-path /
line to your configuration file "/home/dalegebit/.gdbinit".
For more information about this security protection see the
"Auto-loading safe path" section in the GDB manual.  E.g., run from the shell:
	info "(gdb)Auto-loading safe path"
+ target remote localhost:26000
.gdbinit:23: Error in sourced command file:
localhost:26000: Connection timed out.

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
.gdbinit:23: Error in sourced command file:
localhost:26000: Connection timed out.
+ target remote localhost:26000
.gdbinit:23: Error in sourced command file:
localhost:26000: Connection refused.
Argument required (starting display address).

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file obj/kern/kernel
.gdbinit:30: Error in sourced command file:
obj/kern/kernel: No such file or directory.
+ target remote localhost:26000
.gdbinit:23: Error in sourced command file:
Remote communication error.  Target disconnected.: Connection reset by peer.

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
+ target remote localhost:26000
.gdbinit:23: Error in sourced command file:
Remote communication error.  Target disconnected.: Connection reset by peer.

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
.gdbinit:23: Error in sourced command file:
localhost:26000: Connection refused.
+ target remote localhost:26000
.gdbinit:23: Error in sourced command file:
localhost:26000: Connection refused.

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
+ target remote localhost:26000
.gdbinit:23: Error in sourced command file:
Remote communication error.  Target disconnected.: Connection reset by peer.

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
.gdbinit:23: Error in sourced command file:
localhost:26000: Connection timed out.
Missing argument 0 in user function.
[31m[30m
warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
.gdbinit:23: Error in sourced command file:
localhost:26000: Connection refused.
List of classes of commands:

aliases -- Aliases of other commands
breakpoints -- Making program stop at certain points
data -- Examining data
files -- Specifying and examining files
internals -- Maintenance commands
obscure -- Obscure features
running -- Running the program
status -- Status inquiries
support -- Support facilities
tracepoints -- Tracing of program execution without stopping the program
user-defined -- User-defined commands

Type "help" followed by a class name for a list of commands in that class.
Type "help all" for the list of all commands.
Type "help" followed by command name for full documentation.
Type "apropos word" to search for commands related to "word".
Command name abbreviations are allowed if unambiguous.
User-defined.
List of classes of commands:

aliases -- Aliases of other commands
breakpoints -- Making program stop at certain points
data -- Examining data
files -- Specifying and examining files
internals -- Maintenance commands
obscure -- Obscure features
running -- Running the program
status -- Status inquiries
support -- Support facilities
tracepoints -- Tracing of program execution without stopping the program
user-defined -- User-defined commands

Type "help" followed by a class name for a list of commands in that class.
Type "help all" for the list of all commands.
Type "help" followed by command name for full documentation.
Type "apropos word" to search for commands related to "word".
Command name abbreviations are allowed if unambiguous.
Undefined command: "xq".  Try "help".

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
.gdbinit:23: Error in sourced command file:
localhost:26000: Connection refused.

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
[f000:e05b]    0x15805b:	add    %al,(%bx,%si)
0x0000e05b in ?? ()
[f000:e062]    0x158062:	add    %al,(%bx,%si)
0x0000e062 in ?? ()
[f000:e066]    0x158066:	add    %al,(%bx,%si)
0x0000e066 in ?? ()
[f000:e068]    0x158068:	add    %al,(%bx,%si)
0x0000e068 in ?? ()
[f000:e06a]    0x15806a:	add    %al,(%bx,%si)
0x0000e06a in ?? ()
[f000:e070]    0x158070:	add    %al,(%bx,%si)
0x0000e070 in ?? ()
[f000:e076]    0x158076:	add    %al,(%bx,%si)
0x0000e076 in ?? ()
Function "0xf011758" not defined.
Breakpoint 1 at 0xf011758
The "remote" target does not support "run".  Try "help target" or "continue".
Continuing.

Program received signal SIGINT, Interrupt.
The target architecture is assumed to be i386
=> 0xf0100394 <serial_intr+25>:	leave  
serial_intr () at console.c:60
60	}
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Breakpoint 1 at 0xf0101eb3: file env.c, line 550.
Continuing.
The target architecture is assumed to be i386
=> 0xf0101eb3 <env_pop_tf+10>:	pop    %es

Breakpoint 1, 0xf0101eb3 in env_pop_tf (tf=<error reading variable: Cannot access memory at address 0x8>) at env.c:550
550		__asm __volatile("movl %0,%%esp\n"
=> 0xf0101eb4 <env_pop_tf+11>:	pop    %ds
0xf0101eb4	550		__asm __volatile("movl %0,%%esp\n"
=> 0xf0101eb5 <env_pop_tf+12>:	add    $0x8,%esp
0xf0101eb5	550		__asm __volatile("movl %0,%%esp\n"
=> 0xf0101eb8 <env_pop_tf+15>:	iret   
0xf0101eb8	550		__asm __volatile("movl %0,%%esp\n"
=> 0xf0100040 <shitA>:	push   %ebp
shitA () at init.c:49
49	{
=> 0xf0100041 <shitA+1>:	mov    %esp,%ebp
0xf0100041	49	{
=> 0xf0100043 <shitA+3>:	sub    $0x8,%esp
0xf0100043 in shitA () at init.c:49
49	{
=> 0xf0100046 <shitA+6>:	sub    $0xc,%esp
lock_kernel () at ./spinlock.h:23
23		spin_lock(&kernel_lock);
=> 0xf0100049 <shitA+9>:	push   $0xf010f284
0xf0100049	23		spin_lock(&kernel_lock);
=> 0xf0101f36 <spin_lock+6>:	mov    $0x1,%eax
xchg (newval=0x1, addr=0xf010f284 <kernel_lock>) at ./x86.h:319
319		asm volatile("lock; xchgl %0, %1" :
=> 0xf0101f55 <spin_lock+37>:	ret    
0xf0101f55 in spin_lock (lk=0xf010f284 <kernel_lock>) at spinlock.c:30
30	}
=> 0xf010250c <cprintf+3>:	sub    $0x10,%esp
0xf010250c	39	{
=> 0xf01024e3 <vcprintf>:	push   %ebp
vcprintf (fmt=0xf01029e0 "fuck im A\n", ap=0xf0117024 "\020") at stdio.c:30
30	{
=> 0xf01024f3 <vcprintf+16>:	pushl  0x8(%ebp)
0xf01024f3	33		vprintfmt((void*)putch, &cnt, fmt, ap);
=> 0xf01020f8 <vprintfmt>:	push   %ebp
vprintfmt (putch=0xf01020db <putch>, putdat=0xf0116fec, fmt=0xf01029e0 "fuck im A\n", ap=0xf0117024 "\020") at stdio.c:105
105	{
=> 0xf01020fe <vprintfmt+6>:	sub    $0x2c,%esp
0xf01020fe	105	{
=> 0xf010210f <vprintfmt+23>:	movzbl (%eax),%eax
0xf010210f	113			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf010212a <vprintfmt+50>:	mov    0x8(%ebp),%ebx
0xf010212a	114				if (ch == '\0')
=> 0xf01020db <putch>:	push   %ebp
putch (ch=0x66, cnt=0xf0116fec) at stdio.c:23
23	{
=> 0xf01020e5 <putch+10>:	pushl  0x8(%ebp)
24		cputchar(ch);
=> 0xf010061b <cputchar+6>:	mov    0x8(%ebp),%eax
437		cons_putc(c);
=> 0xf010016b <cons_putc+4>:	push   %esi
0xf010016b	200	{
=> 0xf0100177 <cons_putc+16>:	in     (%dx),%al
0xf0100177	68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf010021b <cons_putc+180>:	mov    $0x3f8,%edx
0xf010021b in outb (data=0x66, port=0x3f8) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf010022b <cons_putc+196>:	or     $0x700,%edi
156			c |= 0x0700;
=> 0xf010023b <cons_putc+212>:	cmp    $0x9,%eax
0xf010023b	158		switch (c & 0xff) {
=> 0xf0100252 <cons_putc+235>:	je     0xf0100291 <cons_putc+298>
0xf0100252	158		switch (c & 0xff) {
=> 0xf01002ea <cons_putc+387>:	movzwl %ax,%eax
0xf01002ea	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100345 <cons_putc+478>:	mov    0xf010e9b0,%ecx
191		outb(addr_6845, 14);
=> 0xf010035a <cons_putc+499>:	lea    0x1(%ecx),%esi
0xf010035a	192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100366 <cons_putc+511>:	mov    $0xf,%eax
0xf0100366 in outb (data=0xf, port=0x3d4) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100372 <cons_putc+523>:	out    %al,(%dx)
0xf0100372	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100379 <cons_putc+530>:	pop    %ebp
0xf0100379	203	}
=> 0xf01020f0 <putch+21>:	add    $0x10,%esp
26	}
=> 0xf0102137 <vprintfmt+63>:	movzbl -0x1(%esi),%eax
0xf0102137	113			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0102122 <vprintfmt+42>:	je     0xf01024db <vprintfmt+995>
0xf0102122	114				if (ch == '\0')
=> 0xf0102132 <vprintfmt+58>:	call   *%ebx
0xf0102132	116				putch(ch, putdat);
=> 0xf01020e2 <putch+7>:	mov    0xc(%ebp),%ebx
0xf01020e2	23	{
=> 0xf0100618 <cputchar+3>:	sub    $0x8,%esp
0xf0100618	436	{
=> 0xf010016a <cons_putc+3>:	push   %edi
0xf010016a	200	{
=> 0xf0100172 <cons_putc+11>:	mov    $0x3fd,%edx
inb (port=0x3fd) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf01001a0 <cons_putc+57>:	jne    0xf010021b <cons_putc+180>
0xf01001a0	72		if (c == '\b') {
=> 0xf0100229 <cons_putc+194>:	jne    0xf0100231 <cons_putc+202>
0xf0100229	155		if (!(c & ~0xFF))
=> 0xf0100239 <cons_putc+210>:	je     0xf01002af <cons_putc+328>
0xf0100239	158		switch (c & 0xff) {
=> 0xf010024f <cons_putc+232>:	cmp    $0xd,%eax
0xf010024f	158		switch (c & 0xff) {
=> 0xf010212d <vprintfmt+53>:	sub    $0x8,%esp
116				putch(ch, putdat);
=> 0xf01002e3 <cons_putc+380>:	mov    %dx,0xf010e9a8
0xf01002e3	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf01020dc <putch+1>:	mov    %esp,%ebp
0xf01020dc	23	{
=> 0xf0100300 <cons_putc+409>:	jbe    0xf0100345 <cons_putc+478>
0xf0100300	182		if (crt_pos >= CRT_SIZE) {
=> 0xf01020e8 <putch+13>:	call   0xf0100615 <cputchar>
0xf01020e8	24		cputchar(ch);
=> 0xf0100353 <cons_putc+492>:	movzwl 0xf010e9a8,%ebx
cga_putc (c=<optimized out>) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf010061e <cputchar+9>:	call   0xf0100167 <cons_putc>
0xf010061e	437		cons_putc(c);
=> 0xf0100365 <cons_putc+510>:	out    %al,(%dx)
0xf0100365	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf010016c <cons_putc+5>:	push   %ebx
0xf010016c	200	{
=> 0xf0100370 <cons_putc+521>:	mov    %esi,%edx
0xf0100370	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100178 <cons_putc+17>:	test   $0x20,%al
serial_putc (c=0x20) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100378 <cons_putc+529>:	pop    %edi
0xf0100378	203	}
=> 0xf0100220 <cons_putc+185>:	mov    %edi,%eax
0xf0100220	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100236 <cons_putc+207>:	cmp    $0x9,%eax
0xf0100236	158		switch (c & 0xff) {
=> 0xf010016c <cons_putc+5>:	push   %ebx
0xf010016c	200	{
=> 0xf0102132 <vprintfmt+58>:	call   *%ebx
0xf0102132	116				putch(ch, putdat);
=> 0xf0100624 <cputchar+15>:	ret    
0xf0100624 in cputchar (c=0x41) at console.c:438
438	}
=> 0xf0102137 <vprintfmt+63>:	movzbl -0x1(%esi),%eax
0xf0102137	113			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf010036e <cons_putc+519>:	mov    %ebx,%eax
0xf010036e in outb (data=0xb4, port=0x3d5) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01002ed <cons_putc+390>:	mov    0xf010e9ac,%edx
0xf01002ed	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100229 <cons_putc+194>:	jne    0xf0100231 <cons_putc+202>
0xf0100229	155		if (!(c & ~0xFF))
=> 0xf010023e <cons_putc+215>:	jg     0xf010024a <cons_putc+227>
0xf010023e	158		switch (c & 0xff) {
=> 0xf0100172 <cons_putc+11>:	mov    $0x3fd,%edx
inb (port=0x3fd) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf01020de <putch+3>:	push   %ebx
0xf01020de	23	{
=> 0xf01020f6 <putch+27>:	leave  
0xf01020f6	26	}
=> 0xf0102141 <vprintfmt+73>:	jne    0xf0102120 <vprintfmt+40>
0xf0102141	113			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0100373 <cons_putc+524>:	lea    -0xc(%ebp),%esp
cons_putc (c=c@entry=0x20) at console.c:203
203	}
=> 0xf0100300 <cons_putc+409>:	jbe    0xf0100345 <cons_putc+478>
0xf0100300	182		if (crt_pos >= CRT_SIZE) {
=> 0xf010250c <cprintf+3>:	sub    $0x10,%esp
0xf010250c	39	{
=> 0xf010024f <cons_putc+232>:	cmp    $0xd,%eax
0xf010024f	158		switch (c & 0xff) {
=> 0xf010017a <cons_putc+19>:	jne    0xf010019d <cons_putc+54>
0xf010017a	68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf01020e5 <putch+10>:	pushl  0x8(%ebp)
24		cputchar(ch);
=> 0xf0100167 <cons_putc>:	push   %ebp
cons_putc (c=c@entry=0x66) at console.c:200
200	{
=> 0xf0102128 <vprintfmt+48>:	jmp    0xf010212d <vprintfmt+53>
0xf0102128	114				if (ch == '\0')
=> 0xf0100378 <cons_putc+529>:	pop    %edi
0xf0100378	203	}
=> 0xf0100350 <cons_putc+489>:	mov    %ecx,%edx
0xf0100350	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100365 <cons_putc+510>:	out    %al,(%dx)
0xf0100365	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01002d9 <cons_putc+370>:	movzwl 0xf010e9a8,%eax
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf010021b <cons_putc+180>:	mov    $0x3f8,%edx
0xf010021b in outb (data=0x6d, port=0x3f8) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100616 <cputchar+1>:	mov    %esp,%ebp
0xf0100616	436	{
=> 0xf010016b <cons_putc+4>:	push   %esi
0xf010016b	200	{
=> 0xf0102131 <vprintfmt+57>:	push   %eax
0xf0102131	116				putch(ch, putdat);
=> 0xf0100623 <cputchar+14>:	leave  
cputchar (c=0x6d) at console.c:438
438	}
=> 0xf010035d <cons_putc+502>:	mov    %ebx,%eax
outb (data=0x6, port=0x3d5) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf010036d <cons_putc+518>:	out    %al,(%dx)
0xf010036d	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01002ea <cons_putc+387>:	movzwl %ax,%eax
0xf01002ea	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100223 <cons_putc+188>:	test   $0xffffff00,%edi
cga_putc (c=0x20) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0101f61 <spin_unlock+11>:	lock xchg %eax,(%edx)
0xf0101f61	319		asm volatile("lock; xchgl %0, %1" :
=> 0xf0100170 <cons_putc+9>:	mov    %eax,%edi
0xf0100170	200	{
=> 0xf01020dc <putch+1>:	mov    %esp,%ebp
0xf01020dc	23	{
=> 0xf01020f0 <putch+21>:	add    $0x10,%esp
26	}
=> 0xf0102112 <vprintfmt+26>:	cmp    $0x25,%eax
0xf0102112	113			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0100372 <cons_putc+523>:	out    %al,(%dx)
0xf0100372	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01002f7 <cons_putc+400>:	cmpw   $0x7cf,0xf010e9a8
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100231 <cons_putc+202>:	mov    %edi,%eax
158		switch (c & 0xff) {
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf0100336 <cons_putc+463>:	add    $0x2,%eax
0xf0100336	187				crt_buf[i] = 0x0700 | ' ';
=> 0xf01020df <putch+4>:	sub    $0x10,%esp
0xf01020df	23	{
=> 0xf01020f6 <putch+27>:	leave  
0xf01020f6	26	}
=> 0xf0100366 <cons_putc+511>:	mov    $0xf,%eax
0xf0100366 in outb (data=0xf, port=0x3d4) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01002e0 <cons_putc+377>:	lea    0x1(%eax),%edx
0xf01002e0	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf0100336 <cons_putc+463>:	add    $0x2,%eax
0xf0100336	187				crt_buf[i] = 0x0700 | ' ';
=> 0xf010016b <cons_putc+4>:	push   %esi
0xf010016b	200	{
=> 0xf0102131 <vprintfmt+57>:	push   %eax
0xf0102131	116				putch(ch, putdat);
=> 0xf0100623 <cputchar+14>:	leave  
cputchar (c=0x69) at console.c:438
438	}
=> 0xf010035a <cons_putc+499>:	lea    0x1(%ecx),%esi
0xf010035a	192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf0100336 <cons_putc+463>:	add    $0x2,%eax
0xf0100336	187				crt_buf[i] = 0x0700 | ' ';
=> 0xf0100222 <cons_putc+187>:	out    %al,(%dx)
0xf0100222	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf010061b <cputchar+6>:	mov    0x8(%ebp),%eax
437		cons_putc(c);
=> 0xf0102120 <vprintfmt+40>:	test   %eax,%eax
0xf0102120	114				if (ch == '\0')
=> 0xf0100376 <cons_putc+527>:	pop    %ebx
0xf0100376	203	}
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf0100336 <cons_putc+463>:	add    $0x2,%eax
0xf0100336	187				crt_buf[i] = 0x0700 | ' ';
=> 0xf010024f <cons_putc+232>:	cmp    $0xd,%eax
0xf010024f	158		switch (c & 0xff) {
=> 0xf010017a <cons_putc+19>:	jne    0xf010019d <cons_putc+54>
0xf010017a	68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf01020e5 <putch+10>:	pushl  0x8(%ebp)
24		cputchar(ch);
=> 0xf0102134 <vprintfmt+60>:	add    $0x1,%esi
vprintfmt (putch=0xf01020db <putch>, putdat=0xf0116fec, fmt=0xf01029e9 "\n", ap=0xf0117024 "\020") at stdio.c:113
113			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf0100336 <cons_putc+463>:	add    $0x2,%eax
0xf0100336	187				crt_buf[i] = 0x0700 | ' ';
=> 0xf010034b <cons_putc+484>:	mov    $0xe,%eax
outb (data=0xe, port=0x3d4) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100239 <cons_putc+210>:	je     0xf01002af <cons_putc+328>
0xf0100239	158		switch (c & 0xff) {
=> 0xf010016d <cons_putc+6>:	sub    $0xc,%esp
0xf010016d	200	{
=> 0xf01020db <putch>:	push   %ebp
putch (ch=0xa, cnt=0xf0116fec) at stdio.c:23
23	{
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf0100336 <cons_putc+463>:	add    $0x2,%eax
0xf0100336	187				crt_buf[i] = 0x0700 | ' ';
=> 0xf010036e <cons_putc+519>:	mov    %ebx,%eax
0xf010036e in outb (data=0x81, port=0x3d5) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01002ed <cons_putc+390>:	mov    0xf010e9ac,%edx
0xf01002ed	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100229 <cons_putc+194>:	jne    0xf0100231 <cons_putc+202>
0xf0100229	155		if (!(c & ~0xFF))
=> 0xf0100167 <cons_putc>:	push   %ebp
cons_putc (c=c@entry=0xa) at console.c:200
200	{
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf0102835 <memmove+101>:	pop    %edi
0xf0102835	162	}
=> 0xf0100336 <cons_putc+463>:	add    $0x2,%eax
0xf0100336	187				crt_buf[i] = 0x0700 | ' ';
=> 0xf01020f0 <putch+21>:	add    $0x10,%esp
26	}
=> 0xf0100363 <cons_putc+508>:	mov    %esi,%edx
0xf0100363	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100254 <cons_putc+237>:	jmp    0xf01002d9 <cons_putc+370>
0xf0100254	158		switch (c & 0xff) {
=> 0xf01001a0 <cons_putc+57>:	jne    0xf010021b <cons_putc+180>
0xf01001a0	72		if (c == '\b') {
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf0100336 <cons_putc+463>:	add    $0x2,%eax
0xf0100336	187				crt_buf[i] = 0x0700 | ' ';
=> 0xf0100336 <cons_putc+463>:	add    $0x2,%eax
0xf0100336	187				crt_buf[i] = 0x0700 | ' ';
=> 0xf010212d <vprintfmt+53>:	sub    $0x8,%esp
116				putch(ch, putdat);
=> 0xf0100379 <cons_putc+530>:	pop    %ebp
0xf0100379	203	}
=> 0xf0100352 <cons_putc+491>:	out    %al,(%dx)
0xf0100352	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf010023e <cons_putc+215>:	jg     0xf010024a <cons_putc+227>
0xf010023e	158		switch (c & 0xff) {
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf0100336 <cons_putc+463>:	add    $0x2,%eax
0xf0100336	187				crt_buf[i] = 0x0700 | ' ';
=> 0xf0100336 <cons_putc+463>:	add    $0x2,%eax
0xf0100336	187				crt_buf[i] = 0x0700 | ' ';
=> 0xf0100616 <cputchar+1>:	mov    %esp,%ebp
0xf0100616	436	{
=> 0xf010213e <vprintfmt+70>:	cmp    $0x25,%eax
0xf010213e	113			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0100372 <cons_putc+523>:	out    %al,(%dx)
0xf0100372	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100300 <cons_putc+409>:	jbe    0xf0100345 <cons_putc+478>
0xf0100300	182		if (crt_pos >= CRT_SIZE) {
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf0100336 <cons_putc+463>:	add    $0x2,%eax
0xf0100336	187				crt_buf[i] = 0x0700 | ' ';
=> 0xf0100336 <cons_putc+463>:	add    $0x2,%eax
0xf0100336	187				crt_buf[i] = 0x0700 | ' ';
=> 0xf0100177 <cons_putc+16>:	in     (%dx),%al
0xf0100177	68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf01020df <putch+4>:	sub    $0x10,%esp
0xf01020df	23	{
=> 0xf01020f6 <putch+27>:	leave  
0xf01020f6	26	}
=> 0xf01027d5 <memmove+5>:	mov    0x8(%ebp),%eax
0xf01027d5	136	{
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf0100336 <cons_putc+463>:	add    $0x2,%eax
0xf0100336	187				crt_buf[i] = 0x0700 | ' ';
=> 0xf0100336 <cons_putc+463>:	add    $0x2,%eax
0xf0100336	187				crt_buf[i] = 0x0700 | ' ';
=> 0xf0100233 <cons_putc+204>:	movzbl %al,%eax
0xf0100233	158		switch (c & 0xff) {
=> 0xf010016b <cons_putc+4>:	push   %esi
0xf010016b	200	{
=> 0xf0102131 <vprintfmt+57>:	push   %eax
0xf0102131	116				putch(ch, putdat);
=> 0xf0102828 <memmove+88>:	mov    %eax,%edi
0xf0102828	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf0100336 <cons_putc+463>:	add    $0x2,%eax
0xf0100336	187				crt_buf[i] = 0x0700 | ' ';
=> 0xf0100336 <cons_putc+463>:	add    $0x2,%eax
0xf0100336	187				crt_buf[i] = 0x0700 | ' ';
=> 0xf01002e3 <cons_putc+380>:	mov    %dx,0xf010e9a8
0xf01002e3	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100222 <cons_putc+187>:	out    %al,(%dx)
0xf0100222	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf010061b <cputchar+6>:	mov    0x8(%ebp),%eax
437		cons_putc(c);
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf0100336 <cons_putc+463>:	add    $0x2,%eax
0xf0100336	187				crt_buf[i] = 0x0700 | ' ';
=> 0xf0100345 <cons_putc+478>:	mov    0xf010e9b0,%ecx
191		outb(addr_6845, 14);
=> 0xf010035d <cons_putc+502>:	mov    %ebx,%eax
outb (data=0x7, port=0x3d5) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf010024f <cons_putc+232>:	cmp    $0xd,%eax
0xf010024f	158		switch (c & 0xff) {
=> 0xf010017a <cons_putc+19>:	jne    0xf010019d <cons_putc+54>
0xf010017a	68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf0100336 <cons_putc+463>:	add    $0x2,%eax
0xf0100336	187				crt_buf[i] = 0x0700 | ' ';
=> 0xf010036d <cons_putc+518>:	out    %al,(%dx)
0xf010036d	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100377 <cons_putc+528>:	pop    %esi
0xf0100377	203	}
=> 0xf010034b <cons_putc+484>:	mov    $0xe,%eax
outb (data=0xe, port=0x3d4) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100239 <cons_putc+210>:	je     0xf01002af <cons_putc+328>
0xf0100239	158		switch (c & 0xff) {
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf0100336 <cons_putc+463>:	add    $0x2,%eax
0xf0100336	187				crt_buf[i] = 0x0700 | ' ';
=> 0xf01020ed <putch+18>:	addl   $0x1,(%ebx)
putch (ch=0xa, cnt=0xf0116fec) at stdio.c:25
25		++(*cnt);
=> 0xf0102137 <vprintfmt+63>:	movzbl -0x1(%esi),%eax
0xf0102137	113			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf010036e <cons_putc+519>:	mov    %ebx,%eax
0xf010036e in outb (data=0x85, port=0x3d5) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01002ed <cons_putc+390>:	mov    0xf010e9ac,%edx
0xf01002ed	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf0100336 <cons_putc+463>:	add    $0x2,%eax
0xf0100336	187				crt_buf[i] = 0x0700 | ' ';
=> 0xf01024db <vprintfmt+995>:	lea    -0xc(%ebp),%esp
264	}
=> 0xf01020dc <putch+1>:	mov    %esp,%ebp
0xf01020dc	23	{
=> 0xf01020f0 <putch+21>:	add    $0x10,%esp
26	}
=> 0xf0100363 <cons_putc+508>:	mov    %esi,%edx
0xf0100363	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf0100336 <cons_putc+463>:	add    $0x2,%eax
0xf0100336	187				crt_buf[i] = 0x0700 | ' ';
=> 0xf0100066 <shitA+38>:	call   0xf0101f56 <spin_unlock>
0xf0100066	29		spin_unlock(&kernel_lock);
=> 0xf0100168 <cons_putc+1>:	mov    %esp,%ebp
0xf0100168	200	{
=> 0xf010212d <vprintfmt+53>:	sub    $0x8,%esp
116				putch(ch, putdat);
=> 0xf0100379 <cons_putc+530>:	pop    %ebp
0xf0100379	203	}
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf0100336 <cons_putc+463>:	add    $0x2,%eax
0xf0100336	187				crt_buf[i] = 0x0700 | ' ';
=> 0xf010004e <shitA+14>:	call   0xf0101f30 <spin_lock>
0xf010004e	23		spin_lock(&kernel_lock);
=> 0xf010021b <cons_putc+180>:	mov    $0x3f8,%edx
0xf010021b in outb (data=0x63, port=0x3f8) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100616 <cputchar+1>:	mov    %esp,%ebp
0xf0100616	436	{
=> 0xf010213e <vprintfmt+70>:	cmp    $0x25,%eax
0xf010213e	113			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf0100336 <cons_putc+463>:	add    $0x2,%eax
0xf0100336	187				crt_buf[i] = 0x0700 | ' ';
=> 0xf0102509 <cprintf>:	push   %ebp
cprintf (fmt=0xf01029e0 "fuck im A\n") at stdio.c:39
39	{
=> 0xf010024a <cons_putc+227>:	cmp    $0xa,%eax
0xf010024a	158		switch (c & 0xff) {
=> 0xf0100177 <cons_putc+16>:	in     (%dx),%al
0xf0100177	68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf01020df <putch+4>:	sub    $0x10,%esp
0xf01020df	23	{
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf0100336 <cons_putc+463>:	add    $0x2,%eax
0xf0100336	187				crt_buf[i] = 0x0700 | ' ';
=> 0xf01024f3 <vcprintf+16>:	pushl  0x8(%ebp)
0xf01024f3	33		vprintfmt((void*)putch, &cnt, fmt, ap);
=> 0xf0100300 <cons_putc+409>:	jbe    0xf0100345 <cons_putc+478>
0xf0100300	182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100233 <cons_putc+204>:	movzbl %al,%eax
0xf0100233	158		switch (c & 0xff) {
=> 0xf010016b <cons_putc+4>:	push   %esi
0xf010016b	200	{
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf0100336 <cons_putc+463>:	add    $0x2,%eax
0xf0100336	187				crt_buf[i] = 0x0700 | ' ';
=> 0xf0102104 <vprintfmt+12>:	jmp    0xf0102109 <vprintfmt+17>
0xf0102104	105	{
=> 0xf010036b <cons_putc+516>:	mov    %ecx,%edx
0xf010036b	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01002e3 <cons_putc+380>:	mov    %dx,0xf010e9a8
0xf01002e3	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100222 <cons_putc+187>:	out    %al,(%dx)
0xf0100222	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
=> 0xf010282b <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010282b	155				asm volatile("cld; rep movsl\n"
Breakpoint 2 at 0xf0100078: file init.c, line 61.
Continuing.
=> 0xf0101eb3 <env_pop_tf+10>:	pop    %es

Breakpoint 1, 0xf0101eb3 in env_pop_tf (tf=<error reading variable: Cannot access memory at address 0x8>) at env.c:550
550		__asm __volatile("movl %0,%%esp\n"
=> 0xf0101eb4 <env_pop_tf+11>:	pop    %ds
0xf0101eb4	550		__asm __volatile("movl %0,%%esp\n"
=> 0xf0101eb5 <env_pop_tf+12>:	add    $0x8,%esp
0xf0101eb5	550		__asm __volatile("movl %0,%%esp\n"
=> 0xf0101eb8 <env_pop_tf+15>:	iret   
0xf0101eb8	550		__asm __volatile("movl %0,%%esp\n"
=> 0xf0100072 <shitB>:	push   %ebp
shitB () at init.c:59
59	{
=> 0xf0100073 <shitB+1>:	mov    %esp,%ebp
0xf0100073	59	{
=> 0xf0100075 <shitB+3>:	sub    $0x8,%esp
0xf0100075 in shitB () at init.c:59
59	{
=> 0xf0100078 <shitB+6>:	sub    $0xc,%esp

Breakpoint 2, lock_kernel () at ./spinlock.h:23
23		spin_lock(&kernel_lock);
=> 0xf010007b <shitB+9>:	push   $0xf010f284
0xf010007b	23		spin_lock(&kernel_lock);
=> 0xf0100080 <shitB+14>:	call   0xf0101f30 <spin_lock>
0xf0100080	23		spin_lock(&kernel_lock);
=> 0xf0101f30 <spin_lock>:	push   %ebp
spin_lock (lk=0xf010f284 <kernel_lock>) at spinlock.c:23
23	{
=> 0xf0101f31 <spin_lock+1>:	mov    %esp,%ebp
0xf0101f31	23	{
=> 0xf0101f33 <spin_lock+3>:	mov    0x8(%ebp),%ecx
0xf0101f33	23	{
=> 0xf0101f36 <spin_lock+6>:	mov    $0x1,%eax
xchg (newval=0x1, addr=0xf010f284 <kernel_lock>) at ./x86.h:319
319		asm volatile("lock; xchgl %0, %1" :
=> 0xf0101f3b <spin_lock+11>:	lock xchg %eax,(%ecx)
0xf0101f3b	319		asm volatile("lock; xchgl %0, %1" :
=> 0xf0101f3e <spin_lock+14>:	test   %eax,%eax
spin_lock (lk=0xf010f284 <kernel_lock>) at spinlock.c:28
28		while (xchg(&lk->locked, 1) != 0)
=> 0xf0101f40 <spin_lock+16>:	je     0xf0101f54 <spin_lock+36>
0xf0101f40	28		while (xchg(&lk->locked, 1) != 0)
=> 0xf0101f42 <spin_lock+18>:	mov    %ecx,%edx
0xf0101f42	28		while (xchg(&lk->locked, 1) != 0)
=> 0xf0101f44 <spin_lock+20>:	mov    $0x1,%ecx
xchg (newval=<optimized out>, addr=<optimized out>) at ./x86.h:319
319		asm volatile("lock; xchgl %0, %1" :
=> 0xf0101f49 <spin_lock+25>:	pause  
spin_lock (lk=0xf010f284 <kernel_lock>) at spinlock.c:29
29			asm volatile ("pause");
=> 0xf0101f4d <spin_lock+29>:	lock xchg %eax,(%edx)
0xf0101f4d in xchg (newval=0x1, addr=0xf010f284 <kernel_lock>) at ./x86.h:319
319		asm volatile("lock; xchgl %0, %1" :
=> 0xf0101f50 <spin_lock+32>:	test   %eax,%eax
spin_lock (lk=0xf010f284 <kernel_lock>) at spinlock.c:28
28		while (xchg(&lk->locked, 1) != 0)
=> 0xf0101f52 <spin_lock+34>:	jne    0xf0101f49 <spin_lock+25>
0xf0101f52	28		while (xchg(&lk->locked, 1) != 0)
=> 0xf0101f49 <spin_lock+25>:	pause  
29			asm volatile ("pause");
=> 0xf0101f4d <spin_lock+29>:	lock xchg %eax,(%edx)
0xf0101f4d in xchg (newval=0x1, addr=0xf010f284 <kernel_lock>) at ./x86.h:319
319		asm volatile("lock; xchgl %0, %1" :
=> 0xf0101f50 <spin_lock+32>:	test   %eax,%eax
spin_lock (lk=0xf010f284 <kernel_lock>) at spinlock.c:28
28		while (xchg(&lk->locked, 1) != 0)
=> 0xf0101f52 <spin_lock+34>:	jne    0xf0101f49 <spin_lock+25>
0xf0101f52	28		while (xchg(&lk->locked, 1) != 0)
=> 0xf0101f49 <spin_lock+25>:	pause  
29			asm volatile ("pause");
=> 0xf0101f4d <spin_lock+29>:	lock xchg %eax,(%edx)
0xf0101f4d in xchg (newval=0x1, addr=0xf010f284 <kernel_lock>) at ./x86.h:319
319		asm volatile("lock; xchgl %0, %1" :
=> 0xf0101f50 <spin_lock+32>:	test   %eax,%eax
spin_lock (lk=0xf010f284 <kernel_lock>) at spinlock.c:28
28		while (xchg(&lk->locked, 1) != 0)
=> 0xf0101f52 <spin_lock+34>:	jne    0xf0101f49 <spin_lock+25>
0xf0101f52	28		while (xchg(&lk->locked, 1) != 0)
=> 0xf0101f49 <spin_lock+25>:	pause  
29			asm volatile ("pause");
=> 0xf0101f4d <spin_lock+29>:	lock xchg %eax,(%edx)
0xf0101f4d in xchg (newval=0x1, addr=0xf010f284 <kernel_lock>) at ./x86.h:319
319		asm volatile("lock; xchgl %0, %1" :
=> 0xf0101f50 <spin_lock+32>:	test   %eax,%eax
spin_lock (lk=0xf010f284 <kernel_lock>) at spinlock.c:28
28		while (xchg(&lk->locked, 1) != 0)
=> 0xf0101f52 <spin_lock+34>:	jne    0xf0101f49 <spin_lock+25>
0xf0101f52	28		while (xchg(&lk->locked, 1) != 0)
=> 0xf0101f49 <spin_lock+25>:	pause  
29			asm volatile ("pause");
=> 0xf0101f4d <spin_lock+29>:	lock xchg %eax,(%edx)
0xf0101f4d in xchg (newval=0x1, addr=0xf010f284 <kernel_lock>) at ./x86.h:319
319		asm volatile("lock; xchgl %0, %1" :
=> 0xf0101f50 <spin_lock+32>:	test   %eax,%eax
spin_lock (lk=0xf010f284 <kernel_lock>) at spinlock.c:28
28		while (xchg(&lk->locked, 1) != 0)
=> 0xf0101f52 <spin_lock+34>:	jne    0xf0101f49 <spin_lock+25>
0xf0101f52	28		while (xchg(&lk->locked, 1) != 0)
=> 0xf0101f49 <spin_lock+25>:	pause  
29			asm volatile ("pause");
=> 0xf0101f4d <spin_lock+29>:	lock xchg %eax,(%edx)
0xf0101f4d in xchg (newval=0x1, addr=0xf010f284 <kernel_lock>) at ./x86.h:319
319		asm volatile("lock; xchgl %0, %1" :
=> 0xf0101f50 <spin_lock+32>:	test   %eax,%eax
spin_lock (lk=0xf010f284 <kernel_lock>) at spinlock.c:28
28		while (xchg(&lk->locked, 1) != 0)
=> 0xf0101f52 <spin_lock+34>:	jne    0xf0101f49 <spin_lock+25>
0xf0101f52	28		while (xchg(&lk->locked, 1) != 0)
=> 0xf0101f49 <spin_lock+25>:	pause  
29			asm volatile ("pause");
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Breakpoint 1 at 0xf0100040: file init.c, line 49.
Breakpoint 2 at 0xf0100062: file init.c, line 60.
Continuing.
The target architecture is assumed to be i386
=> 0xf0100040 <shitA>:	push   %ebp

Breakpoint 1, shitA () at init.c:49
49	{
Continuing.
=> 0xf0100062 <shitB>:	push   %ebp

Breakpoint 2, shitB () at init.c:60
60	{
Continuing.
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Breakpoint 1 at 0xf0100040: file init.c, line 49.
Breakpoint 2 at 0xf0100062: file init.c, line 60.
Continuing.
The target architecture is assumed to be i386
=> 0xf0100040 <shitA>:	push   %ebp

Breakpoint 1, shitA () at init.c:49
49	{
Continuing.
=> 0xf0100062 <shitB>:	push   %ebp

Breakpoint 2, shitB () at init.c:60
60	{
=> 0xf0100063 <shitB+1>:	mov    %esp,%ebp
0xf0100063	60	{
=> 0xf0100065 <shitB+3>:	sub    $0x8,%esp
0xf0100065 in shitB () at init.c:60
60	{
=> 0xf0100068 <shitB+6>:	sub    $0xc,%esp
63			cprintf("fuck im B\n");
=> 0xf010006b <shitB+9>:	push   $0xf0102a0b
0xf010006b	63			cprintf("fuck im B\n");
Continuing.
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Breakpoint 1 at 0xf0100040: file init.c, line 49.
Breakpoint 2 at 0xf0101edf: file env.c, line 551.
Continuing.
The target architecture is assumed to be i386
=> 0xf0101edf <env_pop_tf+10>:	pop    %es

Breakpoint 2, 0xf0101edf in env_pop_tf (tf=<error reading variable: Cannot access memory at address 0x8>) at env.c:551
551		__asm __volatile("movl %0,%%esp\n"
Continuing.
=> 0xf0100040 <shitA>:	push   %ebp

Breakpoint 1, shitA () at init.c:49
49	{
=> 0xf0100041 <shitA+1>:	mov    %esp,%ebp
0xf0100041	49	{
=> 0xf0100043 <shitA+3>:	sub    $0x8,%esp
0xf0100043 in shitA () at init.c:49
49	{
=> 0xf0100046 <shitA+6>:	sub    $0xc,%esp
52			cprintf("fuck im A\n");
=> 0xf0100049 <shitA+9>:	push   $0xf0102a00
0xf0100049	52			cprintf("fuck im A\n");
=> 0xf010004e <shitA+14>:	call   0xf0102543 <cprintf>
0xf010004e	52			cprintf("fuck im A\n");
=> 0xf0102543 <cprintf>:	push   %ebp
cprintf (fmt=0xf0102a00 "fuck im A\n") at stdio.c:39
39	{
=> 0xf0102544 <cprintf+1>:	mov    %esp,%ebp
0xf0102544	39	{
=> 0xf0102546 <cprintf+3>:	sub    $0x10,%esp
0xf0102546	39	{
=> 0xf0102549 <cprintf+6>:	lea    0xc(%ebp),%eax
43		va_start(ap, fmt);
=> 0xf010254c <cprintf+9>:	push   %eax
44		cnt = vcprintf(fmt, ap);
=> 0xf010254d <cprintf+10>:	pushl  0x8(%ebp)
0xf010254d	44		cnt = vcprintf(fmt, ap);
=> 0xf0102550 <cprintf+13>:	call   0xf010251d <vcprintf>
0xf0102550	44		cnt = vcprintf(fmt, ap);
=> 0xf010251d <vcprintf>:	push   %ebp
vcprintf (fmt=0xf0102a00 "fuck im A\n", ap=0xf0117024 "\020") at stdio.c:30
30	{
=> 0xf010251e <vcprintf+1>:	mov    %esp,%ebp
0xf010251e	30	{
=> 0xf0102520 <vcprintf+3>:	sub    $0x18,%esp
0xf0102520	30	{
=> 0xf0102523 <vcprintf+6>:	movl   $0x0,-0xc(%ebp)
31		int cnt = 0;
=> 0xf010252a <vcprintf+13>:	pushl  0xc(%ebp)
33		vprintfmt((void*)putch, &cnt, fmt, ap);
=> 0xf010252d <vcprintf+16>:	pushl  0x8(%ebp)
0xf010252d	33		vprintfmt((void*)putch, &cnt, fmt, ap);
=> 0xf0102530 <vcprintf+19>:	lea    -0xc(%ebp),%eax
0xf0102530	33		vprintfmt((void*)putch, &cnt, fmt, ap);
=> 0xf0102533 <vcprintf+22>:	push   %eax
0xf0102533	33		vprintfmt((void*)putch, &cnt, fmt, ap);
=> 0xf0102534 <vcprintf+23>:	push   $0xf0102115
0xf0102534	33		vprintfmt((void*)putch, &cnt, fmt, ap);
=> 0xf0102539 <vcprintf+28>:	call   0xf0102132 <vprintfmt>
0xf0102539	33		vprintfmt((void*)putch, &cnt, fmt, ap);
=> 0xf0102132 <vprintfmt>:	push   %ebp
vprintfmt (putch=0xf0102115 <putch>, putdat=0xf0116fec, fmt=0xf0102a00 "fuck im A\n", ap=0xf0117024 "\020") at stdio.c:105
105	{
=> 0xf0102133 <vprintfmt+1>:	mov    %esp,%ebp
0xf0102133	105	{
=> 0xf0102135 <vprintfmt+3>:	push   %edi
0xf0102135	105	{
=> 0xf0102136 <vprintfmt+4>:	push   %esi
0xf0102136	105	{
=> 0xf0102137 <vprintfmt+5>:	push   %ebx
0xf0102137	105	{
=> 0xf0102138 <vprintfmt+6>:	sub    $0x2c,%esp
0xf0102138	105	{
=> 0xf010213b <vprintfmt+9>:	mov    0xc(%ebp),%edi
0xf010213b	105	{
=> 0xf010213e <vprintfmt+12>:	jmp    0xf0102143 <vprintfmt+17>
0xf010213e	105	{
=> 0xf0102143 <vprintfmt+17>:	mov    0x10(%ebp),%eax
113			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0102146 <vprintfmt+20>:	lea    0x1(%eax),%esi
0xf0102146	113			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0102149 <vprintfmt+23>:	movzbl (%eax),%eax
0xf0102149	113			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf010214c <vprintfmt+26>:	cmp    $0x25,%eax
0xf010214c	113			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf010214f <vprintfmt+29>:	je     0xf010217d <vprintfmt+75>
0xf010214f	113			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0102151 <vprintfmt+31>:	test   %eax,%eax
114				if (ch == '\0')
=> 0xf0102153 <vprintfmt+33>:	jne    0xf0102164 <vprintfmt+50>
0xf0102153	114				if (ch == '\0')
=> 0xf0102164 <vprintfmt+50>:	mov    0x8(%ebp),%ebx
0xf0102164	114				if (ch == '\0')
=> 0xf0102167 <vprintfmt+53>:	sub    $0x8,%esp
116				putch(ch, putdat);
=> 0xf010216a <vprintfmt+56>:	push   %edi
0xf010216a	116				putch(ch, putdat);
=> 0xf010216b <vprintfmt+57>:	push   %eax
0xf010216b	116				putch(ch, putdat);
=> 0xf010216c <vprintfmt+58>:	call   *%ebx
0xf010216c	116				putch(ch, putdat);
=> 0xf0102115 <putch>:	push   %ebp
putch (ch=0x66, cnt=0xf0116fec) at stdio.c:23
23	{
=> 0xf0102116 <putch+1>:	mov    %esp,%ebp
0xf0102116	23	{
=> 0xf0102118 <putch+3>:	push   %ebx
0xf0102118	23	{
=> 0xf0102119 <putch+4>:	sub    $0x10,%esp
0xf0102119	23	{
=> 0xf010211c <putch+7>:	mov    0xc(%ebp),%ebx
0xf010211c	23	{
=> 0xf010211f <putch+10>:	pushl  0x8(%ebp)
24		cputchar(ch);
=> 0xf0102122 <putch+13>:	call   0xf01005f5 <cputchar>
0xf0102122	24		cputchar(ch);
=> 0xf01005f5 <cputchar>:	push   %ebp
cputchar (c=0x66) at console.c:436
436	{
=> 0xf01005f6 <cputchar+1>:	mov    %esp,%ebp
0xf01005f6	436	{
=> 0xf01005f8 <cputchar+3>:	sub    $0x8,%esp
0xf01005f8	436	{
=> 0xf01005fb <cputchar+6>:	mov    0x8(%ebp),%eax
437		cons_putc(c);
=> 0xf01005fe <cputchar+9>:	call   0xf0100147 <cons_putc>
0xf01005fe	437		cons_putc(c);
=> 0xf0100147 <cons_putc>:	push   %ebp
cons_putc (c=c@entry=0x66) at console.c:200
200	{
=> 0xf0100148 <cons_putc+1>:	mov    %esp,%ebp
0xf0100148	200	{
=> 0xf010014a <cons_putc+3>:	push   %edi
0xf010014a	200	{
=> 0xf010014b <cons_putc+4>:	push   %esi
0xf010014b	200	{
=> 0xf010014c <cons_putc+5>:	push   %ebx
0xf010014c	200	{
=> 0xf010014d <cons_putc+6>:	sub    $0xc,%esp
0xf010014d	200	{
=> 0xf0100150 <cons_putc+9>:	mov    %eax,%edi
0xf0100150	200	{
=> 0xf0100152 <cons_putc+11>:	mov    $0x3fd,%edx
inb (port=0x3fd) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100157 <cons_putc+16>:	in     (%dx),%al
0xf0100157	68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100158 <cons_putc+17>:	test   $0x20,%al
serial_putc (c=0x66) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf010015a <cons_putc+19>:	jne    0xf010017d <cons_putc+54>
0xf010015a	68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf010017d <cons_putc+54>:	cmp    $0x8,%edi
72		if (c == '\b') {
=> 0xf0100180 <cons_putc+57>:	jne    0xf01001fb <cons_putc+180>
0xf0100180	72		if (c == '\b') {
=> 0xf01001fb <cons_putc+180>:	mov    $0x3f8,%edx
0xf01001fb in outb (data=0x66, port=0x3f8) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100200 <cons_putc+185>:	mov    %edi,%eax
0xf0100200	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100202 <cons_putc+187>:	out    %al,(%dx)
0xf0100202	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100203 <cons_putc+188>:	test   $0xffffff00,%edi
cga_putc (c=0x66) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100209 <cons_putc+194>:	jne    0xf0100211 <cons_putc+202>
0xf0100209	155		if (!(c & ~0xFF))
=> 0xf010020b <cons_putc+196>:	or     $0x700,%edi
156			c |= 0x0700;
=> 0xf0100211 <cons_putc+202>:	mov    %edi,%eax
158		switch (c & 0xff) {
=> 0xf0100213 <cons_putc+204>:	movzbl %al,%eax
0xf0100213	158		switch (c & 0xff) {
=> 0xf0100216 <cons_putc+207>:	cmp    $0x9,%eax
0xf0100216	158		switch (c & 0xff) {
=> 0xf0100219 <cons_putc+210>:	je     0xf010028f <cons_putc+328>
0xf0100219	158		switch (c & 0xff) {
=> 0xf010021b <cons_putc+212>:	cmp    $0x9,%eax
0xf010021b	158		switch (c & 0xff) {
=> 0xf010021e <cons_putc+215>:	jg     0xf010022a <cons_putc+227>
0xf010021e	158		switch (c & 0xff) {
=> 0xf010022a <cons_putc+227>:	cmp    $0xa,%eax
0xf010022a	158		switch (c & 0xff) {
=> 0xf010022d <cons_putc+230>:	je     0xf0100269 <cons_putc+290>
0xf010022d	158		switch (c & 0xff) {
=> 0xf010022f <cons_putc+232>:	cmp    $0xd,%eax
0xf010022f	158		switch (c & 0xff) {
=> 0xf0100232 <cons_putc+235>:	je     0xf0100271 <cons_putc+298>
0xf0100232	158		switch (c & 0xff) {
=> 0xf0100234 <cons_putc+237>:	jmp    0xf01002b9 <cons_putc+370>
0xf0100234	158		switch (c & 0xff) {
=> 0xf01002b9 <cons_putc+370>:	movzwl 0xf010e9a8,%eax
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf01002c0 <cons_putc+377>:	lea    0x1(%eax),%edx
0xf01002c0	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf01002c3 <cons_putc+380>:	mov    %dx,0xf010e9a8
0xf01002c3	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf01002ca <cons_putc+387>:	movzwl %ax,%eax
0xf01002ca	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf01002cd <cons_putc+390>:	mov    0xf010e9ac,%edx
0xf01002cd	178			crt_buf[crt_pos++] = c;		/* write the character */
Breakpoint 3 at 0xf0101ef9: file env.c, line 571.
Continuing.
=> 0xf0101ef9 <env_run>:	push   %ebp

Breakpoint 3, env_run (e=0xf011707c) at env.c:571
571	{
Continuing.
=> 0xf0101edf <env_pop_tf+10>:	pop    %es

Breakpoint 2, 0xf0101edf in env_pop_tf (tf=<error reading variable: Cannot access memory at address 0x8>) at env.c:551
551		__asm __volatile("movl %0,%%esp\n"
Continuing.
=> 0xf0101ef9 <env_run>:	push   %ebp

Breakpoint 3, env_run (e=0xf011707c) at env.c:571
571	{
=> 0xf0101efa <env_run+1>:	mov    %esp,%ebp
0xf0101efa	571	{
=> 0xf0101efc <env_run+3>:	push   %ebx
0xf0101efc	571	{
=> 0xf0101efd <env_run+4>:	sub    $0x4,%esp
0xf0101efd	571	{
=> 0xf0101f00 <env_run+7>:	mov    0x8(%ebp),%ebx
0xf0101f00	571	{
=> 0xf0101f03 <env_run+10>:	mov    0xf010f26c,%eax
589		if (curenv != e)
=> 0xf0101f08 <env_run+15>:	cmp    %ebx,%eax
0xf0101f08	589		if (curenv != e)
=> 0xf0101f0a <env_run+17>:	je     0xf0101f39 <env_run+64>
0xf0101f0a	589		if (curenv != e)
=> 0xf0101f39 <env_run+64>:	sub    $0xc,%esp
unlock_kernel () at ./spinlock.h:29
29		spin_unlock(&kernel_lock);
=> 0xf0101f3c <env_run+67>:	push   $0xf010f284
0xf0101f3c	29		spin_unlock(&kernel_lock);
=> 0xf0101f41 <env_run+72>:	call   0xf0101f90 <spin_unlock>
0xf0101f41	29		spin_unlock(&kernel_lock);
=> 0xf0101f90 <spin_unlock>:	push   %ebp
spin_unlock (lk=0xf010f284 <kernel_lock>) at spinlock.c:35
35	{
=> 0xf0101f91 <spin_unlock+1>:	mov    %esp,%ebp
0xf0101f91	35	{
=> 0xf0101f93 <spin_unlock+3>:	mov    0x8(%ebp),%edx
0xf0101f93	35	{
=> 0xf0101f96 <spin_unlock+6>:	mov    $0x0,%eax
xchg (newval=0x0, addr=0xf010f284 <kernel_lock>) at ./x86.h:319
319		asm volatile("lock; xchgl %0, %1" :
=> 0xf0101f9b <spin_unlock+11>:	lock xchg %eax,(%edx)
0xf0101f9b	319		asm volatile("lock; xchgl %0, %1" :
=> 0xf0101f9e <spin_unlock+14>:	pop    %ebp
spin_unlock (lk=0xf010f284 <kernel_lock>) at spinlock.c:47
47	}
=> 0xf0101f9f <spin_unlock+15>:	ret    
0xf0101f9f in spin_unlock (lk=0xf010f284 <kernel_lock>) at spinlock.c:47
47	}
=> 0xf0101f46 <env_run+77>:	pause  
unlock_kernel () at ./spinlock.h:35
35		asm volatile("pause");
=> 0xf0101f4f <env_run+86>:	call   0xf0102543 <cprintf>
0xf0101f4f in env_run (e=0xf011707c) at env.c:599
599		cprintf("env_run done!\n");
=> 0xf0102543 <cprintf>:	push   %ebp
cprintf (fmt=0xf01032d1 "env_run done!\n") at stdio.c:39
39	{
=> 0xf0102544 <cprintf+1>:	mov    %esp,%ebp
0xf0102544	39	{
=> 0xf0102546 <cprintf+3>:	sub    $0x10,%esp
0xf0102546	39	{
=> 0xf0102549 <cprintf+6>:	lea    0xc(%ebp),%eax
43		va_start(ap, fmt);
=> 0xf010254c <cprintf+9>:	push   %eax
44		cnt = vcprintf(fmt, ap);
=> 0xf010254d <cprintf+10>:	pushl  0x8(%ebp)
0xf010254d	44		cnt = vcprintf(fmt, ap);
=> 0xf0102550 <cprintf+13>:	call   0xf010251d <vcprintf>
0xf0102550	44		cnt = vcprintf(fmt, ap);
=> 0xf010251d <vcprintf>:	push   %ebp
vcprintf (fmt=0xf01032d1 "env_run done!\n", ap=0xf0116ef0 "\bo\021\360:0\020\360Do\021\360\n") at stdio.c:30
30	{
=> 0xf010251e <vcprintf+1>:	mov    %esp,%ebp
0xf010251e	30	{
=> 0xf0102520 <vcprintf+3>:	sub    $0x18,%esp
0xf0102520	30	{
=> 0xf0102523 <vcprintf+6>:	movl   $0x0,-0xc(%ebp)
31		int cnt = 0;
=> 0xf010252a <vcprintf+13>:	pushl  0xc(%ebp)
33		vprintfmt((void*)putch, &cnt, fmt, ap);
=> 0xf010252d <vcprintf+16>:	pushl  0x8(%ebp)
0xf010252d	33		vprintfmt((void*)putch, &cnt, fmt, ap);
=> 0xf0102530 <vcprintf+19>:	lea    -0xc(%ebp),%eax
0xf0102530	33		vprintfmt((void*)putch, &cnt, fmt, ap);
=> 0xf0102533 <vcprintf+22>:	push   %eax
0xf0102533	33		vprintfmt((void*)putch, &cnt, fmt, ap);
=> 0xf0102534 <vcprintf+23>:	push   $0xf0102115
0xf0102534	33		vprintfmt((void*)putch, &cnt, fmt, ap);
=> 0xf0102539 <vcprintf+28>:	call   0xf0102132 <vprintfmt>
0xf0102539	33		vprintfmt((void*)putch, &cnt, fmt, ap);
=> 0xf0102132 <vprintfmt>:	push   %ebp
vprintfmt (putch=0xf0102115 <putch>, putdat=0xf0116eb8, fmt=0xf01032d1 "env_run done!\n", ap=0xf0116ef0 "\bo\021\360:0\020\360Do\021\360\n") at stdio.c:105
105	{
=> 0xf0102133 <vprintfmt+1>:	mov    %esp,%ebp
0xf0102133	105	{
=> 0xf0102135 <vprintfmt+3>:	push   %edi
0xf0102135	105	{
=> 0xf0102136 <vprintfmt+4>:	push   %esi
0xf0102136	105	{
=> 0xf0102137 <vprintfmt+5>:	push   %ebx
0xf0102137	105	{
=> 0xf0102138 <vprintfmt+6>:	sub    $0x2c,%esp
0xf0102138	105	{
=> 0xf010213b <vprintfmt+9>:	mov    0xc(%ebp),%edi
0xf010213b	105	{
=> 0xf010213e <vprintfmt+12>:	jmp    0xf0102143 <vprintfmt+17>
0xf010213e	105	{
=> 0xf0102143 <vprintfmt+17>:	mov    0x10(%ebp),%eax
113			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0102146 <vprintfmt+20>:	lea    0x1(%eax),%esi
0xf0102146	113			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0102149 <vprintfmt+23>:	movzbl (%eax),%eax
0xf0102149	113			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf010214c <vprintfmt+26>:	cmp    $0x25,%eax
0xf010214c	113			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf010214f <vprintfmt+29>:	je     0xf010217d <vprintfmt+75>
0xf010214f	113			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0102151 <vprintfmt+31>:	test   %eax,%eax
114				if (ch == '\0')
=> 0xf0102153 <vprintfmt+33>:	jne    0xf0102164 <vprintfmt+50>
0xf0102153	114				if (ch == '\0')
=> 0xf0102164 <vprintfmt+50>:	mov    0x8(%ebp),%ebx
0xf0102164	114				if (ch == '\0')
=> 0xf0102167 <vprintfmt+53>:	sub    $0x8,%esp
116				putch(ch, putdat);
=> 0xf010216a <vprintfmt+56>:	push   %edi
0xf010216a	116				putch(ch, putdat);
=> 0xf010216b <vprintfmt+57>:	push   %eax
0xf010216b	116				putch(ch, putdat);
=> 0xf010216c <vprintfmt+58>:	call   *%ebx
0xf010216c	116				putch(ch, putdat);
=> 0xf0102115 <putch>:	push   %ebp
putch (ch=0x65, cnt=0xf0116eb8) at stdio.c:23
23	{
=> 0xf0102116 <putch+1>:	mov    %esp,%ebp
0xf0102116	23	{
=> 0xf0102118 <putch+3>:	push   %ebx
0xf0102118	23	{
=> 0xf0102119 <putch+4>:	sub    $0x10,%esp
0xf0102119	23	{
=> 0xf010211c <putch+7>:	mov    0xc(%ebp),%ebx
0xf010211c	23	{
=> 0xf010211f <putch+10>:	pushl  0x8(%ebp)
24		cputchar(ch);
=> 0xf0102122 <putch+13>:	call   0xf01005f5 <cputchar>
0xf0102122	24		cputchar(ch);
=> 0xf01005f5 <cputchar>:	push   %ebp
cputchar (c=0x65) at console.c:436
436	{
=> 0xf01005f6 <cputchar+1>:	mov    %esp,%ebp
0xf01005f6	436	{
=> 0xf01005f8 <cputchar+3>:	sub    $0x8,%esp
0xf01005f8	436	{
=> 0xf01005fb <cputchar+6>:	mov    0x8(%ebp),%eax
437		cons_putc(c);
=> 0xf01005fe <cputchar+9>:	call   0xf0100147 <cons_putc>
0xf01005fe	437		cons_putc(c);
=> 0xf0100147 <cons_putc>:	push   %ebp
cons_putc (c=c@entry=0x65) at console.c:200
200	{
=> 0xf0100148 <cons_putc+1>:	mov    %esp,%ebp
0xf0100148	200	{
=> 0xf010014a <cons_putc+3>:	push   %edi
0xf010014a	200	{
=> 0xf010014b <cons_putc+4>:	push   %esi
0xf010014b	200	{
=> 0xf010014c <cons_putc+5>:	push   %ebx
0xf010014c	200	{
=> 0xf010014d <cons_putc+6>:	sub    $0xc,%esp
0xf010014d	200	{
=> 0xf0100150 <cons_putc+9>:	mov    %eax,%edi
0xf0100150	200	{
=> 0xf0100152 <cons_putc+11>:	mov    $0x3fd,%edx
inb (port=0x3fd) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100157 <cons_putc+16>:	in     (%dx),%al
0xf0100157	68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100158 <cons_putc+17>:	test   $0x20,%al
serial_putc (c=0x65) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf010015a <cons_putc+19>:	jne    0xf010017d <cons_putc+54>
0xf010015a	68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf010017d <cons_putc+54>:	cmp    $0x8,%edi
72		if (c == '\b') {
=> 0xf0100180 <cons_putc+57>:	jne    0xf01001fb <cons_putc+180>
0xf0100180	72		if (c == '\b') {
=> 0xf01001fb <cons_putc+180>:	mov    $0x3f8,%edx
0xf01001fb in outb (data=0x65, port=0x3f8) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100200 <cons_putc+185>:	mov    %edi,%eax
0xf0100200	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100202 <cons_putc+187>:	out    %al,(%dx)
0xf0100202	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100203 <cons_putc+188>:	test   $0xffffff00,%edi
cga_putc (c=0x65) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100209 <cons_putc+194>:	jne    0xf0100211 <cons_putc+202>
0xf0100209	155		if (!(c & ~0xFF))
=> 0xf010020b <cons_putc+196>:	or     $0x700,%edi
156			c |= 0x0700;
=> 0xf0100211 <cons_putc+202>:	mov    %edi,%eax
158		switch (c & 0xff) {
=> 0xf0100213 <cons_putc+204>:	movzbl %al,%eax
0xf0100213	158		switch (c & 0xff) {
=> 0xf0100216 <cons_putc+207>:	cmp    $0x9,%eax
0xf0100216	158		switch (c & 0xff) {
=> 0xf0100219 <cons_putc+210>:	je     0xf010028f <cons_putc+328>
0xf0100219	158		switch (c & 0xff) {
=> 0xf010021b <cons_putc+212>:	cmp    $0x9,%eax
0xf010021b	158		switch (c & 0xff) {
=> 0xf010021e <cons_putc+215>:	jg     0xf010022a <cons_putc+227>
0xf010021e	158		switch (c & 0xff) {
=> 0xf010022a <cons_putc+227>:	cmp    $0xa,%eax
0xf010022a	158		switch (c & 0xff) {
=> 0xf010022d <cons_putc+230>:	je     0xf0100269 <cons_putc+290>
0xf010022d	158		switch (c & 0xff) {
=> 0xf010022f <cons_putc+232>:	cmp    $0xd,%eax
0xf010022f	158		switch (c & 0xff) {
=> 0xf010033a <cons_putc+499>:	lea    0x1(%ecx),%esi
0xf010033a	192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf010035a <cons_putc+531>:	ret    
0xf010035a in cons_putc (c=<optimized out>) at console.c:203
203	}
=> 0xf0102167 <vprintfmt+53>:	sub    $0x8,%esp
116				putch(ch, putdat);
=> 0xf0100147 <cons_putc>:	push   %ebp
cons_putc (c=c@entry=0x6e) at console.c:200
200	{
=> 0xf0100203 <cons_putc+188>:	test   $0xffffff00,%edi
cga_putc (c=0x6e) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf01002c3 <cons_putc+380>:	mov    %dx,0xf010e9a8
0xf01002c3	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100346 <cons_putc+511>:	mov    $0xf,%eax
0xf0100346 in outb (data=0xf, port=0x3d4) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf010212d <putch+24>:	mov    -0x4(%ebp),%ebx
0xf010212d	26	}
=> 0xf0102116 <putch+1>:	mov    %esp,%ebp
0xf0102116	23	{
=> 0xf010014d <cons_putc+6>:	sub    $0xc,%esp
0xf010014d	200	{
=> 0xf0100216 <cons_putc+207>:	cmp    $0x9,%eax
0xf0100216	158		switch (c & 0xff) {
=> 0xf01002e0 <cons_putc+409>:	jbe    0xf0100325 <cons_putc+478>
0xf01002e0	182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100352 <cons_putc+523>:	out    %al,(%dx)
0xf0100352	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0102175 <vprintfmt+67>:	add    $0x10,%esp
0xf0102175	113			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0102122 <putch+13>:	call   0xf01005f5 <cputchar>
0xf0102122	24		cputchar(ch);
=> 0xf010015a <cons_putc+19>:	jne    0xf010017d <cons_putc+54>
0xf010015a	68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf010022d <cons_putc+230>:	je     0xf0100269 <cons_putc+290>
0xf010022d	158		switch (c & 0xff) {
=> 0xf0100333 <cons_putc+492>:	movzwl 0xf010e9a8,%ebx
cga_putc (c=<optimized out>) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100359 <cons_putc+530>:	pop    %ebp
0xf0100359	203	}
=> 0xf0102162 <vprintfmt+48>:	jmp    0xf0102167 <vprintfmt+53>
0xf0102162	114				if (ch == '\0')
=> 0xf01005fe <cputchar+9>:	call   0xf0100147 <cons_putc>
0xf01005fe	437		cons_putc(c);
=> 0xf0100202 <cons_putc+187>:	out    %al,(%dx)
0xf0100202	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01002c0 <cons_putc+377>:	lea    0x1(%eax),%edx
0xf01002c0	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100345 <cons_putc+510>:	out    %al,(%dx)
0xf0100345	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf010212a <putch+21>:	add    $0x10,%esp
26	}
=> 0xf0102115 <putch>:	push   %ebp
putch (ch=0x75, cnt=0xf0116eb8) at stdio.c:23
23	{
=> 0xf010014c <cons_putc+5>:	push   %ebx
0xf010014c	200	{
=> 0xf0100213 <cons_putc+204>:	movzbl %al,%eax
0xf0100213	158		switch (c & 0xff) {
=> 0xf01002d7 <cons_putc+400>:	cmpw   $0x7cf,0xf010e9a8
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100350 <cons_putc+521>:	mov    %esi,%edx
0xf0100350	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0102171 <vprintfmt+63>:	movzbl -0x1(%esi),%eax
0xf0102171	113			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf010211f <putch+10>:	pushl  0x8(%ebp)
24		cputchar(ch);
=> 0xf0100158 <cons_putc+17>:	test   $0x20,%al
serial_putc (c=0x6e) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf010022a <cons_putc+227>:	cmp    $0xa,%eax
0xf010022a	158		switch (c & 0xff) {
=> 0xf0100332 <cons_putc+491>:	out    %al,(%dx)
0xf0100332	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100358 <cons_putc+529>:	pop    %edi
0xf0100358	203	}
=> 0xf010215c <vprintfmt+42>:	je     0xf0102515 <vprintfmt+995>
0xf010215c	114				if (ch == '\0')
=> 0xf01005fb <cputchar+6>:	mov    0x8(%ebp),%eax
437		cons_putc(c);
=> 0xf0100200 <cons_putc+185>:	mov    %edi,%eax
0xf0100200	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01002b9 <cons_putc+370>:	movzwl 0xf010e9a8,%eax
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100343 <cons_putc+508>:	mov    %esi,%edx
0xf0100343	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0102127 <putch+18>:	addl   $0x1,(%ebx)
putch (ch=0x20, cnt=0xf0116eb8) at stdio.c:25
25		++(*cnt);
=> 0xf010216c <vprintfmt+58>:	call   *%ebx
0xf010216c	116				putch(ch, putdat);
=> 0xf010014b <cons_putc+4>:	push   %esi
0xf010014b	200	{
=> 0xf0100211 <cons_putc+202>:	mov    %edi,%eax
158		switch (c & 0xff) {
=> 0xf01002d3 <cons_putc+396>:	mov    %di,(%edx,%eax,2)
0xf01002d3	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf010034e <cons_putc+519>:	mov    %ebx,%eax
0xf010034e in outb (data=0x89, port=0x3d5) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf010216e <vprintfmt+60>:	add    $0x1,%esi
vprintfmt (putch=0xf0102115 <putch>, putdat=0xf0116eb8, fmt=0xf01032da "one!\n", ap=0xf0116ef0 "\bo\021\360:0\020\360Do\021\360\n") at stdio.c:113
113			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf010211c <putch+7>:	mov    0xc(%ebp),%ebx
0xf010211c	23	{
=> 0xf0100157 <cons_putc+16>:	in     (%dx),%al
0xf0100157	68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf010021e <cons_putc+215>:	jg     0xf010022a <cons_putc+227>
0xf010021e	158		switch (c & 0xff) {
=> 0xf0100330 <cons_putc+489>:	mov    %ecx,%edx
0xf0100330	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100357 <cons_putc+528>:	pop    %esi
0xf0100357	203	}
=> 0xf010215a <vprintfmt+40>:	test   %eax,%eax
0xf010215a	114				if (ch == '\0')
=> 0xf01005f8 <cputchar+3>:	sub    $0x8,%esp
0xf01005f8	436	{
=> 0xf01001fb <cons_putc+180>:	mov    $0x3f8,%edx
0xf01001fb in outb (data=0x6e, port=0x3f8) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100234 <cons_putc+237>:	jmp    0xf01002b9 <cons_putc+370>
0xf0100234	158		switch (c & 0xff) {
=> 0xf010033f <cons_putc+504>:	shr    $0x8,%ax
0xf010033f	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100604 <cputchar+15>:	ret    
0xf0100604 in cputchar (c=0x6e) at console.c:438
438	}
=> 0xf010216b <vprintfmt+57>:	push   %eax
0xf010216b	116				putch(ch, putdat);
=> 0xf010014a <cons_putc+3>:	push   %edi
0xf010014a	200	{
=> 0xf010020b <cons_putc+196>:	or     $0x700,%edi
156			c |= 0x0700;
=> 0xf01002cd <cons_putc+390>:	mov    0xf010e9ac,%edx
0xf01002cd	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf010034d <cons_putc+518>:	out    %al,(%dx)
0xf010034d	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0102131 <putch+28>:	ret    
0xf0102131 in putch (ch=0x65, cnt=0xf0116eb8) at stdio.c:26
26	}
=> 0xf0102119 <putch+4>:	sub    $0x10,%esp
0xf0102119	23	{
=> 0xf0100152 <cons_putc+11>:	mov    $0x3fd,%edx
inb (port=0x3fd) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf010021b <cons_putc+212>:	cmp    $0x9,%eax
0xf010021b	158		switch (c & 0xff) {
=> 0xf010032b <cons_putc+484>:	mov    $0xe,%eax
outb (data=0xe, port=0x3d4) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100356 <cons_putc+527>:	pop    %ebx
0xf0100356	203	}
=> 0xf010217b <vprintfmt+73>:	jne    0xf010215a <vprintfmt+40>
0xf010217b	113			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf01005f6 <cputchar+1>:	mov    %esp,%ebp
0xf01005f6	436	{
=> 0xf0100180 <cons_putc+57>:	jne    0xf01001fb <cons_putc+180>
0xf0100180	72		if (c == '\b') {
=> 0xf0100271 <cons_putc+298>:	movzwl 0xf010e9a8,%eax
169			crt_pos -= (crt_pos % CRT_COLS);
=> 0xf010280a <memmove>:	push   %ebp
memmove (dst=0xf00b8000, src=0xf00b80a0, n=0xf00) at string.c:136
136	{
=> 0xf0102862 <memmove+88>:	mov    %eax,%edi
0xf0102862	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
=> 0xf0102865 <memmove+91>:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102865	155				asm volatile("cld; rep movsl\n"
The history is empty.
List of classes of commands:

aliases -- Aliases of other commands
breakpoints -- Making program stop at certain points
data -- Examining data
files -- Specifying and examining files
internals -- Maintenance commands
obscure -- Obscure features
running -- Running the program
status -- Status inquiries
support -- Support facilities
tracepoints -- Tracing of program execution without stopping the program
user-defined -- User-defined commands

Type "help" followed by a class name for a list of commands in that class.
Type "help all" for the list of all commands.
Type "help" followed by command name for full documentation.
Type "apropos word" to search for commands related to "word".
Command name abbreviations are allowed if unambiguous.
Undefined command: "status".  Try "help".
  [32mEAX:[31m 0xF00B8000  [32mEBX:[31m 0xF0116EB8  [32mECX:[31m 0x000000B5  [32mEDX:[31m 0xF00B80A0  [1m[4m[31mo d i t s z a P c 
[0m  [32mESI:[31m 0xF00B8CCC  [32mEDI:[31m 0xF00B8C2C  [32mEBP:[31m 0xF0116DE4  [32mESP:[31m 0xF0116DDC  [32mEIP:[31m 0xF0102865
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0023  [32mGS:[30m 0023  [32mSS:[30m 0010[0m
=> 0xf0100319 <cons_putc+466>:	cmp    %eax,%edx
186			for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
=> 0xf010032b <cons_putc+484>:	mov    $0xe,%eax
outb (data=0xe, port=0x3d4) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0101edf <env_pop_tf+10>:	pop    %es

Breakpoint 2, 0xf0101edf in env_pop_tf (tf=<error reading variable: Cannot access memory at address 0x8>) at env.c:551
551		__asm __volatile("movl %0,%%esp\n"
=> 0xf0100f44 <trap_handle13+2>:	jmp    0xf0100f6c <_alltraps>
0xf0100f44 in trap_handle13 () at trapentry.S:61
61	TRAPHANDLER(trap_handle13, 13)
No symbol "tf" in current context.
Detaching from program: , Remote target
Ending remote debugging.

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Breakpoint 1 at 0xf0100062: file init.c, line 60.
Breakpoint 2 at 0xf0100040: file init.c, line 49.
Breakpoint 3 at 0xf0101ef4: file env.c, line 566.
Breakpoint 4 at 0xf01015ae: file trap.c, line 244.
#0  0x0000fff0 in ?? ()
[34m--------------------------------------------------------------------------[34m[1m[regs]
[0m  [32mEAX:[30m 0x00000000  [32mEBX:[30m 0x00000000  [32mECX:[30m 0x00000000  [32mEDX:[31m 0x00000663  [1m[4m[31mo d i t s z a p c 
[0m  [32mESI:[30m 0x00000000  [32mEDI:[30m 0x00000000  [32mEBP:[30m 0x00000000  [32mESP:[30m 0x00000000  [32mEIP:[31m 0x0000FFF0
  [32mCS:[30m F000  [32mDS:[30m 0000  [32mES:[30m 0000  [32mFS:[30m 0000  [32mGS:[30m 0000  [32mSS:[30m 0000[0m
[36m[34m[0x0000:0x00000000][34m------------------------------------------------------[34m[1m[stack]
[0m[1m0x00000050 : [0m00 00 00 00 00 00 00 00[1m - [0m00 00 00 00 00 00 00 00 [1m................[0m
[1m0x00000040 : [0m00 00 00 00 00 00 00 00[1m - [0m00 00 00 00 00 00 00 00 [1m................[0m
[1m0x00000030 : [0m00 00 00 00 00 00 00 00[1m - [0m00 00 00 00 00 00 00 00 [1m................[0m
[1m0x00000020 : [0m00 00 00 00 00 00 00 00[1m - [0m00 00 00 00 00 00 00 00 [1m................[0m
[1m0x00000010 : [0m00 00 00 00 00 00 00 00[1m - [0m00 00 00 00 00 00 00 00 [1m................[0m
[1m0x00000000 : [0m00 00 00 00 00 00 00 00[1m - [0m00 00 00 00 00 00 00 00 [1m................[0m
[0m[34m[0x0000:0x00000000][34m-------------------------------------------------------[1m[34m[data]
[0m[1m0x00000000 : [0m00 00 00 00 00 00 00 00[1m - [0m00 00 00 00 00 00 00 00 [1m................[0m
[1m0x00000010 : [0m00 00 00 00 00 00 00 00[1m - [0m00 00 00 00 00 00 00 00 [1m................[0m
[1m0x00000020 : [0m00 00 00 00 00 00 00 00[1m - [0m00 00 00 00 00 00 00 00 [1m................[0m
[1m0x00000030 : [0m00 00 00 00 00 00 00 00[1m - [0m00 00 00 00 00 00 00 00 [1m................[0m
[1m0x00000040 : [0m00 00 00 00 00 00 00 00[1m - [0m00 00 00 00 00 00 00 00 [1m................[0m
[1m0x00000050 : [0m00 00 00 00 00 00 00 00[1m - [0m00 00 00 00 00 00 00 00 [1m................[0m
[1m0x00000060 : [0m00 00 00 00 00 00 00 00[1m - [0m00 00 00 00 00 00 00 00 [1m................[0m
[1m0x00000070 : [0m00 00 00 00 00 00 00 00[1m - [0m00 00 00 00 00 00 00 00 [1m................[0m
[34m--------------------------------------------------------------------------[34m[1m[code]
[0m=> 0xfff0:	add    %al,(%bx,%si)
   0xfff2:	add    %al,(%bx,%si)
   0xfff4:	add    %al,(%bx,%si)
   0xfff6:	add    %al,(%bx,%si)
   0xfff8:	add    %al,(%bx,%si)
   0xfffa:	add    %al,(%bx,%si)
   0xfffc:	add    %al,(%bx,%si)
   0xfffe:	add    %al,(%bx,%si)
[34m--------------------------------------------------------------------------------
[0mContinuing.
The target architecture is assumed to be i386
=> 0xf0101ef4 <env_run>:	push   %ebp

Breakpoint 3, env_run (e=0xf0117000) at env.c:566
566	{
[34m--------------------------------------------------------------------------[34m[1m[regs]
[0m  [32mEAX:[31m 0xF0117000  [32mEBX:[31m 0xF0117000  [32mECX:[30m 0x00000000  [32mEDX:[31m 0x000003D5  [1m[4m[31mo d i t S z A P c 
[0m  [32mESI:[30m 0x00000000  [32mEDI:[30m 0x00000000  [32mEBP:[31m 0xF010BFD8  [32mESP:[31m 0xF010BFAC  [32mEIP:[31m 0xF0101EF4
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0023  [32mGS:[30m 0023  [32mSS:[30m 0010[0m
[36m[34m[0x0010:0xF010BFAC][34m------------------------------------------------------[34m[1m[stack]
[0m[1m0xF010BFFC : [0m3E 00 10 F0 21 D0 10 00[1m - [0m00 00 00 00 00 00 00 00 [1m>...!...........[0m
[1m0xF010BFEC : [0m00 00 00 00 00 00 00 00[1m - [0m00 00 00 00 00 00 00 00 [1m................[0m
[1m0xF010BFDC : [0mD7 00 10 F0 62 00 10 F0[1m - [0m00 00 00 00 18 0F 00 00 [1m....b...........[0m
[1m0xF010BFCC : [0m94 00 01 00 94 00 01 00[1m - [0m00 00 00 00 F8 BF 10 F0 [1m................[0m
[1m0xF010BFBC : [0mA1 1C 10 F0 9A 32 10 F0[1m - [0m00 00 00 00 01 10 00 00 [1m.....2..........[0m
[1m0xF010BFAC : [0mCC 17 10 F0 00 70 11 F0[1m - [0m00 00 00 00 D8 BF 10 F0 [1m.....p..........[0m
[0m[34m[0x0010:0xF010BFAC][34m-------------------------------------------------------[1m[34m[data]
[0m[1m0xF010BFAC : [0mCC 17 10 F0 00 70 11 F0[1m - [0m00 00 00 00 D8 BF 10 F0 [1m.....p..........[0m
[1m0xF010BFBC : [0mA1 1C 10 F0 9A 32 10 F0[1m - [0m00 00 00 00 01 10 00 00 [1m.....2..........[0m
[1m0xF010BFCC : [0m94 00 01 00 94 00 01 00[1m - [0m00 00 00 00 F8 BF 10 F0 [1m................[0m
[1m0xF010BFDC : [0mD7 00 10 F0 62 00 10 F0[1m - [0m00 00 00 00 18 0F 00 00 [1m....b...........[0m
[1m0xF010BFEC : [0m00 00 00 00 00 00 00 00[1m - [0m00 00 00 00 00 00 00 00 [1m................[0m
[1m0xF010BFFC : [0m3E 00 10 F0 21 D0 10 00[1m - [0m00 00 00 00 00 00 00 00 [1m>...!...........[0m
[1m0xF010C00C : [0m00 00 00 00 00 00 00 00[1m - [0m00 00 00 00 00 00 00 00 [1m................[0m
[1m0xF010C01C : [0m00 00 00 00 00 00 00 00[1m - [0m00 00 00 00 00 00 00 00 [1m................[0m
[34m--------------------------------------------------------------------------[34m[1m[code]
[0m=> 0xf0101ef4 <env_run>:	push   %ebp
   0xf0101ef5 <env_run+1>:	mov    %esp,%ebp
   0xf0101ef7 <env_run+3>:	push   %ebx
   0xf0101ef8 <env_run+4>:	sub    $0x4,%esp
   0xf0101efb <env_run+7>:	mov    0x8(%ebp),%ebx
   0xf0101efe <env_run+10>:	mov    0xf010f26c,%eax
   0xf0101f03 <env_run+15>:	cmp    %ebx,%eax
   0xf0101f05 <env_run+17>:	je     0xf0101f34 <env_run+64>
[34m--------------------------------------------------------------------------------
[0mContinuing.
=> 0xf0100040 <shitA>:	push   %ebp

Breakpoint 2, shitA () at init.c:49
49	{
Continuing.
=> 0xf01015ae <trap>:	push   %ebp

Breakpoint 4, trap (tf=0xf0116fe0) at trap.c:244
244	{
Continuing.
=> 0xf0101ef4 <env_run>:	push   %ebp

Breakpoint 3, env_run (e=0xf011707c) at env.c:566
566	{
Continuing.
=> 0xf0100062 <shitB>:	push   %ebp

Breakpoint 1, shitB () at init.c:60
60	{
Continuing.
=> 0xf01015ae <trap>:	push   %ebp

Breakpoint 4, trap (tf=0xf011705c) at trap.c:244
244	{
[34m--------------------------------------------------------------------------[34m[1m[regs]
[0m  [32mEAX:[31m 0x00000010  [32mEBX:[31m 0x00000000  [32mECX:[31m 0x000003D4  [32mEDX:[30m 0x000003D5  [1m[4m[31mo d i t S z a P c 
[0m  [32mESI:[30m 0x00000000  [32mEDI:[30m 0x00000000  [32mEBP:[31m 0xF01170B4  [32mESP:[31m 0xF0117054  [32mEIP:[31m 0xF01015AE
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0023  [32mGS:[30m 0023  [32mSS:[30m 0010[0m
[36m[34m[0x0010:0xF0117054][34m------------------------------------------------------[34m[1m[stack]
[0m[1m0xF01170A4 : [0m00 00 00 00 00 00 00 00[1m - [0m62 00 10 F0 08 00 00 00 [1m........b.......[0m
[1m0xF0117094 : [0m86 02 00 00 75 00 10 F0[1m - [0m0B 2A 10 F0 10 00 00 00 [1m....u....*......[0m
[1m0xF0117084 : [0m20 00 00 00 00 00 00 00[1m - [0m32 25 10 F0 08 00 00 00 [1m .......2%......[0m
[1m0xF0117074 : [0mD4 03 00 00 00 00 00 00[1m - [0m10 00 00 00 10 00 00 00 [1m................[0m
[1m0xF0117064 : [0mB4 70 11 F0 7C 70 11 F0[1m - [0m00 00 00 00 D5 03 00 00 [1m.p..|p..........[0m
[1m0xF0117054 : [0m7D 0F 10 F0 5C 70 11 F0[1m - [0m00 00 00 00 00 00 00 00 [1m}...\p..........[0m
[0m[34m[0x0010:0xF0117054][34m-------------------------------------------------------[1m[34m[data]
[0m[1m0xF0117054 : [0m7D 0F 10 F0 5C 70 11 F0[1m - [0m00 00 00 00 00 00 00 00 [1m}...\p..........[0m
[1m0xF0117064 : [0mB4 70 11 F0 7C 70 11 F0[1m - [0m00 00 00 00 D5 03 00 00 [1m.p..|p..........[0m
[1m0xF0117074 : [0mD4 03 00 00 00 00 00 00[1m - [0m10 00 00 00 10 00 00 00 [1m................[0m
[1m0xF0117084 : [0m20 00 00 00 00 00 00 00[1m - [0m32 25 10 F0 08 00 00 00 [1m .......2%......[0m
[1m0xF0117094 : [0m86 02 00 00 75 00 10 F0[1m - [0m0B 2A 10 F0 10 00 00 00 [1m....u....*......[0m
[1m0xF01170A4 : [0m00 00 00 00 00 00 00 00[1m - [0m62 00 10 F0 08 00 00 00 [1m........b.......[0m
[1m0xF01170B4 : [0m00 00 00 00 00 00 00 F0[1m - [0m10 00 00 00 F8 70 11 F0 [1m.............p..[0m
[1m0xF01170C4 : [0m01 10 00 00 00 00 00 00[1m - [0m01 00 00 00 03 00 00 00 [1m................[0m
[34m--------------------------------------------------------------------------[34m[1m[code]
[0m=> 0xf01015ae <trap>:	push   %ebp
   0xf01015af <trap+1>:	mov    %esp,%ebp
   0xf01015b1 <trap+3>:	push   %edi
   0xf01015b2 <trap+4>:	push   %esi
   0xf01015b3 <trap+5>:	mov    0x8(%ebp),%esi
   0xf01015b6 <trap+8>:	cld    
   0xf01015b7 <trap+9>:	movzwl 0x34(%esi),%eax
   0xf01015bb <trap+13>:	and    $0x3,%eax
[34m--------------------------------------------------------------------------------
[0m=> 0xf01015af <trap+1>:	mov    %esp,%ebp
0xf01015af	244	{
[34m--------------------------------------------------------------------------[34m[1m[regs]
[0m  [32mEAX:[30m 0x00000010  [32mEBX:[30m 0x00000000  [32mECX:[30m 0x000003D4  [32mEDX:[30m 0x000003D5  [1m[4m[31mo d i t S z a P c 
[0m  [32mESI:[30m 0x00000000  [32mEDI:[30m 0x00000000  [32mEBP:[30m 0xF01170B4  [32mESP:[31m 0xF0117050  [32mEIP:[31m 0xF01015AF
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0023  [32mGS:[30m 0023  [32mSS:[30m 0010[0m
[36m[34m[0x0010:0xF0117050][34m------------------------------------------------------[34m[1m[stack]
[0m[1m0xF01170A0 : [0m10 00 00 00 00 00 00 00[1m - [0m00 00 00 00 62 00 10 F0 [1m............b...[0m
[1m0xF0117090 : [0m08 00 00 00 86 02 00 00[1m - [0m75 00 10 F0 0B 2A 10 F0 [1m........u....*..[0m
[1m0xF0117080 : [0m10 00 00 00 20 00 00 00[1m - [0m00 00 00 00 32 25 10 F0 [1m.... .......2%..[0m
[1m0xF0117070 : [0mD5 03 00 00 D4 03 00 00[1m - [0m00 00 00 00 10 00 00 00 [1m................[0m
[1m0xF0117060 : [0m00 00 00 00 B4 70 11 F0[1m - [0m7C 70 11 F0 00 00 00 00 [1m.....p..|p......[0m
[1m0xF0117050 : [0mB4 70 11 F0 7D 0F 10 F0[1m - [0m5C 70 11 F0 00 00 00 00 [1m.p..}...\p......[0m
[0m[34m[0x0010:0xF0117050][34m-------------------------------------------------------[1m[34m[data]
[0m[1m0xF0117050 : [0mB4 70 11 F0 7D 0F 10 F0[1m - [0m5C 70 11 F0 00 00 00 00 [1m.p..}...\p......[0m
[1m0xF0117060 : [0m00 00 00 00 B4 70 11 F0[1m - [0m7C 70 11 F0 00 00 00 00 [1m.....p..|p......[0m
[1m0xF0117070 : [0mD5 03 00 00 D4 03 00 00[1m - [0m00 00 00 00 10 00 00 00 [1m................[0m
[1m0xF0117080 : [0m10 00 00 00 20 00 00 00[1m - [0m00 00 00 00 32 25 10 F0 [1m.... .......2%..[0m
[1m0xF0117090 : [0m08 00 00 00 86 02 00 00[1m - [0m75 00 10 F0 0B 2A 10 F0 [1m........u....*..[0m
[1m0xF01170A0 : [0m10 00 00 00 00 00 00 00[1m - [0m00 00 00 00 62 00 10 F0 [1m............b...[0m
[1m0xF01170B0 : [0m08 00 00 00 00 00 00 00[1m - [0m00 00 00 F0 10 00 00 00 [1m................[0m
[1m0xF01170C0 : [0mF8 70 11 F0 01 10 00 00[1m - [0m00 00 00 00 01 00 00 00 [1m.p..............[0m
[34m--------------------------------------------------------------------------[34m[1m[code]
[0m=> 0xf01015af <trap+1>:	mov    %esp,%ebp
   0xf01015b1 <trap+3>:	push   %edi
   0xf01015b2 <trap+4>:	push   %esi
   0xf01015b3 <trap+5>:	mov    0x8(%ebp),%esi
   0xf01015b6 <trap+8>:	cld    
   0xf01015b7 <trap+9>:	movzwl 0x34(%esi),%eax
   0xf01015bb <trap+13>:	and    $0x3,%eax
   0xf01015be <trap+16>:	cmp    $0x3,%ax
[34m--------------------------------------------------------------------------------
[0mInvalid character ';' in expression.
No symbol "context" in current context.
=> 0xf01015b1 <trap+3>:	push   %edi
0xf01015b1	244	{
=> 0xf01015b2 <trap+4>:	push   %esi
0xf01015b2	244	{
[34m--------------------------------------------------------------------------[34m[1m[regs]
[0m  [32mEAX:[30m 0x00000010  [32mEBX:[30m 0x00000000  [32mECX:[30m 0x000003D4  [32mEDX:[30m 0x000003D5  [1m[4m[31mo d i t S z a P c 
[0m  [32mESI:[30m 0x00000000  [32mEDI:[30m 0x00000000  [32mEBP:[31m 0xF0117050  [32mESP:[31m 0xF011704C  [32mEIP:[31m 0xF01015B2
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0023  [32mGS:[30m 0023  [32mSS:[30m 0010[0m
[36m[34m[0x0010:0xF011704C][34m------------------------------------------------------[34m[1m[stack]
[0m[1m0xF011709C : [0m0B 2A 10 F0 10 00 00 00[1m - [0m00 00 00 00 00 00 00 00 [1m.*..............[0m
[1m0xF011708C : [0m32 25 10 F0 08 00 00 00[1m - [0m86 02 00 00 75 00 10 F0 [1m2%..........u...[0m
[1m0xF011707C : [0m10 00 00 00 10 00 00 00[1m - [0m20 00 00 00 00 00 00 00 [1m........ .......[0m
[1m0xF011706C : [0m00 00 00 00 D5 03 00 00[1m - [0mD4 03 00 00 00 00 00 00 [1m................[0m
[1m0xF011705C : [0m00 00 00 00 00 00 00 00[1m - [0mB4 70 11 F0 7C 70 11 F0 [1m.........p..|p..[0m
[1m0xF011704C : [0m00 00 00 00 B4 70 11 F0[1m - [0m7D 0F 10 F0 5C 70 11 F0 [1m.....p..}...\p..[0m
[0m[34m[0x0010:0xF011704C][34m-------------------------------------------------------[1m[34m[data]
[0m[1m0xF011704C : [0m00 00 00 00 B4 70 11 F0[1m - [0m7D 0F 10 F0 5C 70 11 F0 [1m.....p..}...\p..[0m
[1m0xF011705C : [0m00 00 00 00 00 00 00 00[1m - [0mB4 70 11 F0 7C 70 11 F0 [1m.........p..|p..[0m
[1m0xF011706C : [0m00 00 00 00 D5 03 00 00[1m - [0mD4 03 00 00 00 00 00 00 [1m................[0m
[1m0xF011707C : [0m10 00 00 00 10 00 00 00[1m - [0m20 00 00 00 00 00 00 00 [1m........ .......[0m
[1m0xF011708C : [0m32 25 10 F0 08 00 00 00[1m - [0m86 02 00 00 75 00 10 F0 [1m2%..........u...[0m
[1m0xF011709C : [0m0B 2A 10 F0 10 00 00 00[1m - [0m00 00 00 00 00 00 00 00 [1m.*..............[0m
[1m0xF01170AC : [0m62 00 10 F0 08 00 00 00[1m - [0m00 00 00 00 00 00 00 F0 [1mb...............[0m
[1m0xF01170BC : [0m10 00 00 00 F8 70 11 F0[1m - [0m01 10 00 00 00 00 00 00 [1m.....p..........[0m
[34m--------------------------------------------------------------------------[34m[1m[code]
[0m=> 0xf01015b2 <trap+4>:	push   %esi
   0xf01015b3 <trap+5>:	mov    0x8(%ebp),%esi
   0xf01015b6 <trap+8>:	cld    
   0xf01015b7 <trap+9>:	movzwl 0x34(%esi),%eax
   0xf01015bb <trap+13>:	and    $0x3,%eax
   0xf01015be <trap+16>:	cmp    $0x3,%ax
   0xf01015c2 <trap+20>:	jne    0xf0101606 <trap+88>
   0xf01015c4 <trap+22>:	sub    $0xc,%esp
[34m--------------------------------------------------------------------------------
[0m$1 = (struct Trapframe *) 0xf011705c
$2 = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0xf01170b4, reg_oesp = 0xf011707c, reg_ebx = 0x0, reg_edx = 0x3d5, reg_ecx = 0x3d4, reg_eax = 0x0}, tf_es = 0x10, tf_padding1 = 0x0, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x20, tf_err = 0x0, tf_eip = 0xf0102532, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x286, tf_esp = 0xf0100075, tf_ss = 0x2a0b, tf_padding4 = 0xf010}
=> 0xf01015b3 <trap+5>:	mov    0x8(%ebp),%esi
0xf01015b3	244	{
=> 0xf01015b6 <trap+8>:	cld    
247		asm volatile("cld" ::: "cc");
=> 0xf01015b7 <trap+9>:	movzwl 0x34(%esi),%eax
250		if ((tf->tf_cs & 3) == 3) {
=> 0xf01015bb <trap+13>:	and    $0x3,%eax
0xf01015bb	250		if ((tf->tf_cs & 3) == 3) {
=> 0xf01015be <trap+16>:	cmp    $0x3,%ax
0xf01015be	250		if ((tf->tf_cs & 3) == 3) {
=> 0xf01015c2 <trap+20>:	jne    0xf0101606 <trap+88>
0xf01015c2	250		if ((tf->tf_cs & 3) == 3) {
=> 0xf0101606 <trap+88>:	mov    %esi,0xf010f1e0
272		last_tf = tf;
=> 0xf010160c <trap+94>:	sub    $0x8,%esp
trap_dispatch (tf=0xf011705c) at trap.c:188
188		cprintf("----Trap No: 0x%u\n", tf->tf_trapno);
=> 0xf010160f <trap+97>:	pushl  0x28(%esi)
0xf010160f	188		cprintf("----Trap No: 0x%u\n", tf->tf_trapno);
=> 0xf0101612 <trap+100>:	push   $0xf0103029
0xf0101612	188		cprintf("----Trap No: 0x%u\n", tf->tf_trapno);
=> 0xf0101617 <trap+105>:	call   0xf0102532 <cprintf>
0xf0101617	188		cprintf("----Trap No: 0x%u\n", tf->tf_trapno);
=> 0xf0102532 <cprintf>:	push   %ebp
cprintf (fmt=0xf0103029 "----Trap No: 0x%u\n") at stdio.c:39
39	{
=> 0xf0102533 <cprintf+1>:	mov    %esp,%ebp
0xf0102533	39	{
=> 0xf0102538 <cprintf+6>:	lea    0xc(%ebp),%eax
43		va_start(ap, fmt);
=> 0xf010253b <cprintf+9>:	push   %eax
44		cnt = vcprintf(fmt, ap);
=> 0xf0102512 <vcprintf+6>:	movl   $0x0,-0xc(%ebp)
vcprintf (fmt=0xf0103029 "----Trap No: 0x%u\n", ap=0xf011703c " ") at stdio.c:31
31		int cnt = 0;
=> 0xf0102519 <vcprintf+13>:	pushl  0xc(%ebp)
33		vprintfmt((void*)putch, &cnt, fmt, ap);
=> 0xf0101ef4 <env_run>:	push   %ebp

Breakpoint 3, env_run (e=0xf011707c) at env.c:566
566	{
=> 0xf0101ef5 <env_run+1>:	mov    %esp,%ebp
0xf0101ef5	566	{
=> 0xf0101ef7 <env_run+3>:	push   %ebx
0xf0101ef7	566	{
=> 0xf0101ef8 <env_run+4>:	sub    $0x4,%esp
0xf0101ef8	566	{
=> 0xf0101efb <env_run+7>:	mov    0x8(%ebp),%ebx
0xf0101efb	566	{
=> 0xf0101efe <env_run+10>:	mov    0xf010f26c,%eax
584		if (curenv != e)
=> 0xf0101f03 <env_run+15>:	cmp    %ebx,%eax
0xf0101f03	584		if (curenv != e)
=> 0xf0101f05 <env_run+17>:	je     0xf0101f34 <env_run+64>
0xf0101f05	584		if (curenv != e)
=> 0xf0101f34 <env_run+64>:	sub    $0xc,%esp
unlock_kernel () at ./spinlock.h:29
29		spin_unlock(&kernel_lock);
=> 0xf0101f37 <env_run+67>:	push   $0xf010f284
0xf0101f37	29		spin_unlock(&kernel_lock);
=> 0xf0101f3c <env_run+72>:	call   0xf0101f7f <spin_unlock>
0xf0101f3c	29		spin_unlock(&kernel_lock);
=> 0xf0101f7f <spin_unlock>:	push   %ebp
spin_unlock (lk=0xf010f284 <kernel_lock>) at spinlock.c:35
35	{
=> 0xf0101f85 <spin_unlock+6>:	mov    $0x0,%eax
46		xchg(&lk->locked, 0);
=> 0xf0101f85 <spin_unlock+6>:	mov    $0x0,%eax
xchg (newval=0x0, addr=0xf010f284 <kernel_lock>) at ./x86.h:319
319		asm volatile("lock; xchgl %0, %1" :
=> 0xf0101f8d <spin_unlock+14>:	pop    %ebp
spin_unlock (lk=0xf010f284 <kernel_lock>) at spinlock.c:47
47	}
=> 0xf0101f41 <env_run+77>:	pause  
unlock_kernel () at ./spinlock.h:35
35		asm volatile("pause");
=> 0xf0101f46 <env_run+82>:	call   0xf0101ed0 <env_pop_tf>
0xf0101f46 in env_run (e=0xf011707c) at env.c:594
594		env_pop_tf(&e->env_tf);
=> 0xf0101ed0 <env_pop_tf>:	push   %ebp
env_pop_tf (tf=0xf011707c) at env.c:545
545	{
=> 0xf0101ed1 <env_pop_tf+1>:	mov    %esp,%ebp
0xf0101ed1	545	{
=> 0xf0101ed3 <env_pop_tf+3>:	sub    $0xc,%esp
0xf0101ed3	545	{
=> 0xf0101ed6 <env_pop_tf+6>:	mov    0x8(%ebp),%esp
546		__asm __volatile("movl %0,%%esp\n"
[34m--------------------------------------------------------------------------[34m[1m[regs]
[0m  [32mEAX:[31m 0x00000001  [32mEBX:[31m 0xF011707C  [32mECX:[31m 0x00000401  [32mEDX:[31m 0xF010F284  [1m[4m[31mo d i t S z A P c 
[0m  [32mESI:[31m 0xF011707C  [32mEDI:[30m 0x00000000  [32mEBP:[31m 0xF0116FE0  [32mESP:[31m 0xF0116FD4  [32mEIP:[31m 0xF0101ED6
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0023  [32mGS:[30m 0023  [32mSS:[30m 0010[0m
[36m[34m[0x0010:0xF0116FD4][34m------------------------------------------------------[34m[1m[stack]
[0m[1m0xF0117024 : [0m00 00 00 00 5C 70 11 F0[1m - [0m00 00 00 00 50 70 11 F0 [1m....\p......Pp..[0m
[1m0xF0117014 : [0m44 25 10 F0 29 30 10 F0[1m - [0m3C 70 11 F0 00 2A 10 F0 [1mD%..)0..<p...*..[0m
[1m0xF0117004 : [0mE6 17 10 F0 7C 70 11 F0[1m - [0m00 00 00 00 30 70 11 F0 [1m....|p......0p..[0m
[1m0xF0116FF4 : [0m40 70 11 F0 5D 21 10 F0[1m - [0m00 70 11 F0 30 70 11 F0 [1m@p..]!...p..0p..[0m
[1m0xF0116FE4 : [0m4B 1F 10 F0 7C 70 11 F0[1m - [0m04 70 11 F0 3A 30 10 F0 [1mK...|p...p..:0..[0m
[1m0xF0116FD4 : [0m00 00 00 00 5C 70 11 F0[1m - [0m00 00 00 00 00 70 11 F0 [1m....\p.......p..[0m
[0m[34m[0x0010:0xF0116FD4][34m-------------------------------------------------------[1m[34m[data]
[0m[1m0xF0116FD4 : [0m00 00 00 00 5C 70 11 F0[1m - [0m00 00 00 00 00 70 11 F0 [1m....\p.......p..[0m
[1m0xF0116FE4 : [0m4B 1F 10 F0 7C 70 11 F0[1m - [0m04 70 11 F0 3A 30 10 F0 [1mK...|p...p..:0..[0m
[1m0xF0116FF4 : [0m40 70 11 F0 5D 21 10 F0[1m - [0m00 70 11 F0 30 70 11 F0 [1m@p..]!...p..0p..[0m
[1m0xF0117004 : [0mE6 17 10 F0 7C 70 11 F0[1m - [0m00 00 00 00 30 70 11 F0 [1m....|p......0p..[0m
[1m0xF0117014 : [0m44 25 10 F0 29 30 10 F0[1m - [0m3C 70 11 F0 00 2A 10 F0 [1mD%..)0..<p...*..[0m
[1m0xF0117024 : [0m00 00 00 00 5C 70 11 F0[1m - [0m00 00 00 00 50 70 11 F0 [1m....\p......Pp..[0m
[1m0xF0117034 : [0m81 16 10 F0 84 F2 10 F0[1m - [0m20 00 00 00 00 00 00 00 [1m........ .......[0m
[1m0xF0117044 : [0m74 70 11 F0 00 00 00 00[1m - [0m00 00 00 00 B4 70 11 F0 [1mtp...........p..[0m
[34m--------------------------------------------------------------------------[34m[1m[code]
[0m=> 0xf0101ed6 <env_pop_tf+6>:	mov    0x8(%ebp),%esp
   0xf0101ed9 <env_pop_tf+9>:	popa   
   0xf0101eda <env_pop_tf+10>:	pop    %es
   0xf0101edb <env_pop_tf+11>:	pop    %ds
   0xf0101edc <env_pop_tf+12>:	add    $0x8,%esp
   0xf0101edf <env_pop_tf+15>:	iret   
   0xf0101ee0 <env_pop_tf+16>:	push   $0xf01032c5
   0xf0101ee5 <env_pop_tf+21>:	push   $0x22b
[34m--------------------------------------------------------------------------------
[0m$3 = {tf_regs = {reg_edi = 0x10, reg_esi = 0x10, reg_ebp = 0x20, reg_oesp = 0x0, reg_ebx = 0xf0102532, reg_edx = 0x8, reg_ecx = 0x286, reg_eax = 0xf0100075}, tf_es = 0x2a0b, tf_padding1 = 0xf010, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x0, tf_err = 0x0, tf_eip = 0xf0100062, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x0, tf_esp = 0xf0000000, tf_ss = 0x10, tf_padding4 = 0x0}
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Breakpoint 1 at 0xf01015ae: file trap.c, line 244.
Breakpoint 2 at 0xf0101ef4: file env.c, line 566.
Continuing.
The target architecture is assumed to be i386
=> 0xf0101ef4 <env_run>:	push   %ebp

Breakpoint 2, env_run (e=0xf0117000) at env.c:566
566	{
Continuing.
=> 0xf01015ae <trap>:	push   %ebp

Breakpoint 1, trap (tf=0xf0116ee4) at trap.c:244
244	{
Continuing.
=> 0xf0101ef4 <env_run>:	push   %ebp

Breakpoint 2, env_run (e=0xf011707c) at env.c:566
566	{
Continuing.
=> 0xf01015ae <trap>:	push   %ebp

Breakpoint 1, trap (tf=0xf011705c) at trap.c:244
244	{
$1 = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0xf01170b4, reg_oesp = 0xf011707c, reg_ebx = 0x0, reg_edx = 0x3d5, reg_ecx = 0x3d4, reg_eax = 0x0}, tf_es = 0x10, tf_padding1 = 0x0, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x20, tf_err = 0x0, tf_eip = 0xf0102532, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x286, tf_esp = 0xf0100075, tf_ss = 0x2a0b, tf_padding4 = 0xf010}
=> 0xf01015af <trap+1>:	mov    %esp,%ebp
0xf01015af	244	{
=> 0xf01015b1 <trap+3>:	push   %edi
0xf01015b1	244	{
=> 0xf01015b2 <trap+4>:	push   %esi
0xf01015b2	244	{
=> 0xf01015b3 <trap+5>:	mov    0x8(%ebp),%esi
0xf01015b3	244	{
=> 0xf01015b6 <trap+8>:	cld    
247		asm volatile("cld" ::: "cc");
=> 0xf01015b7 <trap+9>:	movzwl 0x34(%esi),%eax
250		if ((tf->tf_cs & 3) == 3) {
=> 0xf0101606 <trap+88>:	mov    %esi,0xf010f1e0
272		last_tf = tf;
$2 = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0xf01170b4, reg_oesp = 0xf011707c, reg_ebx = 0x0, reg_edx = 0x3d5, reg_ecx = 0x3d4, reg_eax = 0x0}, tf_es = 0x10, tf_padding1 = 0x0, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x20, tf_err = 0x0, tf_eip = 0xf0102532, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x286, tf_esp = 0xf0100075, tf_ss = 0x2a0b, tf_padding4 = 0xf010}
=> 0xf010160c <trap+94>:	sub    $0x8,%esp
275		trap_dispatch(tf);
=> 0xf010160c <trap+94>:	sub    $0x8,%esp
trap_dispatch (tf=0xf011705c) at trap.c:188
188		cprintf("----Trap No: 0x%u\n", tf->tf_trapno);
=> 0xf0102538 <cprintf+6>:	lea    0xc(%ebp),%eax
cprintf (fmt=0xf0103029 "----Trap No: 0x%u\n") at stdio.c:43
43		va_start(ap, fmt);
No symbol "tf" in current context.
=> 0xf010253b <cprintf+9>:	push   %eax
44		cnt = vcprintf(fmt, ap);
=> 0xf0102512 <vcprintf+6>:	movl   $0x0,-0xc(%ebp)
vcprintf (fmt=0xf0103029 "----Trap No: 0x%u\n", ap=0xf011703c " ") at stdio.c:31
31		int cnt = 0;
=> 0xf0102519 <vcprintf+13>:	pushl  0xc(%ebp)
33		vprintfmt((void*)putch, &cnt, fmt, ap);
=> 0xf0101ef4 <env_run>:	push   %ebp

Breakpoint 2, env_run (e=0xf011707c) at env.c:566
566	{
No symbol "tf" in current context.
$3 = (struct Env *) 0xf011707c
$4 = {env_tf = {tf_regs = {reg_edi = 0x10, reg_esi = 0x10, reg_ebp = 0x20, reg_oesp = 0x0, reg_ebx = 0xf0102532, reg_edx = 0x8, reg_ecx = 0x286, reg_eax = 0xf0100075}, tf_es = 0x2a0b, tf_padding1 = 0xf010, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x0, tf_err = 0x0, tf_eip = 0xf0100062, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x0, tf_esp = 0xf0000000, tf_ss = 0x10, tf_padding4 = 0x0}, env_link = 0xf01170f8, env_id = 0x1001, env_parent_id = 0x0, env_type = (unknown: 1), env_status = 0x3, env_runs = 0x1, env_cpunum = 0x0, env_pgdir = 0xf0045000, env_pgfault_upcall = 0x0, env_ipc_recving = 0x0, env_ipc_dstva = 0x0, env_ipc_value = 0x0, env_ipc_from = 0x0, env_ipc_perm = 0x0}
=> 0xf0101efe <env_run+10>:	mov    0xf010f26c,%eax
584		if (curenv != e)
$5 = {env_tf = {tf_regs = {reg_edi = 0x10, reg_esi = 0x10, reg_ebp = 0x20, reg_oesp = 0x0, reg_ebx = 0xf0102532, reg_edx = 0x8, reg_ecx = 0x286, reg_eax = 0xf0100075}, tf_es = 0x2a0b, tf_padding1 = 0xf010, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x0, tf_err = 0x0, tf_eip = 0xf0100062, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x0, tf_esp = 0xf0000000, tf_ss = 0x10, tf_padding4 = 0x0}, env_link = 0xf01170f8, env_id = 0x1001, env_parent_id = 0x0, env_type = (unknown: 1), env_status = 0x3, env_runs = 0x1, env_cpunum = 0x0, env_pgdir = 0xf0045000, env_pgfault_upcall = 0x0, env_ipc_recving = 0x0, env_ipc_dstva = 0x0, env_ipc_value = 0x0, env_ipc_from = 0x0, env_ipc_perm = 0x0}
=> 0xf0101f34 <env_run+64>:	sub    $0xc,%esp
593		unlock_kernel();
=> 0xf0101f34 <env_run+64>:	sub    $0xc,%esp
unlock_kernel () at ./spinlock.h:29
29		spin_unlock(&kernel_lock);
=> 0xf0101f85 <spin_unlock+6>:	mov    $0x0,%eax
spin_unlock (lk=0xf010f284 <kernel_lock>) at spinlock.c:46
46		xchg(&lk->locked, 0);
=> 0xf0101f85 <spin_unlock+6>:	mov    $0x0,%eax
xchg (newval=0x0, addr=0xf010f284 <kernel_lock>) at ./x86.h:319
319		asm volatile("lock; xchgl %0, %1" :
=> 0xf0101f8d <spin_unlock+14>:	pop    %ebp
spin_unlock (lk=0xf010f284 <kernel_lock>) at spinlock.c:47
47	}
=> 0xf0101f41 <env_run+77>:	pause  
unlock_kernel () at ./spinlock.h:35
35		asm volatile("pause");
Cannot access memory at address 0xe
=> 0xf0101f46 <env_run+82>:	call   0xf0101ed0 <env_pop_tf>
0xf0101f46 in env_run (e=0xf011707c) at env.c:594
594		env_pop_tf(&e->env_tf);
$6 = {env_tf = {tf_regs = {reg_edi = 0x10, reg_esi = 0x10, reg_ebp = 0x20, reg_oesp = 0x0, reg_ebx = 0xf0102532, reg_edx = 0x8, reg_ecx = 0x286, reg_eax = 0xf0100075}, tf_es = 0x2a0b, tf_padding1 = 0xf010, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x0, tf_err = 0x0, tf_eip = 0xf0100062, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x0, tf_esp = 0xf0000000, tf_ss = 0x10, tf_padding4 = 0x0}, env_link = 0xf01170f8, env_id = 0x1001, env_parent_id = 0x0, env_type = (unknown: 1), env_status = 0x3, env_runs = 0x1, env_cpunum = 0x0, env_pgdir = 0xf0045000, env_pgfault_upcall = 0x0, env_ipc_recving = 0x0, env_ipc_dstva = 0x0, env_ipc_value = 0x0, env_ipc_from = 0x0, env_ipc_perm = 0x0}
=> 0xf0101ed0 <env_pop_tf>:	push   %ebp
env_pop_tf (tf=0xf011707c) at env.c:545
545	{
=> 0xf0101ed1 <env_pop_tf+1>:	mov    %esp,%ebp
0xf0101ed1	545	{
=> 0xf0101ed3 <env_pop_tf+3>:	sub    $0xc,%esp
0xf0101ed3	545	{
=> 0xf0101ed6 <env_pop_tf+6>:	mov    0x8(%ebp),%esp
546		__asm __volatile("movl %0,%%esp\n"
$7 = {tf_regs = {reg_edi = 0x10, reg_esi = 0x10, reg_ebp = 0x20, reg_oesp = 0x0, reg_ebx = 0xf0102532, reg_edx = 0x8, reg_ecx = 0x286, reg_eax = 0xf0100075}, tf_es = 0x2a0b, tf_padding1 = 0xf010, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x0, tf_err = 0x0, tf_eip = 0xf0100062, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x0, tf_esp = 0xf0000000, tf_ss = 0x10, tf_padding4 = 0x0}
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Breakpoint 1 at 0xf0101eea: file env.c, line 566.
Breakpoint 2 at 0xf01015ae: file trap.c, line 243.
Continuing.
The target architecture is assumed to be i386
=> 0xf0101eea <env_run>:	push   %ebp

Breakpoint 1, env_run (e=0xf0117000) at env.c:566
566	{
Continuing.
=> 0xf01015ae <trap>:	push   %ebp

Breakpoint 2, trap (tf=0xf0116fe0) at trap.c:243
243	{
$1 = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0xf0117038, reg_oesp = 0xf0117000, reg_ebx = 0x0, reg_edx = 0x3d5, reg_ecx = 0x3d4, reg_eax = 0x0}, tf_es = 0x10, tf_padding1 = 0x0, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x20, tf_err = 0x0, tf_eip = 0xf0102528, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x296, tf_esp = 0xf0100053, tf_ss = 0x2a00, tf_padding4 = 0xf010}
=> 0xf01015ba <trap+12>:	cld    
246		asm volatile("cld" ::: "cc");
=> 0xf01015bb <trap+13>:	movzwl 0x34(%ebx),%eax
249		if ((tf->tf_cs & 3) == 3 || tf->tf_trapno == IRQ_OFFSET + IRQ_TIMER) {
=> 0xf01015ce <trap+32>:	sub    $0xc,%esp
253			lock_kernel();
$2 = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0xf0117038, reg_oesp = 0xf0117000, reg_ebx = 0x0, reg_edx = 0x3d5, reg_ecx = 0x3d4, reg_eax = 0x0}, tf_es = 0x10, tf_padding1 = 0x0, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x20, tf_err = 0x0, tf_eip = 0xf0102528, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x296, tf_esp = 0xf0100053, tf_ss = 0x2a00, tf_padding4 = 0xf010}
=> 0xf01015ce <trap+32>:	sub    $0xc,%esp
lock_kernel () at ./spinlock.h:23
23		spin_lock(&kernel_lock);
=> 0xf0101f55 <spin_lock+6>:	mov    $0x1,%eax
spin_lock (lk=0xf010f284 <kernel_lock>) at spinlock.c:28
28		while (xchg(&lk->locked, 1) != 0)
=> 0xf0101f55 <spin_lock+6>:	mov    $0x1,%eax
xchg (newval=0x1, addr=0xf010f284 <kernel_lock>) at ./x86.h:319
319		asm volatile("lock; xchgl %0, %1" :
=> 0xf0101f5d <spin_lock+14>:	test   %eax,%eax
spin_lock (lk=0xf010f284 <kernel_lock>) at spinlock.c:28
28		while (xchg(&lk->locked, 1) != 0)
=> 0xf0101f73 <spin_lock+36>:	pop    %ebp
30	}
=> 0xf01015db <trap+45>:	mov    0xf010f26c,%eax
trap (tf=0xf0116fe0) at trap.c:256
256			if (curenv->env_status == ENV_DYING) {
$3 = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0xf0117038, reg_oesp = 0xf0117000, reg_ebx = 0x0, reg_edx = 0x3d5, reg_ecx = 0x3d4, reg_eax = 0x0}, tf_es = 0x10, tf_padding1 = 0x0, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x20, tf_err = 0x0, tf_eip = 0xf0102528, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x296, tf_esp = 0xf0100053, tf_ss = 0x2a00, tf_padding4 = 0xf010}
=> 0xf0101601 <trap+83>:	mov    $0x11,%ecx
265			curenv->env_tf = *tf;
$4 = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0xf0117038, reg_oesp = 0xf0117000, reg_ebx = 0x0, reg_edx = 0x3d5, reg_ecx = 0x3d4, reg_eax = 0x0}, tf_es = 0x10, tf_padding1 = 0x0, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x20, tf_err = 0x0, tf_eip = 0xf0102528, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x296, tf_esp = 0xf0100053, tf_ss = 0x2a00, tf_padding4 = 0xf010}
$5 = {env_tf = {tf_regs = {reg_edi = 0x10, reg_esi = 0x10, reg_ebp = 0x20, reg_oesp = 0x0, reg_ebx = 0xf0102528, reg_edx = 0x8, reg_ecx = 0x296, reg_eax = 0xf0100053}, tf_es = 0x2a00, tf_padding1 = 0xf010, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x0, tf_err = 0x0, tf_eip = 0xf0100040, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x0, tf_esp = 0xf0000000, tf_ss = 0x10, tf_padding4 = 0x0}, env_link = 0xf011707c, env_id = 0x1000, env_parent_id = 0x0, env_type = (unknown: 1), env_status = 0x3, env_runs = 0x1, env_cpunum = 0x0, env_pgdir = 0xf0044000, env_pgfault_upcall = 0x0, env_ipc_recving = 0x0, env_ipc_dstva = 0x0, env_ipc_value = 0x0, env_ipc_from = 0x0, env_ipc_perm = 0x0}
=> 0xf0101606 <trap+88>:	mov    %eax,%edi
0xf0101606	265			curenv->env_tf = *tf;
=> 0xf0101608 <trap+90>:	mov    %ebx,%esi
0xf0101608	265			curenv->env_tf = *tf;
=> 0xf010160a <trap+92>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010160a	265			curenv->env_tf = *tf;
=> 0xf010160c <trap+94>:	mov    %ebx,0xf010f1e0
271		last_tf = tf;
$6 = {env_tf = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0xf0117038, reg_oesp = 0xf0117000, reg_ebx = 0x0, reg_edx = 0x3d5, reg_ecx = 0x3d4, reg_eax = 0x0}, tf_es = 0x0, tf_padding1 = 0x0, tf_ds = 0x0, tf_padding2 = 0x0, tf_trapno = 0xf0117038, tf_err = 0xf0117000, tf_eip = 0x0, tf_cs = 0x3d5, tf_padding3 = 0x0, tf_eflags = 0x3d4, tf_esp = 0x0, tf_ss = 0x0, tf_padding4 = 0x0}, env_link = 0xf011707c, env_id = 0x1000, env_parent_id = 0x0, env_type = (unknown: 1), env_status = 0x3, env_runs = 0x1, env_cpunum = 0x0, env_pgdir = 0xf0044000, env_pgfault_upcall = 0x0, env_ipc_recving = 0x0, env_ipc_dstva = 0x0, env_ipc_value = 0x0, env_ipc_from = 0x0, env_ipc_perm = 0x0}
$7 = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0xf0117038, reg_oesp = 0xf0117000, reg_ebx = 0x0, reg_edx = 0x3d5, reg_ecx = 0x3d4, reg_eax = 0x0}, tf_es = 0x0, tf_padding1 = 0x0, tf_ds = 0x0, tf_padding2 = 0x0, tf_trapno = 0xf0117038, tf_err = 0xf0117000, tf_eip = 0x0, tf_cs = 0x3d5, tf_padding3 = 0x0, tf_eflags = 0x3d4, tf_esp = 0x0, tf_ss = 0x0, tf_padding4 = 0x0}
   0xf0101606 <trap+88>:	mov    %eax,%edi
   0xf0101608 <trap+90>:	mov    %ebx,%esi
   0xf010160a <trap+92>:	rep movsl %ds:(%esi),%es:(%edi)
=> 0xf010160c <trap+94>:	mov    %ebx,0xf010f1e0
   0xf0101612 <trap+100>:	sub    $0x8,%esp
   0xf0101615 <trap+103>:	pushl  0x28(%ebx)
   0xf0101618 <trap+106>:	push   $0xf0103029
   0xf010161d <trap+111>:	call   0xf0102528 <cprintf>
   0xf0101622 <trap+116>:	mov    0x28(%ebx),%eax
   0xf0101625 <trap+119>:	add    $0x10,%esp
[34m--------------------------------------------------------------------------[34m[1m[regs]
[0m  [32mEAX:[31m 0xF0117000  [32mEBX:[31m 0xF0116FE0  [32mECX:[30m 0x00000000  [32mEDX:[31m 0x000003D5  [1m[4m[31mo d i t s z a p c 
[0m  [32mESI:[31m 0xF0117024  [32mEDI:[31m 0xF0117044  [32mEBP:[31m 0xF0116FD4  [32mESP:[31m 0xF0116FBC  [32mEIP:[31m 0xF010160C
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0023  [32mGS:[30m 0023  [32mSS:[30m 0010[0m
[36m[34m[0x0010:0xF0116FBC][34m------------------------------------------------------[34m[1m[stack]
[0m[1m0xF011700C : [0m00 70 11 F0 00 00 00 00[1m - [0mD5 03 00 00 D4 03 00 00 [1m.p..............[0m
[1m0xF0116FFC : [0m00 00 00 00 00 00 00 00[1m - [0m00 00 00 00 38 70 11 F0 [1m............8p..[0m
[1m0xF0116FEC : [0m00 70 11 F0 00 00 00 00[1m - [0mD5 03 00 00 D4 03 00 00 [1m.p..............[0m
[1m0xF0116FDC : [0mE0 6F 11 F0 00 00 00 00[1m - [0m00 00 00 00 38 70 11 F0 [1m.o..........8p..[0m
[1m0xF0116FCC : [0m00 00 00 00 00 00 00 00[1m - [0m38 70 11 F0 7D 0F 10 F0 [1m........8p..}...[0m
[1m0xF0116FBC : [0m00 00 00 00 00 00 00 00[1m - [0m00 00 00 00 00 00 00 00 [1m................[0m
[0m[34m[0x0010:0xF0116FBC][34m-------------------------------------------------------[1m[34m[data]
[0m[1m0xF0116FBC : [0m00 00 00 00 00 00 00 00[1m - [0m00 00 00 00 00 00 00 00 [1m................[0m
[1m0xF0116FCC : [0m00 00 00 00 00 00 00 00[1m - [0m38 70 11 F0 7D 0F 10 F0 [1m........8p..}...[0m
[1m0xF0116FDC : [0mE0 6F 11 F0 00 00 00 00[1m - [0m00 00 00 00 38 70 11 F0 [1m.o..........8p..[0m
[1m0xF0116FEC : [0m00 70 11 F0 00 00 00 00[1m - [0mD5 03 00 00 D4 03 00 00 [1m.p..............[0m
[1m0xF0116FFC : [0m00 00 00 00 00 00 00 00[1m - [0m00 00 00 00 38 70 11 F0 [1m............8p..[0m
[1m0xF011700C : [0m00 70 11 F0 00 00 00 00[1m - [0mD5 03 00 00 D4 03 00 00 [1m.p..............[0m
[1m0xF011701C : [0m00 00 00 00 00 00 00 00[1m - [0m00 00 00 00 38 70 11 F0 [1m............8p..[0m
[1m0xF011702C : [0m00 70 11 F0 00 00 00 00[1m - [0mD5 03 00 00 D4 03 00 00 [1m.p..............[0m
[34m--------------------------------------------------------------------------[34m[1m[code]
[0m=> 0xf010160c <trap+94>:	mov    %ebx,0xf010f1e0
   0xf0101612 <trap+100>:	sub    $0x8,%esp
   0xf0101615 <trap+103>:	pushl  0x28(%ebx)
   0xf0101618 <trap+106>:	push   $0xf0103029
   0xf010161d <trap+111>:	call   0xf0102528 <cprintf>
   0xf0101622 <trap+116>:	mov    0x28(%ebx),%eax
   0xf0101625 <trap+119>:	add    $0x10,%esp
   0xf0101628 <trap+122>:	cmp    $0xe,%eax
[34m--------------------------------------------------------------------------------
[0m0xf0117000:	0x00000000	0x00000000	0xf0117038	0xf0117000
0xf0117010:	0x00000000	0x000003d5	0x000003d4	0x00000000
0xf0117020:	0x00000000	0x00000000
0xf0117000:	0x00000000	0x00000000	0xf0117038	0xf0117000
0xf0117010:	0x00000000	0x000003d5	0x000003d4	0x00000000
0xf0117020:	0x00000000	0x00000000	0xf0117038	0xf0117000
0xf0117030:	0x00000000	0x000003d5	0x000003d4	0x00000000
0xf0117040:	0x00000000	0xf011707c	0x00001000	0x00000000
0xf0117050:	0x00000001	0x00000003	0x00000001	0x00000000
0xf0117060:	0xf0044000	0x00000000	0x00000000	0x00000000
0xf0117070:	0x00000000	0x00000000
0xf0117078:	0x00000000	0x00000000	0x00000000	0x00000000
0xf0117088:	0x00000000	0x00000000	0x00000000	0x00000000
0xf0117098:	0x00000000	0x00000010	0x00000010	0x00000000
0xf01170a8:	0x00000000	0xf0100062	0x00000008	0x00000200
0xf01170b8:	0xf0000000	0x00000010	0xf01170f8	0x00001001
0xf01170c8:	0x00000000	0x00000001	0x00000002	0x00000000
0xf01170d8:	0x00000000	0xf0045000	0x00000000	0x00000000
0xf01170e8:	0x00000000	0x00000000
$8 = (struct Trapframe *) 0xf0116fe0
$9 = (struct Env *) 0xf0117000
$10 = {env_tf = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0xf0117038, reg_oesp = 0xf0117000, reg_ebx = 0x0, reg_edx = 0x3d5, reg_ecx = 0x3d4, reg_eax = 0x0}, tf_es = 0x0, tf_padding1 = 0x0, tf_ds = 0x0, tf_padding2 = 0x0, tf_trapno = 0xf0117038, tf_err = 0xf0117000, tf_eip = 0x0, tf_cs = 0x3d5, tf_padding3 = 0x0, tf_eflags = 0x3d4, tf_esp = 0x0, tf_ss = 0x0, tf_padding4 = 0x0}, env_link = 0xf011707c, env_id = 0x1000, env_parent_id = 0x0, env_type = (unknown: 1), env_status = 0x3, env_runs = 0x1, env_cpunum = 0x0, env_pgdir = 0xf0044000, env_pgfault_upcall = 0x0, env_ipc_recving = 0x0, env_ipc_dstva = 0x0, env_ipc_value = 0x0, env_ipc_from = 0x0, env_ipc_perm = 0x0}
There is no member named tf.
Structure has no component named operator*.
$11 = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0xf0117038, reg_oesp = 0xf0117000, reg_ebx = 0x0, reg_edx = 0x3d5, reg_ecx = 0x3d4, reg_eax = 0x0}, tf_es = 0x0, tf_padding1 = 0x0, tf_ds = 0x0, tf_padding2 = 0x0, tf_trapno = 0xf0117038, tf_err = 0xf0117000, tf_eip = 0x0, tf_cs = 0x3d5, tf_padding3 = 0x0, tf_eflags = 0x3d4, tf_esp = 0x0, tf_ss = 0x0, tf_padding4 = 0x0}
$12 = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0xf0117038, reg_oesp = 0xf0117000, reg_ebx = 0x0, reg_edx = 0x3d5, reg_ecx = 0x3d4, reg_eax = 0x0}, tf_es = 0x0, tf_padding1 = 0x0, tf_ds = 0x0, tf_padding2 = 0x0, tf_trapno = 0xf0117038, tf_err = 0xf0117000, tf_eip = 0x0, tf_cs = 0x3d5, tf_padding3 = 0x0, tf_eflags = 0x3d4, tf_esp = 0x0, tf_ss = 0x0, tf_padding4 = 0x0}
   0xf010040:	Cannot access memory at address 0xf010040
   0xf010040:	Cannot access memory at address 0xf010040
   0xf010050:	Cannot access memory at address 0xf010050
   0xf010150:	Cannot access memory at address 0xf010150
   0xf010000:	Cannot access memory at address 0xf010000
   0xf0100040 <shitA>:	push   %ebp
   0xf0100041 <shitA+1>:	mov    %esp,%ebp
   0xf0100043 <shitA+3>:	sub    $0x8,%esp
   0xf0100046 <shitA+6>:	sub    $0xc,%esp
   0xf0100049 <shitA+9>:	push   $0xf0102a00
   0xf010004e <shitA+14>:	call   0xf0102528 <cprintf>
   0xf0100053 <shitA+19>:	add    $0x10,%esp
   0xf0100056 <shitA+22>:	mov    $0x186a0,%eax
   0xf010005b <shitA+27>:	sub    $0x1,%eax
   0xf010005e <shitA+30>:	jne    0xf010005b <shitA+27>
   0xf0100060 <shitA+32>:	jmp    0xf0100046 <shitA+6>
   0xf0100062 <shitB>:	push   %ebp
   0xf0100063 <shitB+1>:	mov    %esp,%ebp
   0xf0100065 <shitB+3>:	sub    $0x8,%esp
   0xf0100068 <shitB+6>:	sub    $0xc,%esp
   0xf010006b <shitB+9>:	push   $0xf0102a0b
   0xf0100070 <shitB+14>:	call   0xf0102528 <cprintf>
   0xf0100075 <shitB+19>:	add    $0x10,%esp
   0xf0100078 <shitB+22>:	mov    $0x186a0,%eax
   0xf010007d <shitB+27>:	sub    $0x1,%eax
   0xf0102528 <cprintf>:	push   %ebp
   0xf0102529 <cprintf+1>:	mov    %esp,%ebp
   0xf010252b <cprintf+3>:	sub    $0x10,%esp
   0xf010252e <cprintf+6>:	lea    0xc(%ebp),%eax
   0xf0102531 <cprintf+9>:	push   %eax
   0xf0102532 <cprintf+10>:	pushl  0x8(%ebp)
   0xf0102535 <cprintf+13>:	call   0xf0102502 <vcprintf>
   0xf010253a <cprintf+18>:	leave  
   0xf010253b <cprintf+19>:	ret    
   0xf010253c <printfmt>:	push   %ebp
   0xf010253d <printfmt+1>:	mov    %esp,%ebp
   0xf010253f <printfmt+3>:	sub    $0x8,%esp
   0xf0102542 <printfmt+6>:	lea    0x14(%ebp),%eax
   0xf0102545 <printfmt+9>:	push   %eax
   0xf0102546 <printfmt+10>:	pushl  0x10(%ebp)
   0xf0102549 <printfmt+13>:	pushl  0xc(%ebp)
   0xf010254c <printfmt+16>:	pushl  0x8(%ebp)
   0xf010254f <printfmt+19>:	call   0xf0102117 <vprintfmt>
   0xf0102554 <printfmt+24>:	add    $0x10,%esp
   0xf0102557 <printfmt+27>:	leave  
No symbol "UENVS" in current context.
No symbol "UENV" in current context.
   0xf0102558 <printfmt+28>:	ret    
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Breakpoint 1 at 0xf0101ed0: file env.c, line 567.
Breakpoint 2 at 0xf0101594: file trap.c, line 243.
Continuing.
The target architecture is assumed to be i386
=> 0xf0101ed0 <env_run>:	push   %ebp

Breakpoint 1, env_run (e=0xf0117000) at env.c:567
567	{
Continuing.
=> 0xf0101594 <trap>:	push   %ebp

Breakpoint 2, trap (tf=0xf0116fe4) at trap.c:243
243	{
$1 = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0xf0117038, reg_oesp = 0xf0117004, reg_ebx = 0x0, reg_edx = 0x3d5, reg_ecx = 0x3d4, reg_eax = 0x0}, tf_es = 0x10, tf_padding1 = 0x0, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x0, tf_err = 0xf010250e, tf_eip = 0x8, tf_cs = 0x296, tf_padding3 = 0x0, tf_eflags = 0xf0100053, tf_esp = 0xf01029e0, tf_ss = 0x10, tf_padding4 = 0x0}
=> 0xf0101595 <trap+1>:	mov    %esp,%ebp
0xf0101595	243	{
$2 = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0xf0117038, reg_oesp = 0xf0117004, reg_ebx = 0x0, reg_edx = 0x3d5, reg_ecx = 0x3d4, reg_eax = 0x0}, tf_es = 0x10, tf_padding1 = 0x0, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x0, tf_err = 0xf010250e, tf_eip = 0x8, tf_cs = 0x296, tf_padding3 = 0x0, tf_eflags = 0xf0100053, tf_esp = 0xf01029e0, tf_ss = 0x10, tf_padding4 = 0x0}
$3 = {env_tf = {tf_regs = {reg_edi = 0x0, reg_esi = 0x10, reg_ebp = 0x10, reg_oesp = 0x0, reg_ebx = 0xf010250e, reg_edx = 0x8, reg_ecx = 0x296, reg_eax = 0xf0100053}, tf_es = 0x29e0, tf_padding1 = 0xf010, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x0, tf_err = 0x0, tf_eip = 0xf0100040, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x0, tf_esp = 0xf0000000, tf_ss = 0x10, tf_padding4 = 0x0}, env_link = 0xf011707c, env_id = 0x1000, env_parent_id = 0x0, env_type = (unknown: 1), env_status = 0x3, env_runs = 0x1, env_cpunum = 0x0, env_pgdir = 0xf0044000, env_pgfault_upcall = 0x0, env_ipc_recving = 0x0, env_ipc_dstva = 0x0, env_ipc_value = 0x0, env_ipc_from = 0x0, env_ipc_perm = 0x0}
$4 = {tf_regs = {reg_edi = 0x0, reg_esi = 0x10, reg_ebp = 0x10, reg_oesp = 0x0, reg_ebx = 0xf010250e, reg_edx = 0x8, reg_ecx = 0x296, reg_eax = 0xf0100053}, tf_es = 0x29e0, tf_padding1 = 0xf010, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x0, tf_err = 0x0, tf_eip = 0xf0100040, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x0, tf_esp = 0xf0000000, tf_ss = 0x10, tf_padding4 = 0x0}
$5 = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0xf0117038, reg_oesp = 0xf0117004, reg_ebx = 0x0, reg_edx = 0x3d5, reg_ecx = 0x3d4, reg_eax = 0x0}, tf_es = 0x10, tf_padding1 = 0x0, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x0, tf_err = 0xf010250e, tf_eip = 0x8, tf_cs = 0x296, tf_padding3 = 0x0, tf_eflags = 0xf0100053, tf_esp = 0xf01029e0, tf_ss = 0x10, tf_padding4 = 0x0}
=> 0xf01015a0 <trap+12>:	cld    
246		asm volatile("cld" ::: "cc");
=> 0xf01015a1 <trap+13>:	movzwl 0x34(%ebx),%eax
249		if ((tf->tf_cs & 3) == 3 || tf->tf_trapno == IRQ_OFFSET + IRQ_TIMER) {
=> 0xf01015f2 <trap+94>:	mov    %ebx,0xf010f1e0
271		last_tf = tf;
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Breakpoint 1 at 0xf0101ed0: file env.c, line 567.
Breakpoint 2 at 0xf0101594: file trap.c, line 243.
Continuing.
The target architecture is assumed to be i386
=> 0xf0101ed0 <env_run>:	push   %ebp

Breakpoint 1, env_run (e=0xf0117000) at env.c:567
567	{
Continuing.
=> 0xf0101594 <trap>:	push   %ebp

Breakpoint 2, trap (tf=0xf0116ee8) at trap.c:243
243	{
$1 = {tf_regs = {reg_edi = 0x70a, reg_esi = 0xf01029ea, reg_ebp = 0xf0116f48, reg_oesp = 0xf0116f08, reg_ebx = 0xf0116fec, reg_edx = 0xf00b80a0, reg_ecx = 0x0, reg_eax = 0xf00b8000}, tf_es = 0x10, tf_padding1 = 0x0, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x20, tf_err = 0xf01002fc, tf_eip = 0x8, tf_cs = 0x206, tf_padding3 = 0x0, tf_eflags = 0xf00b8000, tf_esp = 0xf00b80a0, tf_ss = 0xf00, tf_padding4 = 0x0}
$2 = {tf_regs = {reg_edi = 0xf01029e0, reg_esi = 0xf0117024, reg_ebp = 0x0, reg_oesp = 0x0, reg_ebx = 0x0, reg_edx = 0x0, reg_ecx = 0xf0117038, reg_eax = 0xf0100053}, tf_es = 0x29e0, tf_padding1 = 0xf010, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x0, tf_err = 0x0, tf_eip = 0xf0100040, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x0, tf_esp = 0xf0000000, tf_ss = 0x10, tf_padding4 = 0x0}
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Breakpoint 1 at 0xf0101f2b: file env.c, line 567.
Breakpoint 2 at 0xf01015ef: file trap.c, line 243.
Continuing.
The target architecture is assumed to be i386
=> 0xf0101f2b <env_run>:	push   %ebp

Breakpoint 1, env_run (e=0xf0117000) at env.c:567
567	{
Continuing.
=> 0xf01015ef <trap>:	push   %ebp

Breakpoint 2, trap (tf=0xf0116ed8) at trap.c:243
243	{
$1 = {tf_regs = {reg_edi = 0x70a, reg_esi = 0xf0102a4a, reg_ebp = 0xf0116f48, reg_oesp = 0xf0116ef8, reg_ebx = 0xf0116fec, reg_edx = 0xf00b80a0, reg_ecx = 0x0, reg_eax = 0xf00b8000}, tf_es = 0x10, tf_padding1 = 0x0, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0xe, tf_err = 0x0, tf_eip = 0xf0100fa2, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x6, tf_esp = 0xf01002fc, tf_ss = 0x8, tf_padding4 = 0x0}
$2 = {tf_regs = {reg_edi = 0xf0102a40, reg_esi = 0xf0117024, reg_ebp = 0x0, reg_oesp = 0x0, reg_ebx = 0x0, reg_edx = 0x0, reg_ecx = 0xf0117038, reg_eax = 0xf0100053}, tf_es = 0x2a40, tf_padding1 = 0xf010, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x0, tf_err = 0x0, tf_eip = 0xf0100040, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x0, tf_esp = 0xf0000000, tf_ss = 0x10, tf_padding4 = 0x0}
=> 0xf01015fb <trap+12>:	cld    
246		asm volatile("cld" ::: "cc");
=> 0xf01015fc <trap+13>:	movzwl 0x34(%ebx),%eax
249		if ((tf->tf_cs & 3) == 3 || tf->tf_trapno == IRQ_OFFSET + IRQ_TIMER) {
=> 0xf010164d <trap+94>:	mov    %ebx,0xf010f1e0
271		last_tf = tf;
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Breakpoint 1 at 0xf0101eeb: file env.c, line 567.
Breakpoint 2 at 0xf01015af: file trap.c, line 243.
Continuing.
The target architecture is assumed to be i386
=> 0xf0101eeb <env_run>:	push   %ebp

Breakpoint 1, env_run (e=0xf0117000) at env.c:567
567	{
Continuing.
=> 0xf01015af <trap>:	push   %ebp

Breakpoint 2, trap (tf=0xf0116fe0) at trap.c:243
243	{
$1 = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0xf0117038, reg_oesp = 0xf0117000, reg_ebx = 0x0, reg_edx = 0x3d5, reg_ecx = 0x3d4, reg_eax = 0x0}, tf_es = 0x10, tf_padding1 = 0x0, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x20, tf_err = 0x0, tf_eip = 0xf0102529, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x296, tf_esp = 0xf0100053, tf_ss = 0x2a00, tf_padding4 = 0xf010}
$2 = {tf_regs = {reg_edi = 0x10, reg_esi = 0x10, reg_ebp = 0x20, reg_oesp = 0x0, reg_ebx = 0xf0102529, reg_edx = 0x8, reg_ecx = 0x296, reg_eax = 0xf0100053}, tf_es = 0x2a00, tf_padding1 = 0xf010, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x0, tf_err = 0x0, tf_eip = 0xf0100040, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x0, tf_esp = 0xf0000000, tf_ss = 0x10, tf_padding4 = 0x0}
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Breakpoint 1 at 0xf0101eeb: file env.c, line 567.
Breakpoint 2 at 0xf01015af: file trap.c, line 243.
Continuing.
The target architecture is assumed to be i386
=> 0xf0101eeb <env_run>:	push   %ebp

Breakpoint 1, env_run (e=0xf0117000) at env.c:567
567	{
=> 0xf0101eec <env_run+1>:	mov    %esp,%ebp
0xf0101eec	567	{
=> 0xf0101eee <env_run+3>:	push   %ebx
0xf0101eee	567	{
Cannot access memory at address 0x0
=> 0xf0101eef <env_run+4>:	sub    $0x4,%esp
0xf0101eef	567	{
=> 0xf0101ef2 <env_run+7>:	mov    0x8(%ebp),%ebx
0xf0101ef2	567	{
=> 0xf0101ef5 <env_run+10>:	mov    0xf010f26c,%eax
585		if (curenv != e)
=> 0xf0101efa <env_run+15>:	cmp    %ebx,%eax
0xf0101efa	585		if (curenv != e)
=> 0xf0101efc <env_run+17>:	je     0xf0101f2b <env_run+64>
0xf0101efc	585		if (curenv != e)
=> 0xf0101efe <env_run+19>:	test   %eax,%eax
587			if (curenv && curenv->env_status == ENV_RUNNING)
=> 0xf0101f00 <env_run+21>:	je     0xf0101f0f <env_run+36>
0xf0101f00	587			if (curenv && curenv->env_status == ENV_RUNNING)
=> 0xf0101f0f <env_run+36>:	mov    %ebx,0xf010f26c
589			curenv = e;
=> 0xf0101f15 <env_run+42>:	movl   $0x3,0x54(%ebx)
590			e->env_status = ENV_RUNNING;
$1 = {env_tf = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0x0, reg_oesp = 0x0, reg_ebx = 0x0, reg_edx = 0x0, reg_ecx = 0x0, reg_eax = 0x0}, tf_es = 0x10, tf_padding1 = 0x0, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x0, tf_err = 0x0, tf_eip = 0xf0100040, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x200, tf_esp = 0xf0000000, tf_ss = 0x10, tf_padding4 = 0x0}, env_link = 0xf011707c, env_id = 0x1000, env_parent_id = 0x0, env_type = (unknown: 1), env_status = 0x2, env_runs = 0x0, env_cpunum = 0x0, env_pgdir = 0xf0044000, env_pgfault_upcall = 0x0, env_ipc_recving = 0x0, env_ipc_dstva = 0x0, env_ipc_value = 0x0, env_ipc_from = 0x0, env_ipc_perm = 0x0}
=> 0xf0101f1c <env_run+49>:	addl   $0x1,0x58(%ebx)
591			e->env_runs++;
=> 0xf0101f20 <env_run+53>:	mov    0x60(%ebx),%eax
592			lcr3(PADDR(e->env_pgdir));
=> 0xf0101f20 <env_run+53>:	mov    0x60(%ebx),%eax
lcr3 (val=<optimized out>) at ./x86.h:215
215		__asm __volatile("movl %0,%%cr3" : : "r" (val));
=> 0xf0101f2b <env_run+64>:	sub    $0xc,%esp
env_run (e=0xf0117000) at env.c:594
594		unlock_kernel();
=> 0xf0101f2b <env_run+64>:	sub    $0xc,%esp
unlock_kernel () at ./spinlock.h:29
29		spin_unlock(&kernel_lock);
=> 0xf0101f7c <spin_unlock+6>:	mov    $0x0,%eax
spin_unlock (lk=0xf010f284 <kernel_lock>) at spinlock.c:46
46		xchg(&lk->locked, 0);
=> 0xf0101f7c <spin_unlock+6>:	mov    $0x0,%eax
xchg (newval=0x0, addr=0xf010f284 <kernel_lock>) at ./x86.h:319
319		asm volatile("lock; xchgl %0, %1" :
=> 0xf0101f84 <spin_unlock+14>:	pop    %ebp
spin_unlock (lk=0xf010f284 <kernel_lock>) at spinlock.c:47
47	}
=> 0xf0101f38 <env_run+77>:	pause  
unlock_kernel () at ./spinlock.h:35
35		asm volatile("pause");
=> 0xf0101ecd <env_pop_tf+6>:	mov    0x8(%ebp),%esp
env_pop_tf (tf=0xf0117000) at env.c:547
547		__asm __volatile("movl %0,%%esp\n"
$2 = {env_tf = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0x0, reg_oesp = 0x0, reg_ebx = 0x0, reg_edx = 0x0, reg_ecx = 0x0, reg_eax = 0x0}, tf_es = 0x10, tf_padding1 = 0x0, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x0, tf_err = 0x0, tf_eip = 0xf0100040, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x200, tf_esp = 0xf0000000, tf_ss = 0x10, tf_padding4 = 0x0}, env_link = 0xf011707c, env_id = 0x1000, env_parent_id = 0x0, env_type = (unknown: 1), env_status = 0x3, env_runs = 0x1, env_cpunum = 0x0, env_pgdir = 0xf0044000, env_pgfault_upcall = 0x0, env_ipc_recving = 0x0, env_ipc_dstva = 0x0, env_ipc_value = 0x0, env_ipc_from = 0x0, env_ipc_perm = 0x0}
=> 0xf0100040 <shitA>:	push   %ebp
shitA () at init.c:49
49	{
=> 0xf0100046 <shitA+6>:	sub    $0xc,%esp
shitA () at init.c:52
52			cprintf("fuck im A\n");
=> 0xf010252f <cprintf+6>:	lea    0xc(%ebp),%eax
cprintf (fmt=0xf0102a00 "fuck im A\n") at stdio.c:43
43		va_start(ap, fmt);
=> 0xf0102532 <cprintf+9>:	push   %eax
44		cnt = vcprintf(fmt, ap);
=> 0xf0102509 <vcprintf+6>:	movl   $0x0,-0xc(%ebp)
vcprintf (fmt=0xf0102a00 "fuck im A\n", ap=0xf0117024 "\020") at stdio.c:31
31		int cnt = 0;
=> 0xf0102510 <vcprintf+13>:	pushl  0xc(%ebp)
33		vprintfmt((void*)putch, &cnt, fmt, ap);
=> 0xf01015af <trap>:	push   %ebp

Breakpoint 2, trap (tf=0xf0116fe0) at trap.c:243
243	{
$3 = {env_tf = {tf_regs = {reg_edi = 0x10, reg_esi = 0x10, reg_ebp = 0x20, reg_oesp = 0x0, reg_ebx = 0xf0102529, reg_edx = 0x8, reg_ecx = 0x296, reg_eax = 0xf0100053}, tf_es = 0x2a00, tf_padding1 = 0xf010, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x0, tf_err = 0x0, tf_eip = 0xf0100040, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x0, tf_esp = 0xf0000000, tf_ss = 0x10, tf_padding4 = 0x0}, env_link = 0xf011707c, env_id = 0x1000, env_parent_id = 0x0, env_type = (unknown: 1), env_status = 0x3, env_runs = 0x1, env_cpunum = 0x0, env_pgdir = 0xf0044000, env_pgfault_upcall = 0x0, env_ipc_recving = 0x0, env_ipc_dstva = 0x0, env_ipc_value = 0x0, env_ipc_from = 0x0, env_ipc_perm = 0x0}
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Breakpoint 1 at 0xf01015af: file trap.c, line 243.
Breakpoint 2 at 0xf0101eeb: file env.c, line 567.
Continuing.
The target architecture is assumed to be i386
=> 0xf0101eeb <env_run>:	push   %ebp

Breakpoint 2, env_run (e=0xf0117000) at env.c:567
567	{
=> 0xf0101ef5 <env_run+10>:	mov    0xf010f26c,%eax
585		if (curenv != e)
=> 0xf0101efe <env_run+19>:	test   %eax,%eax
587			if (curenv && curenv->env_status == ENV_RUNNING)
=> 0xf0101f0f <env_run+36>:	mov    %ebx,0xf010f26c
589			curenv = e;
=> 0xf0101f15 <env_run+42>:	movl   $0x3,0x54(%ebx)
590			e->env_status = ENV_RUNNING;
=> 0xf0101f1c <env_run+49>:	addl   $0x1,0x58(%ebx)
591			e->env_runs++;
=> 0xf0101f20 <env_run+53>:	mov    0x60(%ebx),%eax
592			lcr3(PADDR(e->env_pgdir));
=> 0xf0101f20 <env_run+53>:	mov    0x60(%ebx),%eax
lcr3 (val=<optimized out>) at ./x86.h:215
215		__asm __volatile("movl %0,%%cr3" : : "r" (val));
=> 0xf0101f2b <env_run+64>:	sub    $0xc,%esp
env_run (e=0xf0117000) at env.c:594
594		unlock_kernel();
=> 0xf0101f2b <env_run+64>:	sub    $0xc,%esp
unlock_kernel () at ./spinlock.h:29
29		spin_unlock(&kernel_lock);
=> 0xf0101f7c <spin_unlock+6>:	mov    $0x0,%eax
spin_unlock (lk=0xf010f284 <kernel_lock>) at spinlock.c:46
46		xchg(&lk->locked, 0);
=> 0xf0101f7c <spin_unlock+6>:	mov    $0x0,%eax
xchg (newval=0x0, addr=0xf010f284 <kernel_lock>) at ./x86.h:319
319		asm volatile("lock; xchgl %0, %1" :
=> 0xf0101f84 <spin_unlock+14>:	pop    %ebp
spin_unlock (lk=0xf010f284 <kernel_lock>) at spinlock.c:47
47	}
=> 0xf0101f38 <env_run+77>:	pause  
unlock_kernel () at ./spinlock.h:35
35		asm volatile("pause");
=> 0xf0101ecd <env_pop_tf+6>:	mov    0x8(%ebp),%esp
env_pop_tf (tf=0xf0117000) at env.c:547
547		__asm __volatile("movl %0,%%esp\n"
=> 0xf0100040 <shitA>:	push   %ebp
shitA () at init.c:49
49	{
=> 0xf0100046 <shitA+6>:	sub    $0xc,%esp
shitA () at init.c:52
52			cprintf("fuck im A\n");
=> 0xf010252f <cprintf+6>:	lea    0xc(%ebp),%eax
cprintf (fmt=0xf0102a00 "fuck im A\n") at stdio.c:43
43		va_start(ap, fmt);
=> 0xf0102532 <cprintf+9>:	push   %eax
44		cnt = vcprintf(fmt, ap);
=> 0xf0102533 <cprintf+10>:	pushl  0x8(%ebp)
0xf0102533	44		cnt = vcprintf(fmt, ap);
$1 = {env_tf = {tf_regs = {reg_edi = 0x0, reg_esi = 0xf0117024, reg_ebp = 0x0, reg_oesp = 0x0, reg_ebx = 0x0, reg_edx = 0x0, reg_ecx = 0xf0117038, reg_eax = 0xf0100053}, tf_es = 0x2a00, tf_padding1 = 0xf010, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x0, tf_err = 0x0, tf_eip = 0xf0100040, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x0, tf_esp = 0xf0000000, tf_ss = 0x10, tf_padding4 = 0x0}, env_link = 0xf011707c, env_id = 0x1000, env_parent_id = 0x0, env_type = (unknown: 1), env_status = 0x3, env_runs = 0x1, env_cpunum = 0x0, env_pgdir = 0xf0044000, env_pgfault_upcall = 0x0, env_ipc_recving = 0x0, env_ipc_dstva = 0x0, env_ipc_value = 0x0, env_ipc_from = 0x0, env_ipc_perm = 0x0}
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Breakpoint 1 at 0xf0101eeb: file env.c, line 567.
Breakpoint 2 at 0xf0100040: file init.c, line 49.
Breakpoint 3 at 0xf01015af: file trap.c, line 243.
Continuing.
The target architecture is assumed to be i386
=> 0xf0101eeb <env_run>:	push   %ebp

Breakpoint 1, env_run (e=0xf0117000) at env.c:567
567	{
=> 0xf0101ef5 <env_run+10>:	mov    0xf010f26c,%eax
585		if (curenv != e)
=> 0xf0101efe <env_run+19>:	test   %eax,%eax
587			if (curenv && curenv->env_status == ENV_RUNNING)
=> 0xf0101f0f <env_run+36>:	mov    %ebx,0xf010f26c
589			curenv = e;
=> 0xf0101f15 <env_run+42>:	movl   $0x3,0x54(%ebx)
590			e->env_status = ENV_RUNNING;
$1 = {env_tf = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0x0, reg_oesp = 0x0, reg_ebx = 0x0, reg_edx = 0x0, reg_ecx = 0x0, reg_eax = 0x0}, tf_es = 0x10, tf_padding1 = 0x0, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x0, tf_err = 0x0, tf_eip = 0xf0100040, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x200, tf_esp = 0xf0000000, tf_ss = 0x10, tf_padding4 = 0x0}, env_link = 0xf011707c, env_id = 0x1000, env_parent_id = 0x0, env_type = (unknown: 1), env_status = 0x2, env_runs = 0x0, env_cpunum = 0x0, env_pgdir = 0xf0044000, env_pgfault_upcall = 0x0, env_ipc_recving = 0x0, env_ipc_dstva = 0x0, env_ipc_value = 0x0, env_ipc_from = 0x0, env_ipc_perm = 0x0}
=> 0xf0101f1c <env_run+49>:	addl   $0x1,0x58(%ebx)
591			e->env_runs++;
$2 = {env_tf = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0x0, reg_oesp = 0x0, reg_ebx = 0x0, reg_edx = 0x0, reg_ecx = 0x0, reg_eax = 0x0}, tf_es = 0x10, tf_padding1 = 0x0, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x0, tf_err = 0x0, tf_eip = 0xf0100040, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x200, tf_esp = 0xf0000000, tf_ss = 0x10, tf_padding4 = 0x0}, env_link = 0xf011707c, env_id = 0x1000, env_parent_id = 0x0, env_type = (unknown: 1), env_status = 0x3, env_runs = 0x0, env_cpunum = 0x0, env_pgdir = 0xf0044000, env_pgfault_upcall = 0x0, env_ipc_recving = 0x0, env_ipc_dstva = 0x0, env_ipc_value = 0x0, env_ipc_from = 0x0, env_ipc_perm = 0x0}
=> 0xf0101f20 <env_run+53>:	mov    0x60(%ebx),%eax
592			lcr3(PADDR(e->env_pgdir));
$3 = {env_tf = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0x0, reg_oesp = 0x0, reg_ebx = 0x0, reg_edx = 0x0, reg_ecx = 0x0, reg_eax = 0x0}, tf_es = 0x10, tf_padding1 = 0x0, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x0, tf_err = 0x0, tf_eip = 0xf0100040, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x200, tf_esp = 0xf0000000, tf_ss = 0x10, tf_padding4 = 0x0}, env_link = 0xf011707c, env_id = 0x1000, env_parent_id = 0x0, env_type = (unknown: 1), env_status = 0x3, env_runs = 0x1, env_cpunum = 0x0, env_pgdir = 0xf0044000, env_pgfault_upcall = 0x0, env_ipc_recving = 0x0, env_ipc_dstva = 0x0, env_ipc_value = 0x0, env_ipc_from = 0x0, env_ipc_perm = 0x0}
=> 0xf0101f20 <env_run+53>:	mov    0x60(%ebx),%eax
lcr3 (val=<optimized out>) at ./x86.h:215
215		__asm __volatile("movl %0,%%cr3" : : "r" (val));
$4 = {env_tf = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0x0, reg_oesp = 0x0, reg_ebx = 0x0, reg_edx = 0x0, reg_ecx = 0x0, reg_eax = 0x0}, tf_es = 0x10, tf_padding1 = 0x0, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x0, tf_err = 0x0, tf_eip = 0xf0100040, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x200, tf_esp = 0xf0000000, tf_ss = 0x10, tf_padding4 = 0x0}, env_link = 0xf011707c, env_id = 0x1000, env_parent_id = 0x0, env_type = (unknown: 1), env_status = 0x3, env_runs = 0x1, env_cpunum = 0x0, env_pgdir = 0xf0044000, env_pgfault_upcall = 0x0, env_ipc_recving = 0x0, env_ipc_dstva = 0x0, env_ipc_value = 0x0, env_ipc_from = 0x0, env_ipc_perm = 0x0}
=> 0xf0101f2b <env_run+64>:	sub    $0xc,%esp
env_run (e=0xf0117000) at env.c:594
594		unlock_kernel();
=> 0xf0101f2b <env_run+64>:	sub    $0xc,%esp
unlock_kernel () at ./spinlock.h:29
29		spin_unlock(&kernel_lock);
=> 0xf0101f7c <spin_unlock+6>:	mov    $0x0,%eax
spin_unlock (lk=0xf010f284 <kernel_lock>) at spinlock.c:46
46		xchg(&lk->locked, 0);
=> 0xf0101f7c <spin_unlock+6>:	mov    $0x0,%eax
xchg (newval=0x0, addr=0xf010f284 <kernel_lock>) at ./x86.h:319
319		asm volatile("lock; xchgl %0, %1" :
=> 0xf0101f84 <spin_unlock+14>:	pop    %ebp
spin_unlock (lk=0xf010f284 <kernel_lock>) at spinlock.c:47
47	}
=> 0xf0101f38 <env_run+77>:	pause  
unlock_kernel () at ./spinlock.h:35
35		asm volatile("pause");
=> 0xf0101ecd <env_pop_tf+6>:	mov    0x8(%ebp),%esp
env_pop_tf (tf=0xf0117000) at env.c:547
547		__asm __volatile("movl %0,%%esp\n"
$5 = {env_tf = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0x0, reg_oesp = 0x0, reg_ebx = 0x0, reg_edx = 0x0, reg_ecx = 0x0, reg_eax = 0x0}, tf_es = 0x10, tf_padding1 = 0x0, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x0, tf_err = 0x0, tf_eip = 0xf0100040, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x200, tf_esp = 0xf0000000, tf_ss = 0x10, tf_padding4 = 0x0}, env_link = 0xf011707c, env_id = 0x1000, env_parent_id = 0x0, env_type = (unknown: 1), env_status = 0x3, env_runs = 0x1, env_cpunum = 0x0, env_pgdir = 0xf0044000, env_pgfault_upcall = 0x0, env_ipc_recving = 0x0, env_ipc_dstva = 0x0, env_ipc_value = 0x0, env_ipc_from = 0x0, env_ipc_perm = 0x0}
=> 0xf0100040 <shitA>:	push   %ebp

Breakpoint 2, shitA () at init.c:49
49	{
=> 0xf0100046 <shitA+6>:	sub    $0xc,%esp
shitA () at init.c:52
52			cprintf("fuck im A\n");
$6 = {env_tf = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0x0, reg_oesp = 0x0, reg_ebx = 0x0, reg_edx = 0x0, reg_ecx = 0x0, reg_eax = 0x0}, tf_es = 0x10, tf_padding1 = 0x0, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x0, tf_err = 0x0, tf_eip = 0xf0100040, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x0, tf_esp = 0xf0000000, tf_ss = 0x10, tf_padding4 = 0x0}, env_link = 0xf011707c, env_id = 0x1000, env_parent_id = 0x0, env_type = (unknown: 1), env_status = 0x3, env_runs = 0x1, env_cpunum = 0x0, env_pgdir = 0xf0044000, env_pgfault_upcall = 0x0, env_ipc_recving = 0x0, env_ipc_dstva = 0x0, env_ipc_value = 0x0, env_ipc_from = 0x0, env_ipc_perm = 0x0}
=> 0xf010252f <cprintf+6>:	lea    0xc(%ebp),%eax
cprintf (fmt=0xf0102a00 "fuck im A\n") at stdio.c:43
43		va_start(ap, fmt);
$7 = {env_tf = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0x0, reg_oesp = 0x0, reg_ebx = 0x0, reg_edx = 0x0, reg_ecx = 0xf0117038, reg_eax = 0xf0100053}, tf_es = 0x2a00, tf_padding1 = 0xf010, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x0, tf_err = 0x0, tf_eip = 0xf0100040, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x0, tf_esp = 0xf0000000, tf_ss = 0x10, tf_padding4 = 0x0}, env_link = 0xf011707c, env_id = 0x1000, env_parent_id = 0x0, env_type = (unknown: 1), env_status = 0x3, env_runs = 0x1, env_cpunum = 0x0, env_pgdir = 0xf0044000, env_pgfault_upcall = 0x0, env_ipc_recving = 0x0, env_ipc_dstva = 0x0, env_ipc_value = 0x0, env_ipc_from = 0x0, env_ipc_perm = 0x0}
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Breakpoint 1 at 0xf0100040: file init.c, line 49.
Continuing.
The target architecture is assumed to be i386
=> 0xf0100040 <shitA>:	push   %ebp

Breakpoint 1, shitA () at init.c:49
49	{
$1 = {env_tf = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0x0, reg_oesp = 0x0, reg_ebx = 0x0, reg_edx = 0x0, reg_ecx = 0x0, reg_eax = 0x0}, tf_es = 0x10, tf_padding1 = 0x0, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x0, tf_err = 0x0, tf_eip = 0xf0100040, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x200, tf_esp = 0xf0000000, tf_ss = 0x10, tf_padding4 = 0x0}, env_link = 0xf011707c, env_id = 0x1000, env_parent_id = 0x0, env_type = (unknown: 1), env_status = 0x3, env_runs = 0x1, env_cpunum = 0x0, env_pgdir = 0xf0044000, env_pgfault_upcall = 0x0, env_ipc_recving = 0x0, env_ipc_dstva = 0x0, env_ipc_value = 0x0, env_ipc_from = 0x0, env_ipc_perm = 0x0}
=> 0xf0100041 <shitA+1>:	mov    %esp,%ebp
0xf0100041	49	{
$2 = {env_tf = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0x0, reg_oesp = 0x0, reg_ebx = 0x0, reg_edx = 0x0, reg_ecx = 0x0, reg_eax = 0x0}, tf_es = 0x10, tf_padding1 = 0x0, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x0, tf_err = 0x0, tf_eip = 0xf0100040, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x0, tf_esp = 0xf0000000, tf_ss = 0x10, tf_padding4 = 0x0}, env_link = 0xf011707c, env_id = 0x1000, env_parent_id = 0x0, env_type = (unknown: 1), env_status = 0x3, env_runs = 0x1, env_cpunum = 0x0, env_pgdir = 0xf0044000, env_pgfault_upcall = 0x0, env_ipc_recving = 0x0, env_ipc_dstva = 0x0, env_ipc_value = 0x0, env_ipc_from = 0x0, env_ipc_perm = 0x0}
=> 0xf0100043 <shitA+3>:	sub    $0x8,%esp
0xf0100043 in shitA () at init.c:49
49	{
$3 = {env_tf = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0x0, reg_oesp = 0x0, reg_ebx = 0x0, reg_edx = 0x0, reg_ecx = 0x0, reg_eax = 0x0}, tf_es = 0x10, tf_padding1 = 0x0, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x0, tf_err = 0x0, tf_eip = 0xf0100040, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x0, tf_esp = 0xf0000000, tf_ss = 0x10, tf_padding4 = 0x0}, env_link = 0xf011707c, env_id = 0x1000, env_parent_id = 0x0, env_type = (unknown: 1), env_status = 0x3, env_runs = 0x1, env_cpunum = 0x0, env_pgdir = 0xf0044000, env_pgfault_upcall = 0x0, env_ipc_recving = 0x0, env_ipc_dstva = 0x0, env_ipc_value = 0x0, env_ipc_from = 0x0, env_ipc_perm = 0x0}
=> 0xf0100046 <shitA+6>:	sub    $0xc,%esp
52			cprintf("fuck im A\n");
$4 = {env_tf = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0x0, reg_oesp = 0x0, reg_ebx = 0x0, reg_edx = 0x0, reg_ecx = 0x0, reg_eax = 0x0}, tf_es = 0x10, tf_padding1 = 0x0, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x0, tf_err = 0x0, tf_eip = 0xf0100040, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x0, tf_esp = 0xf0000000, tf_ss = 0x10, tf_padding4 = 0x0}, env_link = 0xf011707c, env_id = 0x1000, env_parent_id = 0x0, env_type = (unknown: 1), env_status = 0x3, env_runs = 0x1, env_cpunum = 0x0, env_pgdir = 0xf0044000, env_pgfault_upcall = 0x0, env_ipc_recving = 0x0, env_ipc_dstva = 0x0, env_ipc_value = 0x0, env_ipc_from = 0x0, env_ipc_perm = 0x0}
=> 0xf0100049 <shitA+9>:	push   $0xf0102a00
0xf0100049	52			cprintf("fuck im A\n");
$5 = {env_tf = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0x0, reg_oesp = 0x0, reg_ebx = 0x0, reg_edx = 0x0, reg_ecx = 0x0, reg_eax = 0x0}, tf_es = 0x10, tf_padding1 = 0x0, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x0, tf_err = 0x0, tf_eip = 0xf0100040, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x0, tf_esp = 0xf0000000, tf_ss = 0x10, tf_padding4 = 0x0}, env_link = 0xf011707c, env_id = 0x1000, env_parent_id = 0x0, env_type = (unknown: 1), env_status = 0x3, env_runs = 0x1, env_cpunum = 0x0, env_pgdir = 0xf0044000, env_pgfault_upcall = 0x0, env_ipc_recving = 0x0, env_ipc_dstva = 0x0, env_ipc_value = 0x0, env_ipc_from = 0x0, env_ipc_perm = 0x0}
=> 0xf010004e <shitA+14>:	call   0xf0102529 <cprintf>
0xf010004e	52			cprintf("fuck im A\n");
$6 = {env_tf = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0x0, reg_oesp = 0x0, reg_ebx = 0x0, reg_edx = 0x0, reg_ecx = 0x0, reg_eax = 0x0}, tf_es = 0x2a00, tf_padding1 = 0xf010, tf_ds = 0x10, tf_padding2 = 0x0, tf_trapno = 0x0, tf_err = 0x0, tf_eip = 0xf0100040, tf_cs = 0x8, tf_padding3 = 0x0, tf_eflags = 0x0, tf_esp = 0xf0000000, tf_ss = 0x10, tf_padding4 = 0x0}, env_link = 0xf011707c, env_id = 0x1000, env_parent_id = 0x0, env_type = (unknown: 1), env_status = 0x3, env_runs = 0x1, env_cpunum = 0x0, env_pgdir = 0xf0044000, env_pgfault_upcall = 0x0, env_ipc_recving = 0x0, env_ipc_dstva = 0x0, env_ipc_value = 0x0, env_ipc_from = 0x0, env_ipc_perm = 0x0}
$7 = (struct Env *) 0xf0117000
No symbol "curenvsi" in current context.
=> 0xf0102529 <cprintf>:	push   %ebp
cprintf (fmt=0xf0102a00 "fuck im A\n") at stdio.c:39
39	{
  [32mEAX:[30m 0x00000000  [32mEBX:[30m 0x00000000  [32mECX:[30m 0x00000000  [32mEDX:[30m 0x00000000  [1m[4m[31mo d I t S z A P c 
[0m  [32mESI:[30m 0x00000000  [32mEDI:[30m 0x00000000  [32mEBP:[31m 0xF0117038  [32mESP:[31m 0xF011701C  [32mEIP:[31m 0xF0102529
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0023  [32mGS:[30m 0023  [32mSS:[30m 0010[0m
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Breakpoint 1 at 0xf0100040: file init.c, line 49.
Continuing.
The target architecture is assumed to be i386
=> 0xf0100040 <shitA>:	push   %ebp

Breakpoint 1, shitA () at init.c:49
49	{
Ambiguous command "re": rec, record, refresh, reg, regarm, regx64, regx86, remote, remove-inferiors, remove-symbol-file...
  [32mEAX:[30m 0x00000000  [32mEBX:[30m 0x00000000  [32mECX:[30m 0x00000000  [32mEDX:[30m 0x00000000  [1m[4m[31mo d I t s z a p c 
[0m  [32mESI:[30m 0x00000000  [32mEDI:[30m 0x00000000  [32mEBP:[30m 0x00000000  [32mESP:[31m 0xF011703C  [32mEIP:[31m 0xF0100040
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0023  [32mGS:[30m 0023  [32mSS:[30m 0010[0m
No symbol "KSTACKTOP" in current context.
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Function "sched" not defined.
Breakpoint 1 at 0xf0101862: file picirq.c, line 15.
Continuing.
The target architecture is assumed to be i386
=> 0xf0101862 <pic_init>:	movb   $0x1,0xf010f268

Breakpoint 1, pic_init () at picirq.c:15
15		didinit = 1;
  [32mEAX:[31m 0xF010E300  [32mEBX:[31m 0x00010094  [32mECX:[31m 0xF0117000  [32mEDX:[31m 0x0000F010  [1m[4m[31mo d i t s z a P c 
[0m  [32mESI:[31m 0x00010094  [32mEDI:[30m 0x00000000  [32mEBP:[31m 0xF010BFF8  [32mESP:[31m 0xF010BFDC  [32mEIP:[31m 0xF0101862
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0023  [32mGS:[30m 0023  [32mSS:[30m 0010[0m
=> 0xf0101869 <pic_init+7>:	mov    $0x21,%edx
outb (data=0xff, port=0x21) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf010186e <pic_init+12>:	mov    $0xffffffff,%eax
0xf010186e	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0101873 <pic_init+17>:	out    %al,(%dx)
0xf0101873	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0101874 <pic_init+18>:	mov    $0xa1,%edx
0xf0101874 in outb (data=0xff, port=0xa1) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0101879 <pic_init+23>:	out    %al,(%dx)
0xf0101879	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf010187a <pic_init+24>:	mov    $0x20,%edx
0xf010187a in outb (data=0x11, port=0x20) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf010187f <pic_init+29>:	mov    $0x11,%eax
0xf010187f	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0101884 <pic_init+34>:	out    %al,(%dx)
0xf0101884	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0101885 <pic_init+35>:	mov    $0x21,%edx
0xf0101885 in outb (data=0x20, port=0x21) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf010188a <pic_init+40>:	mov    $0x20,%eax
0xf010188a	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf010188f <pic_init+45>:	out    %al,(%dx)
0xf010188f	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0101890 <pic_init+46>:	mov    $0x4,%eax
0xf0101890 in outb (data=0x4, port=0x21) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0101895 <pic_init+51>:	out    %al,(%dx)
0xf0101895	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0101896 <pic_init+52>:	mov    $0x3,%eax
0xf0101896 in outb (data=0x3, port=0x21) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf010189b <pic_init+57>:	out    %al,(%dx)
0xf010189b	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf010189c <pic_init+58>:	mov    $0xa0,%edx
0xf010189c in outb (data=0x11, port=0xa0) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01018a1 <pic_init+63>:	mov    $0x11,%eax
0xf01018a1	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01018a6 <pic_init+68>:	out    %al,(%dx)
0xf01018a6	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01018a7 <pic_init+69>:	mov    $0xa1,%edx
0xf01018a7 in outb (data=0x28, port=0xa1) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01018ac <pic_init+74>:	mov    $0x28,%eax
0xf01018ac	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01018b1 <pic_init+79>:	out    %al,(%dx)
0xf01018b1	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01018b2 <pic_init+80>:	mov    $0x2,%eax
0xf01018b2 in outb (data=0x2, port=0xa1) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01018b7 <pic_init+85>:	out    %al,(%dx)
0xf01018b7	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01018b8 <pic_init+86>:	mov    $0x1,%eax
0xf01018b8 in outb (data=0x1, port=0xa1) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01018bd <pic_init+91>:	out    %al,(%dx)
0xf01018bd	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01018be <pic_init+92>:	mov    $0x20,%edx
0xf01018be in outb (data=0x68, port=0x20) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01018c3 <pic_init+97>:	mov    $0x68,%eax
0xf01018c3	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01018c8 <pic_init+102>:	out    %al,(%dx)
0xf01018c8	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01018c9 <pic_init+103>:	mov    $0xa,%eax
0xf01018c9 in outb (data=0xa, port=0x20) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01018ce <pic_init+108>:	out    %al,(%dx)
0xf01018ce	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01018cf <pic_init+109>:	mov    $0xa0,%edx
0xf01018cf in outb (data=0x68, port=0xa0) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01018d4 <pic_init+114>:	mov    $0x68,%eax
0xf01018d4	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01018d9 <pic_init+119>:	out    %al,(%dx)
0xf01018d9	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01018da <pic_init+120>:	mov    $0xa,%eax
0xf01018da in outb (data=0xa, port=0xa0) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01018df <pic_init+125>:	out    %al,(%dx)
0xf01018df	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01018e0 <pic_init+126>:	movzwl 0xf010e306,%eax
pic_init () at picirq.c:64
64		if (irq_mask_8259A != 0xFFFF)
=> 0xf01018e7 <pic_init+133>:	cmp    $0xffff,%ax
0xf01018e7	64		if (irq_mask_8259A != 0xFFFF)
=> 0xf01018eb <pic_init+137>:	je     0xf0101900 <pic_init+158>
0xf01018eb	64		if (irq_mask_8259A != 0xFFFF)
=> 0xf01018ed <pic_init+139>:	push   %ebp
14	{
=> 0xf01018ee <pic_init+140>:	mov    %esp,%ebp
0xf01018ee in pic_init () at picirq.c:14
14	{
=> 0xf01018f0 <pic_init+142>:	sub    $0x14,%esp
0xf01018f0	14	{
=> 0xf01018f3 <pic_init+145>:	movzwl %ax,%eax
pic_init () at picirq.c:65
65			irq_setmask_8259A(irq_mask_8259A);
=> 0xf01018f6 <pic_init+148>:	push   %eax
0xf01018f6	65			irq_setmask_8259A(irq_mask_8259A);
=> 0xf01018f7 <pic_init+149>:	call   0xf01017ea <irq_setmask_8259A>
0xf01018f7 in pic_init () at picirq.c:65
65			irq_setmask_8259A(irq_mask_8259A);
=> 0xf01017ea <irq_setmask_8259A>:	push   %ebp
irq_setmask_8259A (mask=0xfffa) at picirq.c:70
70	{
=> 0xf01017eb <irq_setmask_8259A+1>:	mov    %esp,%ebp
0xf01017eb	70	{
=> 0xf01017ed <irq_setmask_8259A+3>:	push   %esi
0xf01017ed	70	{
=> 0xf01017ee <irq_setmask_8259A+4>:	push   %ebx
0xf01017ee	70	{
=> 0xf01017ef <irq_setmask_8259A+5>:	mov    0x8(%ebp),%eax
0xf01017ef	70	{
=> 0xf01017f2 <irq_setmask_8259A+8>:	mov    %ax,0xf010e306
72		irq_mask_8259A = mask;
=> 0xf01017f8 <irq_setmask_8259A+14>:	cmpb   $0x0,0xf010f268
73		if (!didinit)
=> 0xf01017ff <irq_setmask_8259A+21>:	je     0xf010185b <irq_setmask_8259A+113>
0xf01017ff	73		if (!didinit)
=> 0xf0101801 <irq_setmask_8259A+23>:	mov    %eax,%esi
0xf0101801	73		if (!didinit)
=> 0xf0101803 <irq_setmask_8259A+25>:	mov    $0x21,%edx
outb (data=0xfa, port=0x21) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0101808 <irq_setmask_8259A+30>:	out    %al,(%dx)
0xf0101808	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0101809 <irq_setmask_8259A+31>:	shr    $0x8,%ax
0xf0101809 in outb (data=0xff, port=0xa1) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf010180d <irq_setmask_8259A+35>:	mov    $0xa1,%edx
0xf010180d	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0101812 <irq_setmask_8259A+40>:	out    %al,(%dx)
0xf0101812	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0101813 <irq_setmask_8259A+41>:	sub    $0xc,%esp
irq_setmask_8259A (mask=0xfffa) at picirq.c:77
77		cprintf("enabled interrupts:");
=> 0xf0101816 <irq_setmask_8259A+44>:	push   $0xf0103259
0xf0101816	77		cprintf("enabled interrupts:");
=> 0xf010181b <irq_setmask_8259A+49>:	call   0xf0102529 <cprintf>
0xf010181b	77		cprintf("enabled interrupts:");
=> 0xf0102529 <cprintf>:	push   %ebp
cprintf (fmt=0xf0103259 "enabled interrupts:") at stdio.c:39
39	{
=> 0xf010252a <cprintf+1>:	mov    %esp,%ebp
0xf010252a	39	{
=> 0xf010252c <cprintf+3>:	sub    $0x10,%esp
0xf010252c	39	{
=> 0xf010252f <cprintf+6>:	lea    0xc(%ebp),%eax
43		va_start(ap, fmt);
=> 0xf0102532 <cprintf+9>:	push   %eax
44		cnt = vcprintf(fmt, ap);
=> 0xf0102533 <cprintf+10>:	pushl  0x8(%ebp)
0xf0102533	44		cnt = vcprintf(fmt, ap);
=> 0xf0102536 <cprintf+13>:	call   0xf0102503 <vcprintf>
0xf0102536	44		cnt = vcprintf(fmt, ap);
=> 0xf0102503 <vcprintf>:	push   %ebp
vcprintf (fmt=0xf0103259 "enabled interrupts:", ap=0xf010bfa4 "Ŀ\020\360\270\277", <incomplete sequence \360>) at stdio.c:30
30	{
=> 0xf0102504 <vcprintf+1>:	mov    %esp,%ebp
0xf0102504	30	{
=> 0xf0102506 <vcprintf+3>:	sub    $0x18,%esp
0xf0102506	30	{
=> 0xf0102509 <vcprintf+6>:	movl   $0x0,-0xc(%ebp)
31		int cnt = 0;
=> 0xf0102510 <vcprintf+13>:	pushl  0xc(%ebp)
33		vprintfmt((void*)putch, &cnt, fmt, ap);
=> 0xf0102513 <vcprintf+16>:	pushl  0x8(%ebp)
0xf0102513	33		vprintfmt((void*)putch, &cnt, fmt, ap);
=> 0xf0102516 <vcprintf+19>:	lea    -0xc(%ebp),%eax
0xf0102516	33		vprintfmt((void*)putch, &cnt, fmt, ap);
=> 0xf0102519 <vcprintf+22>:	push   %eax
0xf0102519	33		vprintfmt((void*)putch, &cnt, fmt, ap);
=> 0xf010251a <vcprintf+23>:	push   $0xf01020fb
0xf010251a	33		vprintfmt((void*)putch, &cnt, fmt, ap);
=> 0xf010251f <vcprintf+28>:	call   0xf0102118 <vprintfmt>
0xf010251f	33		vprintfmt((void*)putch, &cnt, fmt, ap);
=> 0xf0102118 <vprintfmt>:	push   %ebp
vprintfmt (putch=0xf01020fb <putch>, putdat=0xf010bf6c, fmt=0xf0103259 "enabled interrupts:", ap=0xf010bfa4 "Ŀ\020\360\270\277", <incomplete sequence \360>) at stdio.c:105
105	{
=> 0xf0102119 <vprintfmt+1>:	mov    %esp,%ebp
0xf0102119	105	{
=> 0xf010211b <vprintfmt+3>:	push   %edi
0xf010211b	105	{
  [32mEAX:[31m 0xF010BF6C  [32mEBX:[30m 0x00010094  [32mECX:[30m 0xF0117000  [32mEDX:[31m 0x000000A1  [1m[4m[31mo d i t S z a P c 
[0m  [32mESI:[31m 0x0000FFFA  [32mEDI:[30m 0x00000000  [32mEBP:[31m 0xF010BF48  [32mESP:[31m 0xF010BF48  [32mEIP:[31m 0xF010211B
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0023  [32mGS:[30m 0023  [32mSS:[30m 0010[0m
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
.gdbinit:23: Error in sourced command file:
localhost:26000: Connection timed out.

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Function "mem_init()" not defined.
Breakpoint 1 at 0xf010097c: file pmap.c, line 109.
Continuing.
The target architecture is assumed to be i386
=> 0xf010097c <mem_init>:	push   %ebp

Breakpoint 1, mem_init () at pmap.c:109
109	{
=> 0xf0100981 <mem_init+5>:	mov    $0x70,%edx
113		i386_detect_memory();
=> 0xf0100981 <mem_init+5>:	mov    $0x70,%edx
i386_detect_memory () at pmap.c:113
113		i386_detect_memory();
=> 0xf0100981 <mem_init+5>:	mov    $0x70,%edx
nvram_read (r=0x15) at pmap.c:113
113		i386_detect_memory();
=> 0xf0100981 <mem_init+5>:	mov    $0x70,%edx
mc146818_read (reg=0x15) at pmap.c:113
113		i386_detect_memory();
=> 0xf0100981 <mem_init+5>:	mov    $0x70,%edx
outb (data=0x15, port=0x70) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf010098c <mem_init+16>:	mov    $0x71,%ecx
mc146818_read (reg=0x15) at pmap.c:11
11		return inb(IO_RTC+1);
=> 0xf010098c <mem_init+16>:	mov    $0x71,%ecx
inb (port=0x71) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100996 <mem_init+26>:	mov    $0x70,%edx
nvram_read (r=0x15) at pmap.c:31
31		return mc146818_read(r) | (mc146818_read(r + 1) << 8);
=> 0xf0100996 <mem_init+26>:	mov    $0x70,%edx
mc146818_read (reg=0x16) at pmap.c:31
31		return mc146818_read(r) | (mc146818_read(r + 1) << 8);
=> 0xf0100996 <mem_init+26>:	mov    $0x70,%edx
outb (data=0x16, port=0x70) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01009a1 <mem_init+37>:	mov    %ecx,%edx
mc146818_read (reg=0x16) at pmap.c:11
11		return inb(IO_RTC+1);
=> 0xf01009a1 <mem_init+37>:	mov    %ecx,%edx
inb (port=0x71) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf01009a4 <mem_init+40>:	movzbl %al,%esi
i386_detect_memory () at pmap.c:41
41		npages_basemem = (nvram_read(NVRAM_BASELO) * 1024) / PGSIZE;
=> 0xf01009b8 <mem_init+60>:	mov    $0x70,%edx
42		npages_extmem = (nvram_read(NVRAM_EXTLO) * 1024) / PGSIZE;
=> 0xf01009b8 <mem_init+60>:	mov    $0x70,%edx
nvram_read (r=0x17) at pmap.c:42
42		npages_extmem = (nvram_read(NVRAM_EXTLO) * 1024) / PGSIZE;
=> 0xf01009b8 <mem_init+60>:	mov    $0x70,%edx
mc146818_read (reg=0x17) at pmap.c:42
42		npages_extmem = (nvram_read(NVRAM_EXTLO) * 1024) / PGSIZE;
=> 0xf01009b8 <mem_init+60>:	mov    $0x70,%edx
outb (data=0x17, port=0x70) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01009c3 <mem_init+71>:	mov    %ecx,%edx
mc146818_read (reg=0x17) at pmap.c:11
11		return inb(IO_RTC+1);
=> 0xf01009c3 <mem_init+71>:	mov    %ecx,%edx
inb (port=0x71) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf01009c8 <mem_init+76>:	mov    $0x70,%edx
nvram_read (r=0x17) at pmap.c:31
31		return mc146818_read(r) | (mc146818_read(r + 1) << 8);
=> 0xf01009c8 <mem_init+76>:	mov    $0x70,%edx
mc146818_read (reg=0x18) at pmap.c:31
31		return mc146818_read(r) | (mc146818_read(r + 1) << 8);
=> 0xf01009c8 <mem_init+76>:	mov    $0x70,%edx
outb (data=0x18, port=0x70) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01009d3 <mem_init+87>:	mov    %ecx,%edx
mc146818_read (reg=0x18) at pmap.c:11
11		return inb(IO_RTC+1);
=> 0xf01009d3 <mem_init+87>:	mov    %ecx,%edx
inb (port=0x71) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf01009d6 <mem_init+90>:	movzbl %al,%ecx
i386_detect_memory () at pmap.c:42
42		npages_extmem = (nvram_read(NVRAM_EXTLO) * 1024) / PGSIZE;
=> 0xf01009e4 <mem_init+104>:	test   %ecx,%ecx
46		if (npages_extmem)
=> 0xf01009e8 <mem_init+108>:	add    $0x100,%ecx
47			npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
=> 0xf01009fc <mem_init+128>:	sub    $0x8,%esp
51		cprintf("Memory: %dK\n", npages*4);
=> 0xf010252f <cprintf+6>:	lea    0xc(%ebp),%eax
cprintf (fmt=0xf0102c60 "Memory: %dK\n") at stdio.c:43
43		va_start(ap, fmt);
=> 0xf0102532 <cprintf+9>:	push   %eax
44		cnt = vcprintf(fmt, ap);
=> 0xf0102509 <vcprintf+6>:	movl   $0x0,-0xc(%ebp)
vcprintf (fmt=0xf0102c60 "Memory: %dK\n", ap=0xf010bfc4 "") at stdio.c:31
31		int cnt = 0;
=> 0xf0102510 <vcprintf+13>:	pushl  0xc(%ebp)
33		vprintfmt((void*)putch, &cnt, fmt, ap);
Remote connection closed
The program is not being run.

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Breakpoint 1 at 0xf010097c: file pmap.c, line 109.
Cannot find bounds of current function
Continuing.
The target architecture is assumed to be i386
=> 0xf010097c <mem_init>:	push   %ebp

Breakpoint 1, mem_init () at pmap.c:109
109	{
=> 0xf0100981 <mem_init+5>:	mov    $0x70,%edx
113		i386_detect_memory();
=> 0xf0100981 <mem_init+5>:	mov    $0x70,%edx
i386_detect_memory () at pmap.c:113
113		i386_detect_memory();
=> 0xf0100981 <mem_init+5>:	mov    $0x70,%edx
nvram_read (r=0x15) at pmap.c:113
113		i386_detect_memory();
=> 0xf0100981 <mem_init+5>:	mov    $0x70,%edx
mc146818_read (reg=0x15) at pmap.c:113
113		i386_detect_memory();
=> 0xf0100981 <mem_init+5>:	mov    $0x70,%edx
outb (data=0x15, port=0x70) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf010098c <mem_init+16>:	mov    $0x71,%ecx
mc146818_read (reg=0x15) at pmap.c:11
11		return inb(IO_RTC+1);
=> 0xf0100991 <mem_init+21>:	mov    %ecx,%edx
0xf0100991 in inb (port=0x71) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100993 <mem_init+23>:	in     (%dx),%al
0xf0100993	68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100994 <mem_init+24>:	mov    %eax,%ebx
0xf0100994	68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100996 <mem_init+26>:	mov    $0x70,%edx
outb (data=0x16, port=0x70) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf010099b <mem_init+31>:	mov    $0x16,%eax
0xf010099b	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01009a0 <mem_init+36>:	out    %al,(%dx)
0xf01009a0	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01009a1 <mem_init+37>:	mov    %ecx,%edx
inb (port=0x71) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf01009a3 <mem_init+39>:	in     (%dx),%al
0xf01009a3	68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf01009a4 <mem_init+40>:	movzbl %al,%esi
i386_detect_memory () at pmap.c:41
41		npages_basemem = (nvram_read(NVRAM_BASELO) * 1024) / PGSIZE;
=> 0xf01009a7 <mem_init+43>:	shl    $0x8,%esi
0xf01009a7	41		npages_basemem = (nvram_read(NVRAM_BASELO) * 1024) / PGSIZE;
=> 0xf01009aa <mem_init+46>:	movzbl %bl,%ebx
0xf01009aa	41		npages_basemem = (nvram_read(NVRAM_BASELO) * 1024) / PGSIZE;
=> 0xf01009ad <mem_init+49>:	or     %ebx,%esi
0xf01009ad	41		npages_basemem = (nvram_read(NVRAM_BASELO) * 1024) / PGSIZE;
=> 0xf01009af <mem_init+51>:	shr    $0x2,%esi
0xf01009af	41		npages_basemem = (nvram_read(NVRAM_BASELO) * 1024) / PGSIZE;
=> 0xf01009b2 <mem_init+54>:	mov    %esi,0xf010e9c0
0xf01009b2	41		npages_basemem = (nvram_read(NVRAM_BASELO) * 1024) / PGSIZE;
=> 0xf01009b8 <mem_init+60>:	mov    $0x70,%edx
outb (data=0x17, port=0x70) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01009bd <mem_init+65>:	mov    $0x17,%eax
0xf01009bd	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01009c2 <mem_init+70>:	out    %al,(%dx)
0xf01009c2	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01009c3 <mem_init+71>:	mov    %ecx,%edx
mc146818_read (reg=0x17) at pmap.c:11
11		return inb(IO_RTC+1);
=> 0xf01009c3 <mem_init+71>:	mov    %ecx,%edx
inb (port=0x71) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf01009c8 <mem_init+76>:	mov    $0x70,%edx
nvram_read (r=0x17) at pmap.c:31
31		return mc146818_read(r) | (mc146818_read(r + 1) << 8);
=> 0xf01009cd <mem_init+81>:	mov    $0x18,%eax
0xf01009cd in outb (data=0x18, port=0x70) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01009d2 <mem_init+86>:	out    %al,(%dx)
0xf01009d2	118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01009d3 <mem_init+87>:	mov    %ecx,%edx
inb (port=0x71) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf01009d5 <mem_init+89>:	in     (%dx),%al
0xf01009d5	68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf01009d6 <mem_init+90>:	movzbl %al,%ecx
i386_detect_memory () at pmap.c:42
42		npages_extmem = (nvram_read(NVRAM_EXTLO) * 1024) / PGSIZE;
=> 0xf01009d9 <mem_init+93>:	shl    $0x8,%ecx
0xf01009d9	42		npages_extmem = (nvram_read(NVRAM_EXTLO) * 1024) / PGSIZE;
=> 0xf01009dc <mem_init+96>:	movzbl %bl,%ebx
0xf01009dc	42		npages_extmem = (nvram_read(NVRAM_EXTLO) * 1024) / PGSIZE;
=> 0xf01009df <mem_init+99>:	or     %ebx,%ecx
0xf01009df	42		npages_extmem = (nvram_read(NVRAM_EXTLO) * 1024) / PGSIZE;
=> 0xf01009e1 <mem_init+101>:	shr    $0x2,%ecx
0xf01009e1	42		npages_extmem = (nvram_read(NVRAM_EXTLO) * 1024) / PGSIZE;
=> 0xf01009e4 <mem_init+104>:	test   %ecx,%ecx
46		if (npages_extmem)
=> 0xf01009e6 <mem_init+106>:	je     0xf01009f6 <mem_init+122>
0xf01009e6	46		if (npages_extmem)
=> 0xf01009e8 <mem_init+108>:	add    $0x100,%ecx
47			npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
=> 0xf01009ee <mem_init+114>:	mov    %ecx,0xf010f278
0xf01009ee	47			npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
=> 0xf01009f4 <mem_init+120>:	jmp    0xf01009fc <mem_init+128>
0xf01009f4	47			npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
=> 0xf01009fc <mem_init+128>:	sub    $0x8,%esp
51		cprintf("Memory: %dK\n", npages*4);
=> 0xf010252f <cprintf+6>:	lea    0xc(%ebp),%eax
cprintf (fmt=0xf0102c60 "Memory: %dK\n") at stdio.c:43
43		va_start(ap, fmt);
=> 0xf0102532 <cprintf+9>:	push   %eax
44		cnt = vcprintf(fmt, ap);
=> 0xf0102509 <vcprintf+6>:	movl   $0x0,-0xc(%ebp)
vcprintf (fmt=0xf0102c60 "Memory: %dK\n", ap=0xf010bfc4 "") at stdio.c:31
31		int cnt = 0;
=> 0xf0102510 <vcprintf+13>:	pushl  0xc(%ebp)
33		vprintfmt((void*)putch, &cnt, fmt, ap);
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Breakpoint 1 at 0xf010097c: file pmap.c, line 109.
Cannot find bounds of current function
Continuing.
The target architecture is assumed to be i386
=> 0xf010097c <mem_init>:	push   %ebp

Breakpoint 1, mem_init () at pmap.c:109
109	{
=> 0xf0100981 <mem_init+5>:	mov    $0x70,%edx
113		i386_detect_memory();
=> 0xf0100981 <mem_init+5>:	mov    $0x70,%edx
i386_detect_memory () at pmap.c:113
113		i386_detect_memory();
=> 0xf0100981 <mem_init+5>:	mov    $0x70,%edx
nvram_read (r=0x15) at pmap.c:113
113		i386_detect_memory();
=> 0xf0100981 <mem_init+5>:	mov    $0x70,%edx
mc146818_read (reg=0x15) at pmap.c:113
113		i386_detect_memory();
Breakpoint 2 at 0xf01027a3: file string.c, line 117.
Continuing.
=> 0xf01027a3 <memset>:	push   %ebp

Breakpoint 2, memset (v=0xf0110000, c=0x0, n=0x1000) at string.c:117
117	{
=> 0xf01027a4 <memset+1>:	mov    %esp,%ebp
0xf01027a4	117	{
=> 0xf01027a6 <memset+3>:	push   %edi
0xf01027a6	117	{
=> 0xf01027a7 <memset+4>:	push   %esi
0xf01027a7	117	{
=> 0xf01027a8 <memset+5>:	push   %ebx
0xf01027a8	117	{
=> 0xf01027af <memset+12>:	test   %ecx,%ecx
119		if (n == 0)
Breakpoint 3 at 0xf0100911: file pmap.c, line 338.
Continuing.
=> 0xf01027a3 <memset>:	push   %ebp

Breakpoint 2, memset (v=0xf0111000, c=0x0, n=0x6000) at string.c:117
117	{
Continuing.
=> 0xf0100911 <boot_map_region>:	shr    $0xc,%ecx

Breakpoint 3, boot_map_region (pgdir=0xf0110000, va=va@entry=0xef000000, size=0x6000, pa=0x111000, perm=0x3) at pmap.c:338
338		for (i = 0; i < size/PGSIZE; i++) {
=> 0xf0100918 <boot_map_region+7>:	push   %ebp
334	{
=> 0xf0100927 <boot_map_region+22>:	mov    %edx,%esi
boot_map_region (pgdir=0xf0110000, va=0xef000000, size=<optimized out>, pa=<optimized out>, perm=0x3) at pmap.c:338
338		for (i = 0; i < size/PGSIZE; i++) {
=> 0xf0100936 <boot_map_region+37>:	mov    0xc(%ebp),%eax
342			*pte = PTE_ADDR(pa) | perm | PTE_P;
=> 0xf0100945 <boot_map_region+52>:	sub    $0x4,%esp
339			pte = pgdir_walk(pgdir, (void*)va, 1);
=> 0xf010088c <pgdir_walk>:	push   %ebp
pgdir_walk (pgdir=0xf0110000, va=0xef000000, create=0x1) at pmap.c:303
303	{
=> 0xf0100894 <pgdir_walk+8>:	mov    %ebx,%esi
305		pde_t * pde = &pgdir[PDX(va)];
=> 0xf010089f <pgdir_walk+19>:	mov    (%esi),%eax
307		if (*pde & PTE_P) {
=> 0xf01008b2 <pgdir_walk+38>:	mov    $0x0,%eax
313				return NULL;
=> 0xf01008b7 <pgdir_walk+43>:	cmpl   $0x0,0x10(%ebp)
312			if (!create || !(pp = page_alloc(ALLOC_ZERO)) || !(pgtable = (pte_t *)page2kva(pp))){
=> 0xf0100800 <page_alloc+7>:	mov    0xf010e9bc,%ebx
page_alloc (alloc_flags=0x1) at pmap.c:255
255		if (!page_free_list)
=> 0xf010080a <page_alloc+17>:	mov    (%ebx),%eax
258		page_free_list = result->pp_link;
=> 0xf0100811 <page_alloc+24>:	movl   $0x0,(%ebx)
259		result->pp_link = NULL;
=> 0xf0100817 <page_alloc+30>:	testb  $0x1,0x8(%ebp)
260		if (alloc_flags & ALLOC_ZERO)
=> 0xf010081d <page_alloc+36>:	sub    $0x4,%esp
261			memset(page2kva(result), 0, PGSIZE);
=> 0xf01027a3 <memset>:	push   %ebp

Breakpoint 2, memset (v=0xf0001000, c=0x0, n=0x1000) at string.c:117
117	{
=> 0xf01027af <memset+12>:	test   %ecx,%ecx
119		if (n == 0)
=> 0xf01027b3 <memset+16>:	test   $0x3,%edi
121		if ((int)v%4 == 0 && n%4 == 0) {
=> 0xf01027c0 <memset+29>:	movzbl 0xc(%ebp),%edx
122			c &= 0xFF;
=> 0xf01027c4 <memset+33>:	mov    %edx,%ebx
123			c = (c<<24)|(c<<16)|(c<<8)|c;
=> 0xf01027c6 <memset+35>:	shl    $0x8,%ebx
0xf01027c6	123			c = (c<<24)|(c<<16)|(c<<8)|c;
=> 0xf01027c9 <memset+38>:	mov    %edx,%esi
0xf01027c9	123			c = (c<<24)|(c<<16)|(c<<8)|c;
=> 0xf01027cb <memset+40>:	shl    $0x18,%esi
0xf01027cb	123			c = (c<<24)|(c<<16)|(c<<8)|c;
=> 0xf01027ce <memset+43>:	mov    %edx,%eax
0xf01027ce	123			c = (c<<24)|(c<<16)|(c<<8)|c;
=> 0xf01027d0 <memset+45>:	shl    $0x10,%eax
0xf01027d0	123			c = (c<<24)|(c<<16)|(c<<8)|c;
=> 0xf01027d3 <memset+48>:	or     %esi,%eax
0xf01027d3	123			c = (c<<24)|(c<<16)|(c<<8)|c;
=> 0xf01027d5 <memset+50>:	or     %eax,%edx
0xf01027d5	123			c = (c<<24)|(c<<16)|(c<<8)|c;
=> 0xf01027d7 <memset+52>:	mov    %ebx,%eax
124			asm volatile("cld; rep stosl\n"
=> 0xf01027d9 <memset+54>:	or     %edx,%eax
0xf01027d9	124			asm volatile("cld; rep stosl\n"
=> 0xf01027db <memset+56>:	shr    $0x2,%ecx
0xf01027db	124			asm volatile("cld; rep stosl\n"
=> 0xf01027de <memset+59>:	cld    
0xf01027de	124			asm volatile("cld; rep stosl\n"
=> 0xf01027df <memset+60>:	rep stos %eax,%es:(%edi)
0xf01027df	124			asm volatile("cld; rep stosl\n"
=> 0xf01027df <memset+60>:	rep stos %eax,%es:(%edi)
0xf01027df	124			asm volatile("cld; rep stosl\n"
=> 0xf01027df <memset+60>:	rep stos %eax,%es:(%edi)
0xf01027df	124			asm volatile("cld; rep stosl\n"
=> 0xf01027df <memset+60>:	rep stos %eax,%es:(%edi)
0xf01027df	124			asm volatile("cld; rep stosl\n"
=> 0xf01027df <memset+60>:	rep stos %eax,%es:(%edi)
0xf01027df	124			asm volatile("cld; rep stosl\n"
=> 0xf01027df <memset+60>:	rep stos %eax,%es:(%edi)
0xf01027df	124			asm volatile("cld; rep stosl\n"
=> 0xf01027df <memset+60>:	rep stos %eax,%es:(%edi)
0xf01027df	124			asm volatile("cld; rep stosl\n"
=> 0xf01027df <memset+60>:	rep stos %eax,%es:(%edi)
0xf01027df	124			asm volatile("cld; rep stosl\n"
=> 0xf01027e9 <memset+70>:	mov    %edi,%eax
132	}
=> 0xf0100843 <page_alloc+74>:	mov    %ebx,%eax
page_alloc (alloc_flags=0x1) at pmap.c:263
263	}
=> 0xf01008ce <pgdir_walk+66>:	mov    %eax,%ecx
page2kva (pp=0xf0111008) at pmap.c:312
312			if (!create || !(pp = page_alloc(ALLOC_ZERO)) || !(pgtable = (pte_t *)page2kva(pp))){
=> 0xf01008ce <pgdir_walk+66>:	mov    %eax,%ecx
page2pa (pp=0xf0111008) at ./pmap.h:76
76		return (pp - pages) << PGSHIFT;
=> 0xf01008dc <pgdir_walk+80>:	mov    %ecx,%edx
pgdir_walk (pgdir=0xf0110000, va=0xef000000, create=0x1) at pmap.c:312
312			if (!create || !(pp = page_alloc(ALLOC_ZERO)) || !(pgtable = (pte_t *)page2kva(pp))){
=> 0xf01008e6 <pgdir_walk+90>:	addw   $0x1,0x4(%eax)
315			pp->pp_ref ++;
=> 0xf01008eb <pgdir_walk+95>:	or     $0x7,%ecx
316			*pde = PADDR(pgtable) | PTE_P | PTE_W | PTE_U;
=> 0xf01008f0 <pgdir_walk+100>:	mov    %ebx,%eax
319		return &pgtable[PTX(va)];
=> 0xf010090a <pgdir_walk+126>:	lea    -0x8(%ebp),%esp
320	}
=> 0xf0100953 <boot_map_region+66>:	add    $0x10,%esp
boot_map_region (pgdir=0xf0110000, va=0xef000000, size=<optimized out>, pa=0x111000, perm=0x3) at pmap.c:340
340			if (!pte)
=> 0xf010095a <boot_map_region+73>:	and    $0xfffff000,%ebx
boot_map_region (pgdir=0xf0110000, va=0xef000000, size=<optimized out>, pa=0x111000, perm=0x3) at pmap.c:342
342			*pte = PTE_ADDR(pa) | perm | PTE_P;
=> 0xf0100965 <boot_map_region+84>:	add    $0x1000,%esi
344			va += PGSIZE;
=> 0xf010096b <boot_map_region+90>:	add    $0x1,%edi
338		for (i = 0; i < size/PGSIZE; i++) {
=> 0xf0100945 <boot_map_region+52>:	sub    $0x4,%esp
339			pte = pgdir_walk(pgdir, (void*)va, 1);
=> 0xf010088c <pgdir_walk>:	push   %ebp
pgdir_walk (pgdir=0xf0110000, va=0xef001000, create=0x1) at pmap.c:303
303	{
=> 0xf0100894 <pgdir_walk+8>:	mov    %ebx,%esi
305		pde_t * pde = &pgdir[PDX(va)];
  [32mEAX:[31m 0x11111000  [32mEBX:[31m 0xEF001000  [32mECX:[31m 0x00001007  [32mEDX:[31m 0xF0001000  [1m[4m[31mo d i t S z A p c 
[0m  [32mESI:[31m 0xEF001000  [32mEDI:[31m 0x00000001  [32mEBP:[31m 0xF010BF78  [32mESP:[31m 0xF010BF70  [32mEIP:[31m 0xF0100894
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0010  [32mGS:[30m 0010  [32mSS:[30m 0010[0m
$1 = 0xf0104000 ""
$2 = (struct Env *) 0xf0117000
$3 = (struct PageInfo *) 0xf0111000
Function "env_inti" not defined.
Breakpoint 4 at 0xf0101a83: file env.c, line 115.
Continuing.
=> 0xf0100911 <boot_map_region>:	shr    $0xc,%ecx

Breakpoint 3, boot_map_region (pgdir=0xf0110000, va=va@entry=0xeec00000, size=size@entry=0x400000, pa=0x117000, perm=0x5) at pmap.c:338
338		for (i = 0; i < size/PGSIZE; i++) {
  [32mEAX:[31m 0xF0110000  [32mEBX:[31m 0x00000C00  [32mECX:[31m 0x00400000  [32mEDX:[31m 0xEEC00000  [1m[4m[31mo d i t s z a P C 
[0m  [32mESI:[31m 0x000000A0  [32mEDI:[31m 0x00000000  [32mEBP:[31m 0xF010BFD8  [32mESP:[31m 0xF010BFBC  [32mEIP:[31m 0xF0100911
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0010  [32mGS:[30m 0010  [32mSS:[30m 0010[0m
=> 0xf0100914 <boot_map_region+3>:	test   %ecx,%ecx
0xf0100914	338		for (i = 0; i < size/PGSIZE; i++) {
=> 0xf0100916 <boot_map_region+5>:	je     0xf010097a <boot_map_region+105>
0xf0100916	338		for (i = 0; i < size/PGSIZE; i++) {
=> 0xf0100918 <boot_map_region+7>:	push   %ebp
334	{
  [32mEAX:[30m 0xF0110000  [32mEBX:[30m 0x00000C00  [32mECX:[31m 0x00000400  [32mEDX:[30m 0xEEC00000  [1m[4m[31mo d i t s z a P c 
[0m  [32mESI:[30m 0x000000A0  [32mEDI:[30m 0x00000000  [32mEBP:[30m 0xF010BFD8  [32mESP:[30m 0xF010BFBC  [32mEIP:[31m 0xF0100918
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0010  [32mGS:[30m 0010  [32mSS:[30m 0010[0m
=> 0xf0100919 <boot_map_region+8>:	mov    %esp,%ebp
0xf0100919 in boot_map_region (pgdir=0xf0110000, va=0xeec00000, size=<optimized out>, pa=<optimized out>, perm=0x5) at pmap.c:334
334	{
  [32mEAX:[30m 0xF0110000  [32mEBX:[30m 0x00000C00  [32mECX:[30m 0x00000400  [32mEDX:[30m 0xEEC00000  [1m[4m[31mo d i t s z a P c 
[0m  [32mESI:[30m 0x000000A0  [32mEDI:[30m 0x00000000  [32mEBP:[30m 0xF010BFD8  [32mESP:[31m 0xF010BFB8  [32mEIP:[31m 0xF0100919
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0010  [32mGS:[30m 0010  [32mSS:[30m 0010[0m
$4 = 0xf0104000 ""
$5 = 0x10d021
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
$1 = 0x0
$2 = 0x0
[f000:e05b]    0x15805b:	add    %al,(%bx,%si)
0x0000e05b in ?? ()
[f000:e062]    0x158062:	add    %al,(%bx,%si)
0x0000e062 in ?? ()
[f000:e066]    0x158066:	add    %al,(%bx,%si)
0x0000e066 in ?? ()
[f000:e068]    0x158068:	add    %al,(%bx,%si)
0x0000e068 in ?? ()
[f000:e06a]    0x15806a:	add    %al,(%bx,%si)
0x0000e06a in ?? ()
Breakpoint 1 at 0xf010097c: file pmap.c, line 109.
Continuing.
The target architecture is assumed to be i386
=> 0xf010097c <mem_init>:	push   %ebp

Breakpoint 1, mem_init () at pmap.c:109
109	{
Note: breakpoint 1 also set at pc 0xf010097c.
Breakpoint 2 at 0xf010097c: file pmap.c, line 109.
$3 = 0xf0104000 ""
$4 = 0x10d021
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Breakpoint 1 at 0xf010097c: file pmap.c, line 109.
Continuing.
The target architecture is assumed to be i386
=> 0xf010097c <mem_init>:	push   %ebp

Breakpoint 1, mem_init () at pmap.c:109
109	{
$1 = 0x10d021
$2 = 0xf0104000 ""
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Breakpoint 1 at 0xf0100084: file init.c, line 20.
Continuing.
The target architecture is assumed to be i386
=> 0xf0100084 <i386_init>:	push   %ebp

Breakpoint 1, i386_init () at init.c:20
20	{
  [32mEAX:[31m 0xF010002F  [32mEBX:[31m 0x00010094  [32mECX:[30m 0x00000000  [32mEDX:[31m 0x000001F0  [1m[4m[31mo d i t S z a P c 
[0m  [32mESI:[31m 0x00010094  [32mEDI:[30m 0x00000000  [32mEBP:[30m 0x00000000  [32mESP:[31m 0xF010BFFC  [32mEIP:[31m 0xF0100084
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0010  [32mGS:[30m 0010  [32mSS:[30m 0010[0m
No symbol "esp" in current context.
A syntax error in expression, near `%esp'.
  [32mEAX:[30m 0xF010002F  [32mEBX:[30m 0x00010094  [32mECX:[30m 0x00000000  [32mEDX:[30m 0x000001F0  [1m[4m[31mo d i t S z a P c 
[0m  [32mESI:[30m 0x00010094  [32mEDI:[30m 0x00000000  [32mEBP:[30m 0x00000000  [32mESP:[30m 0xF010BFFC  [32mEIP:[31m 0xF0100084
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0010  [32mGS:[30m 0010  [32mSS:[30m 0010[0m
Undefined command: "infor".  Try "help".
Undefined info command: "%esp".  Try "help info".
Undefined info command: "esp".  Try "help info".
eax            0xf010002f	0xf010002f
ecx            0x0	0x0
edx            0x1f0	0x1f0
ebx            0x10094	0x10094
esp            0xf010bffc	0xf010bffc
ebp            0x0	0x0
esi            0x10094	0x10094
edi            0x0	0x0
eip            0xf0100084	0xf0100084 <i386_init>
eflags         0x86	[ PF SF ]
cs             0x8	0x8
ss             0x10	0x10
ds             0x10	0x10
es             0x10	0x10
fs             0x10	0x10
gs             0x10	0x10
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
  [32mEAX:[30m 0x00000000  [32mEBX:[30m 0x00000000  [32mECX:[30m 0x00000000  [32mEDX:[31m 0x00000663  [1m[4m[31mo d i t s z a p c 
[0m  [32mESI:[30m 0x00000000  [32mEDI:[30m 0x00000000  [32mEBP:[30m 0x00000000  [32mESP:[30m 0x00000000  [32mEIP:[31m 0x0000FFF0
  [32mCS:[30m F000  [32mDS:[30m 0000  [32mES:[30m 0000  [32mFS:[30m 0000  [32mGS:[30m 0000  [32mSS:[30m 0000[0m
[f000:e05b]    0x15805b:	add    %al,(%bx,%si)
0x0000e05b in ?? ()
Function "bootmain" not defined.
[f000:e062]    0x158062:	add    %al,(%bx,%si)
0x0000e062 in ?? ()
[f000:e066]    0x158066:	add    %al,(%bx,%si)
0x0000e066 in ?? ()
[f000:e068]    0x158068:	add    %al,(%bx,%si)
0x0000e068 in ?? ()
[f000:e06a]    0x15806a:	add    %al,(%bx,%si)
0x0000e06a in ?? ()
[f000:e070]    0x158070:	add    %al,(%bx,%si)
0x0000e070 in ?? ()
[f000:e076]    0x158076:	add    %al,(%bx,%si)
0x0000e076 in ?? ()
[f000:d165]    0x157165:	add    %al,(%bx,%si)
0x0000d165 in ?? ()
[f000:d168]    0x157168:	add    %al,(%bx,%si)
0x0000d168 in ?? ()
[f000:d169]    0x157169:	add    %al,(%bx,%si)
0x0000d169 in ?? ()
[f000:d16a]    0x15716a:	add    %al,(%bx,%si)
0x0000d16a in ?? ()
[f000:d170]    0x157170:	add    %al,(%bx,%si)
0x0000d170 in ?? ()
[f000:d172]    0x157172:	add    %al,(%bx,%si)
0x0000d172 in ?? ()
[f000:d174]    0x157174:	add    %al,(%bx,%si)
0x0000d174 in ?? ()
[f000:d176]    0x157176:	add    %al,(%bx,%si)
0x0000d176 in ?? ()
[f000:d178]    0x157178:	add    %al,(%bx,%si)
0x0000d178 in ?? ()
[f000:d17a]    0x15717a:	add    %al,(%bx,%si)
0x0000d17a in ?? ()
[f000:d180]    0x157180:	add    %al,(%bx,%si)
0x0000d180 in ?? ()
[f000:d186]    0x157186:	add    %al,(%bx,%si)
0x0000d186 in ?? ()
[f000:d189]    0x157189:	add    %al,(%bx,%si)
0x0000d189 in ?? ()
[f000:d18d]    0x15718d:	add    %al,(%bx,%si)
0x0000d18d in ?? ()
[f000:d190]    0x157190:	add    %al,(%bx,%si)
0x0000d190 in ?? ()
The target architecture is assumed to be i386
=> 0xfd198:	mov    $0x10,%eax
0x000fd198 in ?? ()
=> 0xfd19d:	mov    %eax,%ds
0x000fd19d in ?? ()
=> 0xfd19f:	mov    %eax,%es
0x000fd19f in ?? ()
=> 0xfd1a1:	mov    %eax,%ss
0x000fd1a1 in ?? ()
=> 0xfd1a3:	mov    %eax,%fs
0x000fd1a3 in ?? ()
=> 0xfd1a5:	mov    %eax,%gs
0x000fd1a5 in ?? ()
=> 0xfd1a7:	mov    %ecx,%eax
0x000fd1a7 in ?? ()
=> 0xfd1a9:	jmp    *%edx
0x000fd1a9 in ?? ()
=> 0xf3691:	push   %ebx
0x000f3691 in ?? ()
=> 0xf3692:	sub    $0x20,%esp
0x000f3692 in ?? ()
=> 0xf3695:	push   $0xf5cf8
0x000f3695 in ?? ()
=> 0xf369a:	push   $0xf4770
0x000f369a in ?? ()
=> 0xf369f:	call   0xf0cc9
0x000f369f in ?? ()
=> 0xf0cc9:	lea    0x8(%esp),%ecx
0x000f0cc9 in ?? ()
=> 0xf0ccd:	mov    0x4(%esp),%edx
0x000f0ccd in ?? ()
=> 0xf0cd1:	mov    $0xf5cf4,%eax
0x000f0cd1 in ?? ()
=> 0xf0cd6:	call   0xf0854
0x000f0cd6 in ?? ()
=> 0xf0854:	push   %ebp
0x000f0854 in ?? ()
=> 0xf0855:	push   %edi
0x000f0855 in ?? ()
=> 0xf0856:	push   %esi
0x000f0856 in ?? ()
=> 0xf0857:	push   %ebx
0x000f0857 in ?? ()
=> 0xf0858:	sub    $0x8,%esp
0x000f0858 in ?? ()
=> 0xf085b:	mov    %eax,%edi
0x000f085b in ?? ()
=> 0xf085d:	mov    %edx,%esi
0x000f085d in ?? ()
=> 0xf085f:	mov    %ecx,%ebp
0x000f085f in ?? ()
=> 0xf0861:	movsbl (%esi),%edx
0x000f0861 in ?? ()
=> 0xf0864:	test   %dl,%dl
0x000f0864 in ?? ()
=> 0xf0866:	je     0xf0a72
0x000f0866 in ?? ()
=> 0xf086c:	cmp    $0x25,%dl
0x000f086c in ?? ()
=> 0xf086f:	jne    0xf0991
0x000f086f in ?? ()
=> 0xf0991:	mov    %edi,%eax
0x000f0991 in ?? ()
=> 0xf0993:	call   0xeff40
0x000f0993 in ?? ()
=> 0xeff40:	mov    %eax,%ecx
0x000eff40 in ?? ()
=> 0xeff42:	movsbl %dl,%edx
0x000eff42 in ?? ()
=> 0xeff45:	call   *(%ecx)
0x000eff45 in ?? ()
=> 0xeff35:	mov    %edx,%eax
0x000eff35 in ?? ()
=> 0xeff37:	mov    0xf6abc,%dx
0x000eff37 in ?? ()
=> 0xeff3e:	out    %al,(%dx)
0x000eff3e in ?? ()
=> 0xeff3f:	ret    
0x000eff3f in ?? ()
=> 0xeff47:	ret    
0x000eff47 in ?? ()
=> 0xf0998:	jmp    0xf099c
0x000f0998 in ?? ()
=> 0xf099c:	inc    %esi
0x000f099c in ?? ()
=> 0xf099d:	jmp    0xf0861
0x000f099d in ?? ()
=> 0xf0861:	movsbl (%esi),%edx
0x000f0861 in ?? ()
=> 0xf0864:	test   %dl,%dl
0x000f0864 in ?? ()
=> 0xf0866:	je     0xf0a72
0x000f0866 in ?? ()
=> 0xf086c:	cmp    $0x25,%dl
0x000f086c in ?? ()
=> 0xf086f:	jne    0xf0991
0x000f086f in ?? ()
=> 0xf0991:	mov    %edi,%eax
0x000f0991 in ?? ()
=> 0xf0993:	call   0xeff40
0x000f0993 in ?? ()
=> 0xeff40:	mov    %eax,%ecx
0x000eff40 in ?? ()
=> 0xeff42:	movsbl %dl,%edx
0x000eff42 in ?? ()
=> 0xeff45:	call   *(%ecx)
0x000eff45 in ?? ()
=> 0xeff35:	mov    %edx,%eax
0x000eff35 in ?? ()
=> 0xeff37:	mov    0xf6abc,%dx
0x000eff37 in ?? ()
=> 0xeff3e:	out    %al,(%dx)
0x000eff3e in ?? ()
=> 0xeff3f:	ret    
0x000eff3f in ?? ()
=> 0xeff47:	ret    
0x000eff47 in ?? ()
=> 0xf0998:	jmp    0xf099c
0x000f0998 in ?? ()
=> 0xf099c:	inc    %esi
0x000f099c in ?? ()
=> 0xf099d:	jmp    0xf0861
0x000f099d in ?? ()
=> 0xf0861:	movsbl (%esi),%edx
0x000f0861 in ?? ()
=> 0xf0864:	test   %dl,%dl
0x000f0864 in ?? ()
=> 0xf0866:	je     0xf0a72
0x000f0866 in ?? ()
=> 0xf086c:	cmp    $0x25,%dl
0x000f086c in ?? ()
=> 0xf086f:	jne    0xf0991
0x000f086f in ?? ()
=> 0xf0991:	mov    %edi,%eax
0x000f0991 in ?? ()
=> 0xf0993:	call   0xeff40
0x000f0993 in ?? ()
=> 0xeff40:	mov    %eax,%ecx
0x000eff40 in ?? ()
=> 0xeff42:	movsbl %dl,%edx
0x000eff42 in ?? ()
=> 0xeff45:	call   *(%ecx)
0x000eff45 in ?? ()
=> 0xeff35:	mov    %edx,%eax
0x000eff35 in ?? ()
=> 0xeff37:	mov    0xf6abc,%dx
0x000eff37 in ?? ()
=> 0xeff3e:	out    %al,(%dx)
0x000eff3e in ?? ()
=> 0xeff3f:	ret    
0x000eff3f in ?? ()
=> 0xeff47:	ret    
0x000eff47 in ?? ()
=> 0xf0998:	jmp    0xf099c
0x000f0998 in ?? ()
=> 0xf099c:	inc    %esi
0x000f099c in ?? ()
=> 0xf099d:	jmp    0xf0861
0x000f099d in ?? ()
=> 0xf0861:	movsbl (%esi),%edx
0x000f0861 in ?? ()
=> 0xf0864:	test   %dl,%dl
0x000f0864 in ?? ()
=> 0xf0866:	je     0xf0a72
0x000f0866 in ?? ()
=> 0xf086c:	cmp    $0x25,%dl
0x000f086c in ?? ()
=> 0xf086f:	jne    0xf0991
0x000f086f in ?? ()
=> 0xf0991:	mov    %edi,%eax
0x000f0991 in ?? ()
=> 0xf0993:	call   0xeff40
0x000f0993 in ?? ()
=> 0xeff40:	mov    %eax,%ecx
0x000eff40 in ?? ()
=> 0xeff42:	movsbl %dl,%edx
0x000eff42 in ?? ()
=> 0xeff45:	call   *(%ecx)
0x000eff45 in ?? ()
=> 0xeff35:	mov    %edx,%eax
0x000eff35 in ?? ()
=> 0xeff37:	mov    0xf6abc,%dx
0x000eff37 in ?? ()
=> 0xeff3e:	out    %al,(%dx)
0x000eff3e in ?? ()
=> 0xeff3f:	ret    
0x000eff3f in ?? ()
=> 0xeff47:	ret    
0x000eff47 in ?? ()
=> 0xf0998:	jmp    0xf099c
0x000f0998 in ?? ()
=> 0xf099c:	inc    %esi
0x000f099c in ?? ()
=> 0xf099d:	jmp    0xf0861
0x000f099d in ?? ()
=> 0xf0861:	movsbl (%esi),%edx
0x000f0861 in ?? ()
=> 0xf0864:	test   %dl,%dl
0x000f0864 in ?? ()
=> 0xf0866:	je     0xf0a72
0x000f0866 in ?? ()
=> 0xf086c:	cmp    $0x25,%dl
0x000f086c in ?? ()
=> 0xf086f:	jne    0xf0991
0x000f086f in ?? ()
=> 0xf0991:	mov    %edi,%eax
0x000f0991 in ?? ()
=> 0xf0993:	call   0xeff40
0x000f0993 in ?? ()
=> 0xeff40:	mov    %eax,%ecx
0x000eff40 in ?? ()
=> 0xeff42:	movsbl %dl,%edx
0x000eff42 in ?? ()
=> 0xeff45:	call   *(%ecx)
0x000eff45 in ?? ()
=> 0xeff35:	mov    %edx,%eax
0x000eff35 in ?? ()
=> 0xf36f1:	test   %eax,%eax
0x000f36f1 in ?? ()
=> 0xf36b5:	lea    0xc(%esp),%ecx
0x000f36b5 in ?? ()
=> 0xf01c4:	mov    %ecx,%edi
0x000f01c4 in ?? ()
=> 0xf01d7:	pop    %ecx
0x000f01d7 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
=> 0xffff0544:	rep movsb %ds:(%esi),%es:(%edi)
0xffff0544 in ?? ()
Breakpoint 1 at 0xf010000c: file entry.S, line 41.
Continuing.
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Breakpoint 1 at 0xf010000c: file entry.S, line 41.
Continuing.
Remote connection closed
The program is not being run.

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
[f000:e05b]    0x15805b:	add    %al,(%bx,%si)
0x0000e05b in ?? ()
$1 = 0x0
$2 = 0x0
  [32mEAX:[30m 0x00000000  [32mEBX:[30m 0x00000000  [32mECX:[30m 0x00000000  [32mEDX:[31m 0x00000663  [1m[4m[31mo d i t s z a p c 
[0m  [32mESI:[30m 0x00000000  [32mEDI:[30m 0x00000000  [32mEBP:[30m 0x00000000  [32mESP:[30m 0x00000000  [32mEIP:[31m 0x0000E05B
  [32mCS:[30m F000  [32mDS:[30m 0000  [32mES:[30m 0000  [32mFS:[30m 0000  [32mGS:[30m 0000  [32mSS:[30m 0000[0m
  [32mEAX:[30m 0x00000000  [32mEBX:[30m 0x00000000  [32mECX:[30m 0x00000000  [32mEDX:[30m 0x00000663  [1m[4m[31mo d i t s z a p c 
[0m  [32mESI:[30m 0x00000000  [32mEDI:[30m 0x00000000  [32mEBP:[30m 0x00000000  [32mESP:[30m 0x00000000  [32mEIP:[31m 0x0000E05B
  [32mCS:[30m F000  [32mDS:[30m 0000  [32mES:[30m 0000  [32mFS:[30m 0000  [32mGS:[30m 0000  [32mSS:[30m 0000[0m
Breakpoint 1 at 0xf0100084: file init.c, line 20.
Continuing.
The target architecture is assumed to be i386
=> 0xf0100084 <i386_init>:	push   %ebp

Breakpoint 1, i386_init () at init.c:20
20	{
$3 = 0x10d021
$4 = 0x0
Undefined command: "ewf".  Try "help".
  [32mEAX:[31m 0xF010002F  [32mEBX:[31m 0x00010094  [32mECX:[30m 0x00000000  [32mEDX:[31m 0x000001F0  [1m[4m[31mo d i t S z a P c 
[0m  [32mESI:[31m 0x00010094  [32mEDI:[30m 0x00000000  [32mEBP:[30m 0x00000000  [32mESP:[31m 0xF010BFFC  [32mEIP:[31m 0xF0100084
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0010  [32mGS:[30m 0010  [32mSS:[30m 0010[0m
$5 = 0xf000ff53
$6 = 0x0
$7 = 0x10d021
Detaching from program: , Remote target
Ending remote debugging.

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
$1 = 0x0
$2 = 0x0
[f000:e05b]    0x15805b:	add    %al,(%bx,%si)
0x0000e05b in ?? ()
The target architecture is assumed to be i386
=> 0xeff37:	mov    0xf6abc,%dx
0x000eff37 in ?? ()
$3 = 0x0
=> 0xf097e:	test   %dl,%dl
0x000f097e in ?? ()
$4 = 0x0
=> 0xf01d7:	pop    %ecx
0x000f01d7 in ?? ()
$5 = 0x0
=> 0xf0209:	mov    %ecx,0x0(%ebp)
0x000f0209 in ?? ()
$6 = 0x0
=> 0xf36c8:	mov    %eax,0x1b(%esp)
0x000f36c8 in ?? ()
Function "0x7c32" not defined.
Breakpoint 1 at 0x7c32
Continuing.
=> 0x7c32:	mov    $0x10,%ax

Breakpoint 1, 0x00007c32 in ?? ()
=> 0x7c36:	mov    %eax,%ds
0x00007c36 in ?? ()
=> 0x7c38:	mov    %eax,%es
0x00007c38 in ?? ()
=> 0x7c3a:	mov    %eax,%fs
0x00007c3a in ?? ()
=> 0x7c3c:	mov    %eax,%gs
0x00007c3c in ?? ()
=> 0x7c3e:	mov    %eax,%ss
0x00007c3e in ?? ()
=> 0x7c40:	mov    $0x7c00,%esp
0x00007c40 in ?? ()
  [32mEAX:[31m 0x00000010  [32mEBX:[30m 0x00000000  [32mECX:[30m 0x00000000  [32mEDX:[31m 0x00000080  [1m[4m[31mo d i t s z a P c 
[0m  [32mESI:[30m 0x00000000  [32mEDI:[30m 0x00000000  [32mEBP:[30m 0x00000000  [32mESP:[31m 0x00006F2C  [32mEIP:[31m 0x00007C40
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0010  [32mGS:[30m 0010  [32mSS:[30m 0010[0m
=> 0x7c45:	call   0x7c6a
0x00007c45 in ?? ()
=> 0x7c6a:	push   %ebp
0x00007c6a in ?? ()
=> 0x7c6b:	mov    %esp,%ebp
0x00007c6b in ?? ()
=> 0x7c6d:	push   %esi
0x00007c6d in ?? ()
=> 0x7c6e:	push   %ebx
0x00007c6e in ?? ()
=> 0x7c6f:	sub    $0x4,%esp
0x00007c6f in ?? ()
=> 0x7c72:	push   $0x0
0x00007c72 in ?? ()
=> 0x7c74:	push   $0x1000
0x00007c74 in ?? ()
=> 0x7c79:	push   $0x10000
0x00007c79 in ?? ()
=> 0x7c7e:	call   0x7d5d
0x00007c7e in ?? ()
=> 0x7d5d:	push   %ebp
0x00007d5d in ?? ()
=> 0x7d5e:	mov    %esp,%ebp
0x00007d5e in ?? ()
  [32mEAX:[30m 0x00000010  [32mEBX:[30m 0x00000000  [32mECX:[30m 0x00000000  [32mEDX:[30m 0x00000080  [1m[4m[31mo d i t s z A p c 
[0m  [32mESI:[30m 0x00000000  [32mEDI:[30m 0x00000000  [32mEBP:[31m 0x00007BF8  [32mESP:[31m 0x00007BD8  [32mEIP:[31m 0x00007D5E
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0010  [32mGS:[30m 0010  [32mSS:[30m 0010[0m
=> 0x7d60:	push   %edi
0x00007d60 in ?? ()
=> 0x7d61:	push   %esi
0x00007d61 in ?? ()
=> 0x7d62:	push   %ebx
0x00007d62 in ?? ()
=> 0x7d63:	mov    0x8(%ebp),%ebx
0x00007d63 in ?? ()
=> 0x7d66:	mov    %ebx,%edi
0x00007d66 in ?? ()
=> 0x7d68:	add    0xc(%ebp),%edi
0x00007d68 in ?? ()
=> 0x7d6b:	and    $0xfffffe00,%ebx
0x00007d6b in ?? ()
=> 0x7d71:	mov    0x10(%ebp),%esi
0x00007d71 in ?? ()
=> 0x7d74:	shr    $0x9,%esi
0x00007d74 in ?? ()
=> 0x7d77:	add    $0x1,%esi
0x00007d77 in ?? ()
=> 0x7d7a:	cmp    %ebx,%edi
0x00007d7a in ?? ()
=> 0x7d7c:	jbe    0x7d95
0x00007d7c in ?? ()
=> 0x7d7e:	push   %esi
0x00007d7e in ?? ()
=> 0x7d7f:	push   %ebx
0x00007d7f in ?? ()
Cannot find bounds of current function
=> 0x7d80:	call   0x7cf5
0x00007d80 in ?? ()
=> 0x7cf5:	push   %ebp
0x00007cf5 in ?? ()
=> 0x7cf6:	mov    %esp,%ebp
0x00007cf6 in ?? ()
=> 0x7cf8:	push   %edi
0x00007cf8 in ?? ()
=> 0x7cf9:	push   %ebx
0x00007cf9 in ?? ()
=> 0x7cfa:	mov    0xc(%ebp),%ebx
0x00007cfa in ?? ()
=> 0x7cfd:	call   0x7ce3
0x00007cfd in ?? ()
=> 0x7ce3:	push   %ebp
0x00007ce3 in ?? ()
=> 0x7ce4:	mov    %esp,%ebp
0x00007ce4 in ?? ()
=> 0x7ce6:	mov    $0x1f7,%edx
0x00007ce6 in ?? ()
=> 0x7ceb:	in     (%dx),%al
0x00007ceb in ?? ()
=> 0x7cec:	and    $0xffffffc0,%eax
0x00007cec in ?? ()
=> 0x7cef:	cmp    $0x40,%al
0x00007cef in ?? ()
=> 0x7cf1:	jne    0x7ceb
0x00007cf1 in ?? ()
=> 0x7cf3:	pop    %ebp
0x00007cf3 in ?? ()
=> 0x7cf4:	ret    
0x00007cf4 in ?? ()
=> 0x7d02:	mov    $0x1f2,%edx
0x00007d02 in ?? ()
=> 0x7d07:	mov    $0x1,%eax
0x00007d07 in ?? ()
=> 0x7d0c:	out    %al,(%dx)
0x00007d0c in ?? ()
=> 0x7d0d:	mov    $0x1f3,%edx
0x00007d0d in ?? ()
=> 0x7d12:	mov    %ebx,%eax
0x00007d12 in ?? ()
=> 0x7d14:	out    %al,(%dx)
0x00007d14 in ?? ()
=> 0x7d15:	mov    %ebx,%eax
0x00007d15 in ?? ()
=> 0x7d17:	shr    $0x8,%eax
0x00007d17 in ?? ()
=> 0x7d1a:	mov    $0x1f4,%edx
0x00007d1a in ?? ()
=> 0x7d1f:	out    %al,(%dx)
0x00007d1f in ?? ()
=> 0x7d20:	mov    %ebx,%eax
0x00007d20 in ?? ()
=> 0x7d22:	shr    $0x10,%eax
0x00007d22 in ?? ()
=> 0x7d25:	mov    $0x1f5,%edx
0x00007d25 in ?? ()
=> 0x7d2a:	out    %al,(%dx)
0x00007d2a in ?? ()
=> 0x7d2b:	mov    %ebx,%eax
0x00007d2b in ?? ()
=> 0x7d2d:	shr    $0x18,%eax
0x00007d2d in ?? ()
=> 0x7d30:	or     $0xffffffe0,%eax
0x00007d30 in ?? ()
=> 0x7d33:	mov    $0x1f6,%edx
0x00007d33 in ?? ()
=> 0x7d38:	out    %al,(%dx)
0x00007d38 in ?? ()
=> 0x7d39:	mov    $0x1f7,%edx
0x00007d39 in ?? ()
=> 0x7d3e:	mov    $0x20,%eax
0x00007d3e in ?? ()
=> 0x7d43:	out    %al,(%dx)
0x00007d43 in ?? ()
=> 0x7d44:	call   0x7ce3
0x00007d44 in ?? ()
=> 0x7ce3:	push   %ebp
0x00007ce3 in ?? ()
=> 0x7ce4:	mov    %esp,%ebp
0x00007ce4 in ?? ()
=> 0x7ce6:	mov    $0x1f7,%edx
0x00007ce6 in ?? ()
=> 0x7ceb:	in     (%dx),%al
0x00007ceb in ?? ()
=> 0x7cec:	and    $0xffffffc0,%eax
0x00007cec in ?? ()
=> 0x7cef:	cmp    $0x40,%al
0x00007cef in ?? ()
=> 0x7cf1:	jne    0x7ceb
0x00007cf1 in ?? ()
=> 0x7cf3:	pop    %ebp
0x00007cf3 in ?? ()
=> 0x7cf4:	ret    
0x00007cf4 in ?? ()
=> 0x7d49:	mov    0x8(%ebp),%edi
0x00007d49 in ?? ()
=> 0x7d4c:	mov    $0x80,%ecx
0x00007d4c in ?? ()
=> 0x7d51:	mov    $0x1f0,%edx
0x00007d51 in ?? ()
=> 0x7d56:	cld    
0x00007d56 in ?? ()
=> 0x7d57:	repnz insl (%dx),%es:(%edi)
0x00007d57 in ?? ()
=> 0x7d57:	repnz insl (%dx),%es:(%edi)
0x00007d57 in ?? ()
=> 0x7d57:	repnz insl (%dx),%es:(%edi)
0x00007d57 in ?? ()
=> 0x7d57:	repnz insl (%dx),%es:(%edi)
0x00007d57 in ?? ()
=> 0x7d57:	repnz insl (%dx),%es:(%edi)
0x00007d57 in ?? ()
=> 0x7d57:	repnz insl (%dx),%es:(%edi)
0x00007d57 in ?? ()
=> 0x7d57:	repnz insl (%dx),%es:(%edi)
0x00007d57 in ?? ()
=> 0x7d57:	repnz insl (%dx),%es:(%edi)
0x00007d57 in ?? ()
=> 0x7d57:	repnz insl (%dx),%es:(%edi)
0x00007d57 in ?? ()
=> 0x7d57:	repnz insl (%dx),%es:(%edi)
0x00007d57 in ?? ()
=> 0x7d57:	repnz insl (%dx),%es:(%edi)
0x00007d57 in ?? ()
=> 0x7d57:	repnz insl (%dx),%es:(%edi)
0x00007d57 in ?? ()
=> 0x7d57:	repnz insl (%dx),%es:(%edi)
0x00007d57 in ?? ()
=> 0x7d57:	repnz insl (%dx),%es:(%edi)
0x00007d57 in ?? ()
=> 0x7d57:	repnz insl (%dx),%es:(%edi)
0x00007d57 in ?? ()
=> 0x7d57:	repnz insl (%dx),%es:(%edi)
0x00007d57 in ?? ()
=> 0x7d57:	repnz insl (%dx),%es:(%edi)
0x00007d57 in ?? ()
=> 0x7d57:	repnz insl (%dx),%es:(%edi)
0x00007d57 in ?? ()
=> 0x7d57:	repnz insl (%dx),%es:(%edi)
0x00007d57 in ?? ()
=> 0x7d57:	repnz insl (%dx),%es:(%edi)
0x00007d57 in ?? ()
=> 0x7d57:	repnz insl (%dx),%es:(%edi)
0x00007d57 in ?? ()
=> 0x7d57:	repnz insl (%dx),%es:(%edi)
0x00007d57 in ?? ()
=> 0x7d57:	repnz insl (%dx),%es:(%edi)
0x00007d57 in ?? ()
=> 0x7d57:	repnz insl (%dx),%es:(%edi)
0x00007d57 in ?? ()
=> 0x7d57:	repnz insl (%dx),%es:(%edi)
0x00007d57 in ?? ()
=> 0x7d57:	repnz insl (%dx),%es:(%edi)
0x00007d57 in ?? ()
=> 0x7d57:	repnz insl (%dx),%es:(%edi)
0x00007d57 in ?? ()
=> 0x7d57:	repnz insl (%dx),%es:(%edi)
0x00007d57 in ?? ()
=> 0x7d57:	repnz insl (%dx),%es:(%edi)
0x00007d57 in ?? ()
=> 0x7d17:	shr    $0x8,%eax
0x00007d17 in ?? ()
=> 0x7d1a:	mov    $0x1f4,%edx
0x00007d1a in ?? ()
=> 0x7d1f:	out    %al,(%dx)
0x00007d1f in ?? ()
=> 0x7d20:	mov    %ebx,%eax
0x00007d20 in ?? ()
=> 0x7d22:	shr    $0x10,%eax
0x00007d22 in ?? ()
=> 0x7d25:	mov    $0x1f5,%edx
0x00007d25 in ?? ()
=> 0x7d2a:	out    %al,(%dx)
0x00007d2a in ?? ()
=> 0x7d2b:	mov    %ebx,%eax
0x00007d2b in ?? ()
=> 0x7d2d:	shr    $0x18,%eax
0x00007d2d in ?? ()
=> 0x7d30:	or     $0xffffffe0,%eax
0x00007d30 in ?? ()
=> 0x7d33:	mov    $0x1f6,%edx
0x00007d33 in ?? ()
=> 0x7d38:	out    %al,(%dx)
0x00007d38 in ?? ()
=> 0x7d39:	mov    $0x1f7,%edx
0x00007d39 in ?? ()
=> 0x7d3e:	mov    $0x20,%eax
0x00007d3e in ?? ()
=> 0x7d43:	out    %al,(%dx)
0x00007d43 in ?? ()
=> 0x7d44:	call   0x7ce3
0x00007d44 in ?? ()
=> 0x7ce3:	push   %ebp
0x00007ce3 in ?? ()
=> 0x7ce4:	mov    %esp,%ebp
0x00007ce4 in ?? ()
=> 0x7ce6:	mov    $0x1f7,%edx
0x00007ce6 in ?? ()
=> 0x7ceb:	in     (%dx),%al
0x00007ceb in ?? ()
=> 0x7cec:	and    $0xffffffc0,%eax
0x00007cec in ?? ()
=> 0x7cef:	cmp    $0x40,%al
0x00007cef in ?? ()
=> 0x7cf1:	jne    0x7ceb
0x00007cf1 in ?? ()
=> 0x7cf3:	pop    %ebp
0x00007cf3 in ?? ()
=> 0x7cf4:	ret    
0x00007cf4 in ?? ()
=> 0x7d49:	mov    0x8(%ebp),%edi
0x00007d49 in ?? ()
=> 0x7d4c:	mov    $0x80,%ecx
0x00007d4c in ?? ()
=> 0x7d51:	mov    $0x1f0,%edx
0x00007d51 in ?? ()
=> 0x7d56:	cld    
0x00007d56 in ?? ()
=> 0x7d57:	repnz insl (%dx),%es:(%edi)
0x00007d57 in ?? ()
=> 0x7d57:	repnz insl (%dx),%es:(%edi)
0x00007d57 in ?? ()
=> 0x7d57:	repnz insl (%dx),%es:(%edi)
0x00007d57 in ?? ()
=> 0x7d57:	repnz insl (%dx),%es:(%edi)
0x00007d57 in ?? ()
=> 0x7d57:	repnz insl (%dx),%es:(%edi)
0x00007d57 in ?? ()

Program received signal SIGINT, Interrupt.
=> 0x7ce3:	push   %ebp
0x00007ce3 in ?? ()
Undefined command: "ls".  Try "help".
=> 0x7ce4:	mov    %esp,%ebp
0x00007ce4 in ?? ()
=> 0x7ce6:	mov    $0x1f7,%edx
0x00007ce6 in ?? ()
=> 0x7ceb:	in     (%dx),%al
0x00007ceb in ?? ()
=> 0x7cec:	and    $0xffffffc0,%eax
0x00007cec in ?? ()
=> 0x7cef:	cmp    $0x40,%al
0x00007cef in ?? ()
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel bootblock
.gdbinit:28: Error in sourced command file:
`/home/dalegebit/Documents/system_learning/final/bootblock': can't read symbols: File format not recognized.
Detaching from program: , Remote target
Ending remote debugging.

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel bootblock.o
Breakpoint 1 at 0x7c6a: file main.c, line 11.
Continuing.
The target architecture is assumed to be i386
=> 0x7c6a <bootmain>:	push   %ebp

Breakpoint 1, bootmain () at main.c:11
11	{
=> 0x7c6b <bootmain+1>:	mov    %esp,%ebp
0x00007c6b	11	{
=> 0x7c6d <bootmain+3>:	push   %esi
0x00007c6d	11	{
=> 0x7c6e <bootmain+4>:	push   %ebx
0x00007c6e	11	{
=> 0x7c6f <bootmain+5>:	sub    $0x4,%esp
15		readseg((uint32_t) ELFHDR, SECTSIZE*8, 0);
=> 0x7c72 <bootmain+8>:	push   $0x0
0x00007c72	15		readseg((uint32_t) ELFHDR, SECTSIZE*8, 0);
=> 0x7d66 <readseg+9>:	mov    %ebx,%edi
readseg (pa=0x10000, count=0x1000, offset=0x0) at ide.c:12
12		end_pa = pa + count;
=> 0x7d6b <readseg+14>:	and    $0xfffffe00,%ebx
15		pa &= ~(SECTSIZE - 1);
=> 0x7d71 <readseg+20>:	mov    0x10(%ebp),%esi
18		offset = (offset / SECTSIZE) + 1;
=> 0x7d7a <readseg+29>:	cmp    %ebx,%edi
23		while (pa < end_pa) {
=> 0x7d7e <readseg+33>:	push   %esi
28			readsect((uint8_t*) pa, offset);
=> 0x7cfd <readsect+8>:	call   0x7ce3 <waitdisk>
readsect (dst=0x10000, offset=0x1) at ide.c:47
47		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
  [32mEAX:[31m 0x00000010  [32mEBX:[31m 0x00000001  [32mECX:[30m 0x00000000  [32mEDX:[31m 0x00000080  [1m[4m[31mo d i t s z a P c 
[0m  [32mESI:[31m 0x00000001  [32mEDI:[31m 0x00011000  [32mEBP:[31m 0x00007BAC  [32mESP:[31m 0x00007BAC  [32mEIP:[31m 0x00007CE6
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0010  [32mGS:[30m 0010  [32mSS:[30m 0010[0m
  [32mEAX:[30m 0x00000010  [32mEBX:[30m 0x00000001  [32mECX:[30m 0x00000000  [32mEDX:[30m 0x00000080  [1m[4m[31mo d i t s z a P c 
[0m  [32mESI:[30m 0x00000001  [32mEDI:[30m 0x00011000  [32mEBP:[30m 0x00007BAC  [32mESP:[30m 0x00007BAC  [32mEIP:[31m 0x00007CE6
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0010  [32mGS:[30m 0010  [32mSS:[30m 0010[0m
  [32mEAX:[30m 0x00000010  [32mEBX:[30m 0x00000001  [32mECX:[30m 0x00000000  [32mEDX:[30m 0x00000080  [1m[4m[31mo d i t s z a P c 
[0m  [32mESI:[30m 0x00000001  [32mEDI:[30m 0x00011000  [32mEBP:[30m 0x00007BAC  [32mESP:[30m 0x00007BAC  [32mEIP:[31m 0x00007CE6
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0010  [32mGS:[30m 0010  [32mSS:[30m 0010[0m
  [32mEAX:[30m 0x00000010  [32mEBX:[30m 0x00000001  [32mECX:[30m 0x00000000  [32mEDX:[30m 0x00000080  [1m[4m[31mo d i t s z a P c 
[0m  [32mESI:[30m 0x00000001  [32mEDI:[30m 0x00011000  [32mEBP:[30m 0x00007BAC  [32mESP:[30m 0x00007BAC  [32mEIP:[31m 0x00007CE6
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0010  [32mGS:[30m 0010  [32mSS:[30m 0010[0m
  [32mEAX:[30m 0x00000010  [32mEBX:[30m 0x00000001  [32mECX:[30m 0x00000000  [32mEDX:[30m 0x00000080  [1m[4m[31mo d i t s z a P c 
[0m  [32mESI:[30m 0x00000001  [32mEDI:[30m 0x00011000  [32mEBP:[30m 0x00007BAC  [32mESP:[30m 0x00007BAC  [32mEIP:[31m 0x00007CE6
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0010  [32mGS:[30m 0010  [32mSS:[30m 0010[0m
  [32mEAX:[30m 0x00000010  [32mEBX:[30m 0x00000001  [32mECX:[30m 0x00000000  [32mEDX:[30m 0x00000080  [1m[4m[31mo d i t s z a P c 
[0m  [32mESI:[30m 0x00000001  [32mEDI:[30m 0x00011000  [32mEBP:[30m 0x00007BAC  [32mESP:[30m 0x00007BAC  [32mEIP:[31m 0x00007CE6
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0010  [32mGS:[30m 0010  [32mSS:[30m 0010[0m
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
readsect (dst=0x10000, offset=0x1) at ide.c:49
49		outb(0x1F2, 1);		// count = 1
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
outb (data=0x1, port=0x1f2) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0x7d44 <readsect+79>:	call   0x7ce3 <waitdisk>
readsect (dst=0x10000, offset=0x1) at ide.c:57
57		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
readsect (dst=0x10000, offset=0x1) at ide.c:60
60		insl(0x1F0, dst, SECTSIZE/4);
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
insl (cnt=0x80, addr=0x10000, port=0x1f0) at ./x86.h:109
109		__asm __volatile("cld\n\trepne\n\tinsl"			:
=> 0x7d59 <readsect+100>:	pop    %ebx
readsect (dst=0x10000, offset=0x1) at ide.c:61
61	}
=> 0x7d85 <readseg+40>:	add    $0x200,%ebx
readseg (pa=0x10000, count=0x1000, offset=0x1) at ide.c:29
29			pa += SECTSIZE;
=> 0x7d8b <readseg+46>:	add    $0x1,%esi
30			offset++;
=> 0x7d8e <readseg+49>:	add    $0x8,%esp
23		while (pa < end_pa) {
=> 0x7d7e <readseg+33>:	push   %esi
28			readsect((uint8_t*) pa, offset);
=> 0x7cfd <readsect+8>:	call   0x7ce3 <waitdisk>
readsect (dst=0x10200, offset=0x2) at ide.c:47
47		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
readsect (dst=0x10200, offset=0x2) at ide.c:49
49		outb(0x1F2, 1);		// count = 1
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
outb (data=0x1, port=0x1f2) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0x7d44 <readsect+79>:	call   0x7ce3 <waitdisk>
readsect (dst=0x10200, offset=0x2) at ide.c:57
57		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
readsect (dst=0x10200, offset=0x2) at ide.c:60
60		insl(0x1F0, dst, SECTSIZE/4);
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
insl (cnt=0x80, addr=0x10200, port=0x1f0) at ./x86.h:109
109		__asm __volatile("cld\n\trepne\n\tinsl"			:
=> 0x7d59 <readsect+100>:	pop    %ebx
readsect (dst=0x10200, offset=0x2) at ide.c:61
61	}
=> 0x7d85 <readseg+40>:	add    $0x200,%ebx
readseg (pa=0x10200, count=0x1000, offset=0x2) at ide.c:29
29			pa += SECTSIZE;
=> 0x7d8b <readseg+46>:	add    $0x1,%esi
30			offset++;
=> 0x7d8e <readseg+49>:	add    $0x8,%esp
23		while (pa < end_pa) {
=> 0x7d7e <readseg+33>:	push   %esi
28			readsect((uint8_t*) pa, offset);
=> 0x7cfd <readsect+8>:	call   0x7ce3 <waitdisk>
readsect (dst=0x10400, offset=0x3) at ide.c:47
47		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
readsect (dst=0x10400, offset=0x3) at ide.c:49
49		outb(0x1F2, 1);		// count = 1
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
outb (data=0x1, port=0x1f2) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0x7d44 <readsect+79>:	call   0x7ce3 <waitdisk>
readsect (dst=0x10400, offset=0x3) at ide.c:57
57		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
readsect (dst=0x10400, offset=0x3) at ide.c:60
60		insl(0x1F0, dst, SECTSIZE/4);
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
insl (cnt=0x80, addr=0x10400, port=0x1f0) at ./x86.h:109
109		__asm __volatile("cld\n\trepne\n\tinsl"			:
=> 0x7d59 <readsect+100>:	pop    %ebx
readsect (dst=0x10400, offset=0x3) at ide.c:61
61	}
=> 0x7d85 <readseg+40>:	add    $0x200,%ebx
readseg (pa=0x10400, count=0x1000, offset=0x3) at ide.c:29
29			pa += SECTSIZE;
=> 0x7d8b <readseg+46>:	add    $0x1,%esi
30			offset++;
=> 0x7d8e <readseg+49>:	add    $0x8,%esp
23		while (pa < end_pa) {
=> 0x7d7e <readseg+33>:	push   %esi
28			readsect((uint8_t*) pa, offset);
=> 0x7cfd <readsect+8>:	call   0x7ce3 <waitdisk>
readsect (dst=0x10600, offset=0x4) at ide.c:47
47		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
readsect (dst=0x10600, offset=0x4) at ide.c:49
49		outb(0x1F2, 1);		// count = 1
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
outb (data=0x1, port=0x1f2) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0x7d44 <readsect+79>:	call   0x7ce3 <waitdisk>
readsect (dst=0x10600, offset=0x4) at ide.c:57
57		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
readsect (dst=0x10600, offset=0x4) at ide.c:60
60		insl(0x1F0, dst, SECTSIZE/4);
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
insl (cnt=0x80, addr=0x10600, port=0x1f0) at ./x86.h:109
109		__asm __volatile("cld\n\trepne\n\tinsl"			:
=> 0x7d59 <readsect+100>:	pop    %ebx
readsect (dst=0x10600, offset=0x4) at ide.c:61
61	}
=> 0x7d85 <readseg+40>:	add    $0x200,%ebx
readseg (pa=0x10600, count=0x1000, offset=0x4) at ide.c:29
29			pa += SECTSIZE;
=> 0x7d8b <readseg+46>:	add    $0x1,%esi
30			offset++;
=> 0x7d8e <readseg+49>:	add    $0x8,%esp
23		while (pa < end_pa) {
=> 0x7d7e <readseg+33>:	push   %esi
28			readsect((uint8_t*) pa, offset);
=> 0x7cfd <readsect+8>:	call   0x7ce3 <waitdisk>
readsect (dst=0x10800, offset=0x5) at ide.c:47
47		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
readsect (dst=0x10800, offset=0x5) at ide.c:49
49		outb(0x1F2, 1);		// count = 1
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
outb (data=0x1, port=0x1f2) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0x7d44 <readsect+79>:	call   0x7ce3 <waitdisk>
readsect (dst=0x10800, offset=0x5) at ide.c:57
57		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
readsect (dst=0x10800, offset=0x5) at ide.c:60
60		insl(0x1F0, dst, SECTSIZE/4);
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
insl (cnt=0x80, addr=0x10800, port=0x1f0) at ./x86.h:109
109		__asm __volatile("cld\n\trepne\n\tinsl"			:
=> 0x7d59 <readsect+100>:	pop    %ebx
readsect (dst=0x10800, offset=0x5) at ide.c:61
61	}
=> 0x7d85 <readseg+40>:	add    $0x200,%ebx
readseg (pa=0x10800, count=0x1000, offset=0x5) at ide.c:29
29			pa += SECTSIZE;
=> 0x7d8b <readseg+46>:	add    $0x1,%esi
30			offset++;
=> 0x7d8e <readseg+49>:	add    $0x8,%esp
23		while (pa < end_pa) {
=> 0x7d7e <readseg+33>:	push   %esi
28			readsect((uint8_t*) pa, offset);
=> 0x7cfd <readsect+8>:	call   0x7ce3 <waitdisk>
readsect (dst=0x10a00, offset=0x6) at ide.c:47
47		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
readsect (dst=0x10a00, offset=0x6) at ide.c:49
49		outb(0x1F2, 1);		// count = 1
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
outb (data=0x1, port=0x1f2) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0x7d44 <readsect+79>:	call   0x7ce3 <waitdisk>
readsect (dst=0x10a00, offset=0x6) at ide.c:57
57		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
readsect (dst=0x10a00, offset=0x6) at ide.c:60
60		insl(0x1F0, dst, SECTSIZE/4);
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
insl (cnt=0x80, addr=0x10a00, port=0x1f0) at ./x86.h:109
109		__asm __volatile("cld\n\trepne\n\tinsl"			:
=> 0x7d59 <readsect+100>:	pop    %ebx
readsect (dst=0x10a00, offset=0x6) at ide.c:61
61	}
=> 0x7d85 <readseg+40>:	add    $0x200,%ebx
readseg (pa=0x10a00, count=0x1000, offset=0x6) at ide.c:29
29			pa += SECTSIZE;
=> 0x7d8b <readseg+46>:	add    $0x1,%esi
30			offset++;
=> 0x7d8e <readseg+49>:	add    $0x8,%esp
23		while (pa < end_pa) {
=> 0x7d7e <readseg+33>:	push   %esi
28			readsect((uint8_t*) pa, offset);
=> 0x7cfd <readsect+8>:	call   0x7ce3 <waitdisk>
readsect (dst=0x10c00, offset=0x7) at ide.c:47
47		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
readsect (dst=0x10c00, offset=0x7) at ide.c:49
49		outb(0x1F2, 1);		// count = 1
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
outb (data=0x1, port=0x1f2) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0x7d44 <readsect+79>:	call   0x7ce3 <waitdisk>
readsect (dst=0x10c00, offset=0x7) at ide.c:57
57		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
readsect (dst=0x10c00, offset=0x7) at ide.c:60
60		insl(0x1F0, dst, SECTSIZE/4);
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
insl (cnt=0x80, addr=0x10c00, port=0x1f0) at ./x86.h:109
109		__asm __volatile("cld\n\trepne\n\tinsl"			:
=> 0x7d59 <readsect+100>:	pop    %ebx
readsect (dst=0x10c00, offset=0x7) at ide.c:61
61	}
=> 0x7d85 <readseg+40>:	add    $0x200,%ebx
readseg (pa=0x10c00, count=0x1000, offset=0x7) at ide.c:29
29			pa += SECTSIZE;
=> 0x7d8b <readseg+46>:	add    $0x1,%esi
30			offset++;
=> 0x7d8e <readseg+49>:	add    $0x8,%esp
23		while (pa < end_pa) {
=> 0x7d7e <readseg+33>:	push   %esi
28			readsect((uint8_t*) pa, offset);
=> 0x7cfd <readsect+8>:	call   0x7ce3 <waitdisk>
readsect (dst=0x10e00, offset=0x8) at ide.c:47
47		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
readsect (dst=0x10e00, offset=0x8) at ide.c:49
49		outb(0x1F2, 1);		// count = 1
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
outb (data=0x1, port=0x1f2) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0x7d44 <readsect+79>:	call   0x7ce3 <waitdisk>
readsect (dst=0x10e00, offset=0x8) at ide.c:57
57		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
readsect (dst=0x10e00, offset=0x8) at ide.c:60
60		insl(0x1F0, dst, SECTSIZE/4);
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
insl (cnt=0x80, addr=0x10e00, port=0x1f0) at ./x86.h:109
109		__asm __volatile("cld\n\trepne\n\tinsl"			:
=> 0x7d59 <readsect+100>:	pop    %ebx
readsect (dst=0x10e00, offset=0x8) at ide.c:61
61	}
=> 0x7d85 <readseg+40>:	add    $0x200,%ebx
readseg (pa=0x10e00, count=0x1000, offset=0x8) at ide.c:29
29			pa += SECTSIZE;
=> 0x7d8b <readseg+46>:	add    $0x1,%esi
30			offset++;
=> 0x7d8e <readseg+49>:	add    $0x8,%esp
23		while (pa < end_pa) {
=> 0x7d95 <readseg+56>:	lea    -0xc(%ebp),%esp
32	}
=> 0x7c83 <bootmain+25>:	add    $0x10,%esp
bootmain () at main.c:18
18		if (ELFHDR->e_magic != ELF_MAGIC)
=> 0x7c92 <bootmain+40>:	mov    0x1001c,%eax
22		ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR->e_phoff);
=> 0x7c9d <bootmain+51>:	movzwl 0x1002c,%esi
23		eph = ph + ELFHDR->e_phnum;
=> 0x7ca9 <bootmain+63>:	cmp    %esi,%ebx
24		for (; ph < eph; ph++)
=> 0x7cad <bootmain+67>:	sub    $0x4,%esp
27			readseg(ph->p_pa, ph->p_memsz, ph->p_offset);
=> 0x7d66 <readseg+9>:	mov    %ebx,%edi
readseg (pa=0x100000, count=0x497e, offset=0x1000) at ide.c:12
12		end_pa = pa + count;
=> 0x7d6b <readseg+14>:	and    $0xfffffe00,%ebx
15		pa &= ~(SECTSIZE - 1);
=> 0x7d71 <readseg+20>:	mov    0x10(%ebp),%esi
18		offset = (offset / SECTSIZE) + 1;
=> 0x7d7a <readseg+29>:	cmp    %ebx,%edi
23		while (pa < end_pa) {
=> 0x7d7e <readseg+33>:	push   %esi
28			readsect((uint8_t*) pa, offset);
=> 0x7cfd <readsect+8>:	call   0x7ce3 <waitdisk>
readsect (dst=0x100000, offset=0x9) at ide.c:47
47		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
readsect (dst=0x100000, offset=0x9) at ide.c:49
49		outb(0x1F2, 1);		// count = 1
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
outb (data=0x1, port=0x1f2) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0x7d44 <readsect+79>:	call   0x7ce3 <waitdisk>
readsect (dst=0x100000, offset=0x9) at ide.c:57
57		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
readsect (dst=0x100000, offset=0x9) at ide.c:60
60		insl(0x1F0, dst, SECTSIZE/4);
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
insl (cnt=0x80, addr=0x100000, port=0x1f0) at ./x86.h:109
109		__asm __volatile("cld\n\trepne\n\tinsl"			:
=> 0x7d59 <readsect+100>:	pop    %ebx
readsect (dst=0x100000, offset=0x9) at ide.c:61
61	}
=> 0x7d85 <readseg+40>:	add    $0x200,%ebx
readseg (pa=0x100000, count=0x497e, offset=0x9) at ide.c:29
29			pa += SECTSIZE;
=> 0x7d8b <readseg+46>:	add    $0x1,%esi
30			offset++;
=> 0x7d8e <readseg+49>:	add    $0x8,%esp
23		while (pa < end_pa) {
=> 0x7d7e <readseg+33>:	push   %esi
28			readsect((uint8_t*) pa, offset);
=> 0x7cfd <readsect+8>:	call   0x7ce3 <waitdisk>
readsect (dst=0x100200, offset=0xa) at ide.c:47
47		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
readsect (dst=0x100200, offset=0xa) at ide.c:49
49		outb(0x1F2, 1);		// count = 1
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
outb (data=0x1, port=0x1f2) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0x7d44 <readsect+79>:	call   0x7ce3 <waitdisk>
readsect (dst=0x100200, offset=0xa) at ide.c:57
57		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
readsect (dst=0x100200, offset=0xa) at ide.c:60
60		insl(0x1F0, dst, SECTSIZE/4);
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
insl (cnt=0x80, addr=0x100200, port=0x1f0) at ./x86.h:109
109		__asm __volatile("cld\n\trepne\n\tinsl"			:
=> 0x7d59 <readsect+100>:	pop    %ebx
readsect (dst=0x100200, offset=0xa) at ide.c:61
61	}
=> 0x7d85 <readseg+40>:	add    $0x200,%ebx
readseg (pa=0x100200, count=0x497e, offset=0xa) at ide.c:29
29			pa += SECTSIZE;
=> 0x7d8b <readseg+46>:	add    $0x1,%esi
30			offset++;
=> 0x7d8e <readseg+49>:	add    $0x8,%esp
23		while (pa < end_pa) {
=> 0x7d7e <readseg+33>:	push   %esi
28			readsect((uint8_t*) pa, offset);
=> 0x7cfd <readsect+8>:	call   0x7ce3 <waitdisk>
readsect (dst=0x100400, offset=0xb) at ide.c:47
47		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
readsect (dst=0x100400, offset=0xb) at ide.c:49
49		outb(0x1F2, 1);		// count = 1
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
outb (data=0x1, port=0x1f2) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0x7d44 <readsect+79>:	call   0x7ce3 <waitdisk>
readsect (dst=0x100400, offset=0xb) at ide.c:57
57		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
readsect (dst=0x100400, offset=0xb) at ide.c:60
60		insl(0x1F0, dst, SECTSIZE/4);
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
insl (cnt=0x80, addr=0x100400, port=0x1f0) at ./x86.h:109
109		__asm __volatile("cld\n\trepne\n\tinsl"			:
=> 0x7d59 <readsect+100>:	pop    %ebx
readsect (dst=0x100400, offset=0xb) at ide.c:61
61	}
=> 0x7d85 <readseg+40>:	add    $0x200,%ebx
readseg (pa=0x100400, count=0x497e, offset=0xb) at ide.c:29
29			pa += SECTSIZE;
=> 0x7d8b <readseg+46>:	add    $0x1,%esi
30			offset++;
=> 0x7d8e <readseg+49>:	add    $0x8,%esp
23		while (pa < end_pa) {
=> 0x7d7e <readseg+33>:	push   %esi
28			readsect((uint8_t*) pa, offset);
=> 0x7cfd <readsect+8>:	call   0x7ce3 <waitdisk>
readsect (dst=0x100600, offset=0xc) at ide.c:47
47		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
readsect (dst=0x100600, offset=0xc) at ide.c:49
49		outb(0x1F2, 1);		// count = 1
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
outb (data=0x1, port=0x1f2) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0x7d44 <readsect+79>:	call   0x7ce3 <waitdisk>
readsect (dst=0x100600, offset=0xc) at ide.c:57
57		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
readsect (dst=0x100600, offset=0xc) at ide.c:60
60		insl(0x1F0, dst, SECTSIZE/4);
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
insl (cnt=0x80, addr=0x100600, port=0x1f0) at ./x86.h:109
109		__asm __volatile("cld\n\trepne\n\tinsl"			:
=> 0x7d59 <readsect+100>:	pop    %ebx
readsect (dst=0x100600, offset=0xc) at ide.c:61
61	}
=> 0x7d85 <readseg+40>:	add    $0x200,%ebx
readseg (pa=0x100600, count=0x497e, offset=0xc) at ide.c:29
29			pa += SECTSIZE;
=> 0x7d8b <readseg+46>:	add    $0x1,%esi
30			offset++;
=> 0x7d8e <readseg+49>:	add    $0x8,%esp
23		while (pa < end_pa) {
=> 0x7d7e <readseg+33>:	push   %esi
28			readsect((uint8_t*) pa, offset);
=> 0x7cfd <readsect+8>:	call   0x7ce3 <waitdisk>
readsect (dst=0x100800, offset=0xd) at ide.c:47
47		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
readsect (dst=0x100800, offset=0xd) at ide.c:49
49		outb(0x1F2, 1);		// count = 1
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
outb (data=0x1, port=0x1f2) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0x7d44 <readsect+79>:	call   0x7ce3 <waitdisk>
readsect (dst=0x100800, offset=0xd) at ide.c:57
57		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
readsect (dst=0x100800, offset=0xd) at ide.c:60
60		insl(0x1F0, dst, SECTSIZE/4);
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
insl (cnt=0x80, addr=0x100800, port=0x1f0) at ./x86.h:109
109		__asm __volatile("cld\n\trepne\n\tinsl"			:
=> 0x7d59 <readsect+100>:	pop    %ebx
readsect (dst=0x100800, offset=0xd) at ide.c:61
61	}
=> 0x7d85 <readseg+40>:	add    $0x200,%ebx
readseg (pa=0x100800, count=0x497e, offset=0xd) at ide.c:29
29			pa += SECTSIZE;
=> 0x7d8b <readseg+46>:	add    $0x1,%esi
30			offset++;
=> 0x7d8e <readseg+49>:	add    $0x8,%esp
23		while (pa < end_pa) {
=> 0x7d7e <readseg+33>:	push   %esi
28			readsect((uint8_t*) pa, offset);
=> 0x7cfd <readsect+8>:	call   0x7ce3 <waitdisk>
readsect (dst=0x100a00, offset=0xe) at ide.c:47
47		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
readsect (dst=0x100a00, offset=0xe) at ide.c:49
49		outb(0x1F2, 1);		// count = 1
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
outb (data=0x1, port=0x1f2) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0x7d44 <readsect+79>:	call   0x7ce3 <waitdisk>
readsect (dst=0x100a00, offset=0xe) at ide.c:57
57		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
readsect (dst=0x100a00, offset=0xe) at ide.c:60
60		insl(0x1F0, dst, SECTSIZE/4);
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
insl (cnt=0x80, addr=0x100a00, port=0x1f0) at ./x86.h:109
109		__asm __volatile("cld\n\trepne\n\tinsl"			:
=> 0x7d59 <readsect+100>:	pop    %ebx
readsect (dst=0x100a00, offset=0xe) at ide.c:61
61	}
=> 0x7d85 <readseg+40>:	add    $0x200,%ebx
readseg (pa=0x100a00, count=0x497e, offset=0xe) at ide.c:29
29			pa += SECTSIZE;
=> 0x7d8b <readseg+46>:	add    $0x1,%esi
30			offset++;
=> 0x7d8e <readseg+49>:	add    $0x8,%esp
23		while (pa < end_pa) {
=> 0x7d7e <readseg+33>:	push   %esi
28			readsect((uint8_t*) pa, offset);
=> 0x7cfd <readsect+8>:	call   0x7ce3 <waitdisk>
readsect (dst=0x100c00, offset=0xf) at ide.c:47
47		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
readsect (dst=0x100c00, offset=0xf) at ide.c:49
49		outb(0x1F2, 1);		// count = 1
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
outb (data=0x1, port=0x1f2) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0x7d44 <readsect+79>:	call   0x7ce3 <waitdisk>
readsect (dst=0x100c00, offset=0xf) at ide.c:57
57		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
readsect (dst=0x100c00, offset=0xf) at ide.c:60
60		insl(0x1F0, dst, SECTSIZE/4);
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
insl (cnt=0x80, addr=0x100c00, port=0x1f0) at ./x86.h:109
109		__asm __volatile("cld\n\trepne\n\tinsl"			:
=> 0x7d59 <readsect+100>:	pop    %ebx
readsect (dst=0x100c00, offset=0xf) at ide.c:61
61	}
=> 0x7d85 <readseg+40>:	add    $0x200,%ebx
readseg (pa=0x100c00, count=0x497e, offset=0xf) at ide.c:29
29			pa += SECTSIZE;
=> 0x7d8b <readseg+46>:	add    $0x1,%esi
30			offset++;
=> 0x7d8e <readseg+49>:	add    $0x8,%esp
23		while (pa < end_pa) {
=> 0x7d7e <readseg+33>:	push   %esi
28			readsect((uint8_t*) pa, offset);
=> 0x7cfd <readsect+8>:	call   0x7ce3 <waitdisk>
readsect (dst=0x100e00, offset=0x10) at ide.c:47
47		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
readsect (dst=0x100e00, offset=0x10) at ide.c:49
49		outb(0x1F2, 1);		// count = 1
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
outb (data=0x1, port=0x1f2) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0x7d44 <readsect+79>:	call   0x7ce3 <waitdisk>
readsect (dst=0x100e00, offset=0x10) at ide.c:57
57		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
readsect (dst=0x100e00, offset=0x10) at ide.c:60
60		insl(0x1F0, dst, SECTSIZE/4);
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
insl (cnt=0x80, addr=0x100e00, port=0x1f0) at ./x86.h:109
109		__asm __volatile("cld\n\trepne\n\tinsl"			:
=> 0x7d59 <readsect+100>:	pop    %ebx
readsect (dst=0x100e00, offset=0x10) at ide.c:61
61	}
=> 0x7d85 <readseg+40>:	add    $0x200,%ebx
readseg (pa=0x100e00, count=0x497e, offset=0x10) at ide.c:29
29			pa += SECTSIZE;
=> 0x7d8b <readseg+46>:	add    $0x1,%esi
30			offset++;
=> 0x7d8e <readseg+49>:	add    $0x8,%esp
23		while (pa < end_pa) {
=> 0x7d7e <readseg+33>:	push   %esi
28			readsect((uint8_t*) pa, offset);
=> 0x7cfd <readsect+8>:	call   0x7ce3 <waitdisk>
readsect (dst=0x101000, offset=0x11) at ide.c:47
47		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
readsect (dst=0x101000, offset=0x11) at ide.c:49
49		outb(0x1F2, 1);		// count = 1
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
outb (data=0x1, port=0x1f2) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0x7d44 <readsect+79>:	call   0x7ce3 <waitdisk>
readsect (dst=0x101000, offset=0x11) at ide.c:57
57		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
readsect (dst=0x101000, offset=0x11) at ide.c:60
60		insl(0x1F0, dst, SECTSIZE/4);
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
insl (cnt=0x80, addr=0x101000, port=0x1f0) at ./x86.h:109
109		__asm __volatile("cld\n\trepne\n\tinsl"			:
=> 0x7d59 <readsect+100>:	pop    %ebx
readsect (dst=0x101000, offset=0x11) at ide.c:61
61	}
=> 0x7d85 <readseg+40>:	add    $0x200,%ebx
readseg (pa=0x101000, count=0x497e, offset=0x11) at ide.c:29
29			pa += SECTSIZE;
=> 0x7d8b <readseg+46>:	add    $0x1,%esi
30			offset++;
=> 0x7d8e <readseg+49>:	add    $0x8,%esp
23		while (pa < end_pa) {
=> 0x7d7e <readseg+33>:	push   %esi
28			readsect((uint8_t*) pa, offset);
=> 0x7cfd <readsect+8>:	call   0x7ce3 <waitdisk>
readsect (dst=0x101200, offset=0x12) at ide.c:47
47		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
readsect (dst=0x101200, offset=0x12) at ide.c:49
49		outb(0x1F2, 1);		// count = 1
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
outb (data=0x1, port=0x1f2) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0x7d44 <readsect+79>:	call   0x7ce3 <waitdisk>
readsect (dst=0x101200, offset=0x12) at ide.c:57
57		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
readsect (dst=0x101200, offset=0x12) at ide.c:60
60		insl(0x1F0, dst, SECTSIZE/4);
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
insl (cnt=0x80, addr=0x101200, port=0x1f0) at ./x86.h:109
109		__asm __volatile("cld\n\trepne\n\tinsl"			:
=> 0x7d59 <readsect+100>:	pop    %ebx
readsect (dst=0x101200, offset=0x12) at ide.c:61
61	}
=> 0x7d85 <readseg+40>:	add    $0x200,%ebx
readseg (pa=0x101200, count=0x497e, offset=0x12) at ide.c:29
29			pa += SECTSIZE;
=> 0x7d8b <readseg+46>:	add    $0x1,%esi
30			offset++;
=> 0x7d8e <readseg+49>:	add    $0x8,%esp
23		while (pa < end_pa) {
=> 0x7d7e <readseg+33>:	push   %esi
28			readsect((uint8_t*) pa, offset);
=> 0x7cfd <readsect+8>:	call   0x7ce3 <waitdisk>
readsect (dst=0x101400, offset=0x13) at ide.c:47
47		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
readsect (dst=0x101400, offset=0x13) at ide.c:49
49		outb(0x1F2, 1);		// count = 1
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
outb (data=0x1, port=0x1f2) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0x7d44 <readsect+79>:	call   0x7ce3 <waitdisk>
readsect (dst=0x101400, offset=0x13) at ide.c:57
57		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
readsect (dst=0x101400, offset=0x13) at ide.c:60
60		insl(0x1F0, dst, SECTSIZE/4);
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
insl (cnt=0x80, addr=0x101400, port=0x1f0) at ./x86.h:109
109		__asm __volatile("cld\n\trepne\n\tinsl"			:
=> 0x7d59 <readsect+100>:	pop    %ebx
readsect (dst=0x101400, offset=0x13) at ide.c:61
61	}
=> 0x7d85 <readseg+40>:	add    $0x200,%ebx
readseg (pa=0x101400, count=0x497e, offset=0x13) at ide.c:29
29			pa += SECTSIZE;
=> 0x7d8b <readseg+46>:	add    $0x1,%esi
30			offset++;
=> 0x7d8e <readseg+49>:	add    $0x8,%esp
23		while (pa < end_pa) {
=> 0x7d7e <readseg+33>:	push   %esi
28			readsect((uint8_t*) pa, offset);
=> 0x7cfd <readsect+8>:	call   0x7ce3 <waitdisk>
readsect (dst=0x101600, offset=0x14) at ide.c:47
47		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
readsect (dst=0x101600, offset=0x14) at ide.c:49
49		outb(0x1F2, 1);		// count = 1
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
outb (data=0x1, port=0x1f2) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0x7d44 <readsect+79>:	call   0x7ce3 <waitdisk>
readsect (dst=0x101600, offset=0x14) at ide.c:57
57		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
readsect (dst=0x101600, offset=0x14) at ide.c:60
60		insl(0x1F0, dst, SECTSIZE/4);
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
insl (cnt=0x80, addr=0x101600, port=0x1f0) at ./x86.h:109
109		__asm __volatile("cld\n\trepne\n\tinsl"			:
=> 0x7d59 <readsect+100>:	pop    %ebx
readsect (dst=0x101600, offset=0x14) at ide.c:61
61	}
=> 0x7d85 <readseg+40>:	add    $0x200,%ebx
readseg (pa=0x101600, count=0x497e, offset=0x14) at ide.c:29
29			pa += SECTSIZE;
=> 0x7d8b <readseg+46>:	add    $0x1,%esi
30			offset++;
=> 0x7d8e <readseg+49>:	add    $0x8,%esp
23		while (pa < end_pa) {
=> 0x7d7e <readseg+33>:	push   %esi
28			readsect((uint8_t*) pa, offset);
=> 0x7cfd <readsect+8>:	call   0x7ce3 <waitdisk>
readsect (dst=0x101800, offset=0x15) at ide.c:47
47		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
readsect (dst=0x101800, offset=0x15) at ide.c:49
49		outb(0x1F2, 1);		// count = 1
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
outb (data=0x1, port=0x1f2) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0x7d44 <readsect+79>:	call   0x7ce3 <waitdisk>
readsect (dst=0x101800, offset=0x15) at ide.c:57
57		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
readsect (dst=0x101800, offset=0x15) at ide.c:60
60		insl(0x1F0, dst, SECTSIZE/4);
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
insl (cnt=0x80, addr=0x101800, port=0x1f0) at ./x86.h:109
109		__asm __volatile("cld\n\trepne\n\tinsl"			:
=> 0x7d59 <readsect+100>:	pop    %ebx
readsect (dst=0x101800, offset=0x15) at ide.c:61
61	}
=> 0x7d85 <readseg+40>:	add    $0x200,%ebx
readseg (pa=0x101800, count=0x497e, offset=0x15) at ide.c:29
29			pa += SECTSIZE;
=> 0x7d8b <readseg+46>:	add    $0x1,%esi
30			offset++;
=> 0x7d8e <readseg+49>:	add    $0x8,%esp
23		while (pa < end_pa) {
=> 0x7d7e <readseg+33>:	push   %esi
28			readsect((uint8_t*) pa, offset);
=> 0x7cfd <readsect+8>:	call   0x7ce3 <waitdisk>
readsect (dst=0x101a00, offset=0x16) at ide.c:47
47		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
readsect (dst=0x101a00, offset=0x16) at ide.c:49
49		outb(0x1F2, 1);		// count = 1
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
outb (data=0x1, port=0x1f2) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0x7d44 <readsect+79>:	call   0x7ce3 <waitdisk>
readsect (dst=0x101a00, offset=0x16) at ide.c:57
57		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
readsect (dst=0x101a00, offset=0x16) at ide.c:60
60		insl(0x1F0, dst, SECTSIZE/4);
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
insl (cnt=0x80, addr=0x101a00, port=0x1f0) at ./x86.h:109
109		__asm __volatile("cld\n\trepne\n\tinsl"			:
=> 0x7d59 <readsect+100>:	pop    %ebx
readsect (dst=0x101a00, offset=0x16) at ide.c:61
61	}
=> 0x7d85 <readseg+40>:	add    $0x200,%ebx
readseg (pa=0x101a00, count=0x497e, offset=0x16) at ide.c:29
29			pa += SECTSIZE;
=> 0x7d8b <readseg+46>:	add    $0x1,%esi
30			offset++;
=> 0x7d8e <readseg+49>:	add    $0x8,%esp
23		while (pa < end_pa) {
=> 0x7d7e <readseg+33>:	push   %esi
28			readsect((uint8_t*) pa, offset);
=> 0x7cfd <readsect+8>:	call   0x7ce3 <waitdisk>
readsect (dst=0x101c00, offset=0x17) at ide.c:47
47		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
readsect (dst=0x101c00, offset=0x17) at ide.c:49
49		outb(0x1F2, 1);		// count = 1
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
outb (data=0x1, port=0x1f2) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0x7d44 <readsect+79>:	call   0x7ce3 <waitdisk>
readsect (dst=0x101c00, offset=0x17) at ide.c:57
57		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
readsect (dst=0x101c00, offset=0x17) at ide.c:60
60		insl(0x1F0, dst, SECTSIZE/4);
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
insl (cnt=0x80, addr=0x101c00, port=0x1f0) at ./x86.h:109
109		__asm __volatile("cld\n\trepne\n\tinsl"			:
=> 0x7d59 <readsect+100>:	pop    %ebx
readsect (dst=0x101c00, offset=0x17) at ide.c:61
61	}
=> 0x7d85 <readseg+40>:	add    $0x200,%ebx
readseg (pa=0x101c00, count=0x497e, offset=0x17) at ide.c:29
29			pa += SECTSIZE;
=> 0x7d8b <readseg+46>:	add    $0x1,%esi
30			offset++;
=> 0x7d8e <readseg+49>:	add    $0x8,%esp
23		while (pa < end_pa) {
=> 0x7d7e <readseg+33>:	push   %esi
28			readsect((uint8_t*) pa, offset);
=> 0x7cfd <readsect+8>:	call   0x7ce3 <waitdisk>
readsect (dst=0x101e00, offset=0x18) at ide.c:47
47		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
readsect (dst=0x101e00, offset=0x18) at ide.c:49
49		outb(0x1F2, 1);		// count = 1
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
outb (data=0x1, port=0x1f2) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0x7d44 <readsect+79>:	call   0x7ce3 <waitdisk>
readsect (dst=0x101e00, offset=0x18) at ide.c:57
57		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
readsect (dst=0x101e00, offset=0x18) at ide.c:60
60		insl(0x1F0, dst, SECTSIZE/4);
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
insl (cnt=0x80, addr=0x101e00, port=0x1f0) at ./x86.h:109
109		__asm __volatile("cld\n\trepne\n\tinsl"			:
=> 0x7d59 <readsect+100>:	pop    %ebx
readsect (dst=0x101e00, offset=0x18) at ide.c:61
61	}
=> 0x7d85 <readseg+40>:	add    $0x200,%ebx
readseg (pa=0x101e00, count=0x497e, offset=0x18) at ide.c:29
29			pa += SECTSIZE;
=> 0x7d8b <readseg+46>:	add    $0x1,%esi
30			offset++;
=> 0x7d8e <readseg+49>:	add    $0x8,%esp
23		while (pa < end_pa) {
=> 0x7d7e <readseg+33>:	push   %esi
28			readsect((uint8_t*) pa, offset);
=> 0x7cfd <readsect+8>:	call   0x7ce3 <waitdisk>
readsect (dst=0x102000, offset=0x19) at ide.c:47
47		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
readsect (dst=0x102000, offset=0x19) at ide.c:49
49		outb(0x1F2, 1);		// count = 1
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
outb (data=0x1, port=0x1f2) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0x7d44 <readsect+79>:	call   0x7ce3 <waitdisk>
readsect (dst=0x102000, offset=0x19) at ide.c:57
57		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
readsect (dst=0x102000, offset=0x19) at ide.c:60
60		insl(0x1F0, dst, SECTSIZE/4);
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
insl (cnt=0x80, addr=0x102000, port=0x1f0) at ./x86.h:109
109		__asm __volatile("cld\n\trepne\n\tinsl"			:
=> 0x7d59 <readsect+100>:	pop    %ebx
readsect (dst=0x102000, offset=0x19) at ide.c:61
61	}
=> 0x7d85 <readseg+40>:	add    $0x200,%ebx
readseg (pa=0x102000, count=0x497e, offset=0x19) at ide.c:29
29			pa += SECTSIZE;
=> 0x7d8b <readseg+46>:	add    $0x1,%esi
30			offset++;
=> 0x7d8e <readseg+49>:	add    $0x8,%esp
23		while (pa < end_pa) {
=> 0x7d7e <readseg+33>:	push   %esi
28			readsect((uint8_t*) pa, offset);
=> 0x7cfd <readsect+8>:	call   0x7ce3 <waitdisk>
readsect (dst=0x102200, offset=0x1a) at ide.c:47
47		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
readsect (dst=0x102200, offset=0x1a) at ide.c:49
49		outb(0x1F2, 1);		// count = 1
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
outb (data=0x1, port=0x1f2) at ./x86.h:118
118		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0x7d44 <readsect+79>:	call   0x7ce3 <waitdisk>
readsect (dst=0x102200, offset=0x1a) at ide.c:57
57		waitdisk();
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7ce6 <waitdisk+3>:	mov    $0x1f7,%edx
inb (port=<optimized out>) at ./x86.h:68
68		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7cf3 <waitdisk+16>:	pop    %ebp
40	}
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
readsect (dst=0x102200, offset=0x1a) at ide.c:60
60		insl(0x1F0, dst, SECTSIZE/4);
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
insl (cnt=0x80, addr=0x102200, port=0x1f0) at ./x86.h:109
109		__asm __volatile("cld\n\trepne\n\tinsl"			:
=> 0x7d59 <readsect+100>:	pop    %ebx
readsect (dst=0x102200, offset=0x1a) at ide.c:61
61	}
=> 0x7d85 <readseg+40>:	add    $0x200,%ebx
readseg (pa=0x102200, count=0x497e, offset=0x1a) at ide.c:29
29			pa += SECTSIZE;
=> 0x7d8b <readseg+46>:	add    $0x1,%esi
30			offset++;
=> 0x7d49 <readsect+84>:	mov    0x8(%ebp),%edi
insl (cnt=0x80, addr=0x102400, port=0x1f0) at ./x86.h:109
109		__asm __volatile("cld\n\trepne\n\tinsl"			:
=> 0x7cec <waitdisk+9>:	and    $0xffffffc0,%eax
waitdisk () at ide.c:38
38		while ((inb(0x1F7) & 0xC0) != 0x40)
=> 0x7d02 <readsect+13>:	mov    $0x1f2,%edx
readsect (dst=0x106000, offset=0x39) at ide.c:49
49		outb(0x1F2, 1);		// count = 1
=> 0x7d59 <readsect+100>:	pop    %ebx
readsect (dst=0x107a00, offset=0x46) at ide.c:61
61	}
Function "entry" not defined.
=> 0x7d5a <readsect+101>:	pop    %edi
0x00007d5a	61	}
=> 0x7d5b <readsect+102>:	pop    %ebp
0x00007d5b	61	}
=> 0x7d5c <readsect+103>:	ret    
0x00007d5c	61	}
=> 0x7d85 <readseg+40>:	add    $0x200,%ebx
readseg (pa=0x107a00, count=0xb46c, offset=0x46) at ide.c:29
29			pa += SECTSIZE;
Function "shitA" not defined.
Detaching from program: , Remote target
Ending remote debugging.

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Breakpoint 1 at 0xf0100c3a: file pmap.c, line 109.
Continuing.
The target architecture is assumed to be i386
=> 0xf0100c3a <mem_init>:	push   %ebp

Breakpoint 1, mem_init () at pmap.c:109
109	{
  [32mEAX:[31m 0x00000300  [32mEBX:[31m 0x00010094  [32mECX:[30m 0x00000000  [32mEDX:[31m 0x000003F8  [1m[4m[31mo d i t s z A p C 
[0m  [32mESI:[31m 0x00010094  [32mEDI:[30m 0x00000000  [32mEBP:[31m 0xF010CFF8  [32mESP:[31m 0xF010CFEC  [32mEIP:[31m 0xF0100C3A
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0010  [32mGS:[30m 0010  [32mSS:[30m 0010[0m
Breakpoint 2 at 0xf010286a: file picirq.c, line 15.
Continuing.
=> 0xf010286a <pic_init+6>:	movb   $0x1,0xf011044c

Breakpoint 2, pic_init () at picirq.c:15
15		didinit = 1;
  [32mEAX:[31m 0xF010F52C  [32mEBX:[30m 0x00010094  [32mECX:[30m 0x00000000  [32mEDX:[31m 0xF0118000  [1m[4m[31mo d i t S z a P c 
[0m  [32mESI:[30m 0x00010094  [32mEDI:[30m 0x00000000  [32mEBP:[31m 0xF010CFE8  [32mESP:[31m 0xF010CF90  [32mEIP:[31m 0xF010286A
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0023  [32mGS:[30m 0023  [32mSS:[30m 0010[0m
No symbol "env" in current context.
$1 = (struct Env *) 0xf0118000
Breakpoint 3 at 0xf01026c6: file sched.c, line 29.
Continuing.
=> 0xf01026c6 <sched_yield+6>:	mov    0xf0110454,%eax

Breakpoint 3, sched_yield () at sched.c:29
29		if(curenv)
  [32mEAX:[31m 0x00000000  [32mEBX:[30m 0x00010094  [32mECX:[31m 0x0000001B  [32mEDX:[31m 0xF01046C9  [1m[4m[31mo d i t S z a p c 
[0m  [32mESI:[30m 0x00010094  [32mEDI:[30m 0x00000000  [32mEBP:[30m 0xF010CFE8  [32mESP:[31m 0xF010CFD0  [32mEIP:[31m 0xF01026C6
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0023  [32mGS:[30m 0023  [32mSS:[30m 0010[0m
Breakpoint 4 at 0xf0103393: file env.c, line 585.
Continuing.
=> 0xf0103393 <env_run+6>:	mov    0xf0110454,%eax

Breakpoint 4, env_run (e=0xf0118000) at env.c:585
585		if (curenv != e)
  [32mEAX:[31m 0xF0118000  [32mEBX:[30m 0x00010094  [32mECX:[31m 0x00000000  [32mEDX:[31m 0xF0118000  [1m[4m[31mo d i t S z a P c 
[0m  [32mESI:[30m 0x00010094  [32mEDI:[30m 0x00000000  [32mEBP:[31m 0xF010CFB8  [32mESP:[31m 0xF010CFA0  [32mEIP:[31m 0xF0103393
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0023  [32mGS:[30m 0023  [32mSS:[30m 0010[0m
=> 0xf0103398 <env_run+11>:	cmp    0x8(%ebp),%eax
0xf0103398	585		if (curenv != e)
=> 0xf010339d <env_run+16>:	mov    0xf0110454,%eax
587			if (curenv && curenv->env_status == ENV_RUNNING)
=> 0xf01033bf <env_run+50>:	mov    0x8(%ebp),%eax
589			curenv = e;
=> 0xf01033c2 <env_run+53>:	mov    %eax,0xf0110454
0xf01033c2	589			curenv = e;
=> 0xf01033c7 <env_run+58>:	mov    0x8(%ebp),%eax
590			e->env_status = ENV_RUNNING;
=> 0xf01033ca <env_run+61>:	movl   $0x3,0x54(%eax)
0xf01033ca	590			e->env_status = ENV_RUNNING;
=> 0xf01033d1 <env_run+68>:	mov    0x8(%ebp),%eax
591			e->env_runs++;
=> 0xf01033d4 <env_run+71>:	mov    0x58(%eax),%eax
0xf01033d4	591			e->env_runs++;
=> 0xf01033d7 <env_run+74>:	lea    0x1(%eax),%edx
0xf01033d7	591			e->env_runs++;
=> 0xf01033da <env_run+77>:	mov    0x8(%ebp),%eax
0xf01033da	591			e->env_runs++;
=> 0xf01033dd <env_run+80>:	mov    %edx,0x58(%eax)
0xf01033dd	591			e->env_runs++;
=> 0xf01033e0 <env_run+83>:	mov    0x8(%ebp),%eax
592			lcr3(PADDR(e->env_pgdir));
=> 0xf01033e3 <env_run+86>:	mov    0x60(%eax),%eax
0xf01033e3	592			lcr3(PADDR(e->env_pgdir));
=> 0xf01033e6 <env_run+89>:	push   %eax
0xf01033e6	592			lcr3(PADDR(e->env_pgdir));
=> 0xf01033e7 <env_run+90>:	call   0xf0102a6f <_paddr>
0xf01033e7	592			lcr3(PADDR(e->env_pgdir));
=> 0xf0102a6f <_paddr>:	push   %ebp
_paddr (kva=0xf0044000) at ./pmap.h:38
38	{
=> 0xf0102a70 <_paddr+1>:	mov    %esp,%ebp
0xf0102a70	38	{
=> 0xf0102a72 <_paddr+3>:	mov    0x8(%ebp),%eax
39		return (physaddr_t)kva - KERNBASE;
=> 0xf0102a75 <_paddr+6>:	add    $0x10000000,%eax
0xf0102a75	39		return (physaddr_t)kva - KERNBASE;
=> 0xf0102a7a <_paddr+11>:	pop    %ebp
40	}
=> 0xf0102a7b <_paddr+12>:	ret    
0xf0102a7b in _paddr (kva=0xf0044000) at ./pmap.h:40
40	}
=> 0xf01033ec <env_run+95>:	add    $0x4,%esp
0xf01033ec in env_run (e=0xf0118000) at env.c:592
592			lcr3(PADDR(e->env_pgdir));
=> 0xf01033ef <env_run+98>:	mov    %eax,-0xc(%ebp)
0xf01033ef	592			lcr3(PADDR(e->env_pgdir));
=> 0xf01033f2 <env_run+101>:	mov    -0xc(%ebp),%eax
lcr3 (val=0x44000) at ./x86.h:215
215		__asm __volatile("movl %0,%%cr3" : : "r" (val));
=> 0xf01033f5 <env_run+104>:	mov    %eax,%cr3
0xf01033f5	215		__asm __volatile("movl %0,%%cr3" : : "r" (val));
=> 0xf01033f8 <env_run+107>:	call   0xf0102acd <unlock_kernel>
env_run (e=0xf0118000) at env.c:594
594		unlock_kernel();
  [32mEAX:[31m 0x00044000  [32mEBX:[30m 0x00010094  [32mECX:[30m 0x00000000  [32mEDX:[31m 0x00000001  [1m[4m[31mo d i t S z A P c 
[0m  [32mESI:[30m 0x00010094  [32mEDI:[30m 0x00000000  [32mEBP:[30m 0xF010CFB8  [32mESP:[30m 0xF010CFA0  [32mEIP:[31m 0xF01033F8
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0023  [32mGS:[30m 0023  [32mSS:[30m 0010[0m
Undefined command: "control".  Try "help".
Undefined command: "cr3".  Try "help".
No symbol "cr3" in current context.
No symbol "cr3" in current context.
$2 = void
A syntax error in expression, near `%cr3'.
eax            0x44000	0x44000
ecx            0x0	0x0
edx            0x1	0x1
ebx            0x10094	0x10094
esp            0xf010cfa0	0xf010cfa0
ebp            0xf010cfb8	0xf010cfb8
esi            0x10094	0x10094
edi            0x0	0x0
eip            0xf01033f8	0xf01033f8 <env_run+107>
eflags         0x96	[ PF AF SF ]
cs             0x8	0x8
ss             0x10	0x10
ds             0x10	0x10
es             0x10	0x10
fs             0x23	0x23
gs             0x23	0x23
=> 0xf0102acd <unlock_kernel>:	push   %ebp
unlock_kernel () at ./spinlock.h:28
28	{
=> 0xf0102ace <unlock_kernel+1>:	mov    %esp,%ebp
0xf0102ace	28	{
=> 0xf0102ad0 <unlock_kernel+3>:	sub    $0x8,%esp
0xf0102ad0	28	{
=> 0xf0102ad3 <unlock_kernel+6>:	sub    $0xc,%esp
29		spin_unlock(&kernel_lock);
=> 0xf0103451 <spin_unlock+3>:	mov    0x8(%ebp),%eax
spin_unlock (lk=0xf0110468 <kernel_lock>) at spinlock.c:46
46		xchg(&lk->locked, 0);
=> 0xf010340f <xchg+6>:	mov    0x8(%ebp),%edx
xchg (addr=0xf0110468 <kernel_lock>, newval=0x0) at ./x86.h:319
319		asm volatile("lock; xchgl %0, %1" :
=> 0xf010341e <xchg+21>:	mov    -0x4(%ebp),%eax
323		return result;
=> 0xf0103421 <xchg+24>:	leave  
324	}
Undefined command: "su".  Try "help".
Undefined command: "su".  Try "help".
=> 0xf0103422 <xchg+25>:	ret    
0xf0103422 in xchg (addr=0xf0110468 <kernel_lock>, newval=0x0) at ./x86.h:324
324	}
=> 0xf010345c <spin_unlock+14>:	add    $0x8,%esp
0xf010345c in spin_unlock (lk=0xf0110468 <kernel_lock>) at spinlock.c:46
46		xchg(&lk->locked, 0);
=> 0xf010345f <spin_unlock+17>:	nop
47	}
=> 0xf0103460 <spin_unlock+18>:	leave  
0xf0103460	47	}
=> 0xf0103461 <spin_unlock+19>:	ret    
0xf0103461 in spin_unlock (lk=0xf0110468 <kernel_lock>) at spinlock.c:47
47	}
=> 0xf0102ae0 <unlock_kernel+19>:	add    $0x10,%esp
0xf0102ae0 in unlock_kernel () at ./spinlock.h:29
29		spin_unlock(&kernel_lock);
=> 0xf0102ae3 <unlock_kernel+22>:	pause  
35		asm volatile("pause");
=> 0xf0102ae6 <unlock_kernel+25>:	leave  
0xf0102ae6	36	}
=> 0xf0102ae7 <unlock_kernel+26>:	ret    
0xf0102ae7 in unlock_kernel () at ./spinlock.h:36
36	}
=> 0xf01033fd <env_run+112>:	mov    0x8(%ebp),%eax
env_run (e=0xf0118000) at env.c:595
595		env_pop_tf(&(e->env_tf));
=> 0xf0103400 <env_run+115>:	sub    $0xc,%esp
0xf0103400	595		env_pop_tf(&(e->env_tf));
=> 0xf0103403 <env_run+118>:	push   %eax
0xf0103403	595		env_pop_tf(&(e->env_tf));
=> 0xf0103404 <env_run+119>:	call   0xf0103366 <env_pop_tf>
0xf0103404	595		env_pop_tf(&(e->env_tf));
=> 0xf0103366 <env_pop_tf>:	push   %ebp
env_pop_tf (tf=0xf0118000) at env.c:546
546	{
=> 0xf0103367 <env_pop_tf+1>:	mov    %esp,%ebp
0xf0103367	546	{
=> 0xf0103369 <env_pop_tf+3>:	sub    $0x8,%esp
0xf0103369	546	{
=> 0xf010336c <env_pop_tf+6>:	mov    0x8(%ebp),%esp
547		__asm __volatile("movl %0,%%esp\n"
=> 0xf010336f <env_pop_tf+9>:	popa   
0xf010336f	547		__asm __volatile("movl %0,%%esp\n"
=> 0xf0103370 <env_pop_tf+10>:	pop    %es
0xf0103370 in env_pop_tf (tf=<error reading variable: Cannot access memory at address 0x8>) at env.c:547
547		__asm __volatile("movl %0,%%esp\n"
=> 0xf0103371 <env_pop_tf+11>:	pop    %ds
0xf0103371	547		__asm __volatile("movl %0,%%esp\n"
=> 0xf0103372 <env_pop_tf+12>:	add    $0x8,%esp
0xf0103372	547		__asm __volatile("movl %0,%%esp\n"
=> 0xf0103375 <env_pop_tf+15>:	iret   
0xf0103375	547		__asm __volatile("movl %0,%%esp\n"
  [32mEAX:[31m 0x00000000  [32mEBX:[31m 0x00000000  [32mECX:[30m 0x00000000  [32mEDX:[31m 0x00000000  [1m[4m[31mo d i t S z A P c 
[0m  [32mESI:[31m 0x00000000  [32mEDI:[30m 0x00000000  [32mEBP:[31m 0x00000000  [32mESP:[31m 0xF0118030  [32mEIP:[31m 0xF0103375
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0023  [32mGS:[30m 0023  [32mSS:[30m 0010[0m
Cannot access memory at address 0x8
Cannot access memory at address 0x8
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Breakpoint 1 at 0xf010338d: file env.c, line 567.
Continuing.
The target architecture is assumed to be i386
=> 0xf010338d <env_run>:	push   %ebp

Breakpoint 1, env_run (e=0xf0118000) at env.c:567
567	{
=> 0xf0103393 <env_run+6>:	mov    0xf0110454,%eax
585		if (curenv != e)
=> 0xf010339d <env_run+16>:	mov    0xf0110454,%eax
587			if (curenv && curenv->env_status == ENV_RUNNING)
=> 0xf01033bf <env_run+50>:	mov    0x8(%ebp),%eax
589			curenv = e;
=> 0xf01033c7 <env_run+58>:	mov    0x8(%ebp),%eax
590			e->env_status = ENV_RUNNING;
=> 0xf01033d1 <env_run+68>:	mov    0x8(%ebp),%eax
591			e->env_runs++;
=> 0xf01033e0 <env_run+83>:	mov    0x8(%ebp),%eax
592			lcr3(PADDR(e->env_pgdir));
=> 0xf0102a72 <_paddr+3>:	mov    0x8(%ebp),%eax
_paddr (kva=0xf0044000) at ./pmap.h:39
39		return (physaddr_t)kva - KERNBASE;
=> 0xf0102a7a <_paddr+11>:	pop    %ebp
40	}
=> 0xf01033f2 <env_run+101>:	mov    -0xc(%ebp),%eax
lcr3 (val=0x44000) at ./x86.h:215
215		__asm __volatile("movl %0,%%cr3" : : "r" (val));
=> 0xf01033f8 <env_run+107>:	call   0xf0102acd <unlock_kernel>
env_run (e=0xf0118000) at env.c:594
594		unlock_kernel();
=> 0xf0102ad3 <unlock_kernel+6>:	sub    $0xc,%esp
unlock_kernel () at ./spinlock.h:29
29		spin_unlock(&kernel_lock);
=> 0xf0103451 <spin_unlock+3>:	mov    0x8(%ebp),%eax
spin_unlock (lk=0xf0110468 <kernel_lock>) at spinlock.c:46
46		xchg(&lk->locked, 0);
=> 0xf010340f <xchg+6>:	mov    0x8(%ebp),%edx
xchg (addr=0xf0110468 <kernel_lock>, newval=0x0) at ./x86.h:319
319		asm volatile("lock; xchgl %0, %1" :
=> 0xf010341e <xchg+21>:	mov    -0x4(%ebp),%eax
323		return result;
=> 0xf0103421 <xchg+24>:	leave  
324	}
=> 0xf0103422 <xchg+25>:	ret    
0xf0103422 in xchg (addr=0xf0110468 <kernel_lock>, newval=0x0) at ./x86.h:324
324	}
=> 0xf010345c <spin_unlock+14>:	add    $0x8,%esp
0xf010345c in spin_unlock (lk=0xf0110468 <kernel_lock>) at spinlock.c:46
46		xchg(&lk->locked, 0);
=> 0xf010345f <spin_unlock+17>:	nop
47	}
=> 0xf0103460 <spin_unlock+18>:	leave  
0xf0103460	47	}
=> 0xf0103461 <spin_unlock+19>:	ret    
0xf0103461 in spin_unlock (lk=0xf0110468 <kernel_lock>) at spinlock.c:47
47	}
=> 0xf0102ae0 <unlock_kernel+19>:	add    $0x10,%esp
0xf0102ae0 in unlock_kernel () at ./spinlock.h:29
29		spin_unlock(&kernel_lock);
=> 0xf0102ae3 <unlock_kernel+22>:	pause  
35		asm volatile("pause");
=> 0xf0102ae6 <unlock_kernel+25>:	leave  
0xf0102ae6	36	}
=> 0xf0102ae7 <unlock_kernel+26>:	ret    
0xf0102ae7 in unlock_kernel () at ./spinlock.h:36
36	}
=> 0xf01033fd <env_run+112>:	mov    0x8(%ebp),%eax
env_run (e=0xf0118000) at env.c:595
595		env_pop_tf(&(e->env_tf));
=> 0xf0103400 <env_run+115>:	sub    $0xc,%esp
0xf0103400	595		env_pop_tf(&(e->env_tf));
=> 0xf0103403 <env_run+118>:	push   %eax
0xf0103403	595		env_pop_tf(&(e->env_tf));
  [32mEAX:[31m 0xF0118000  [32mEBX:[31m 0x00010094  [32mECX:[31m 0xF0110468  [32mEDX:[31m 0xF0110468  [1m[4m[31mo d i t S z A p c 
[0m  [32mESI:[31m 0x00010094  [32mEDI:[30m 0x00000000  [32mEBP:[31m 0xF010CFB8  [32mESP:[31m 0xF010CF94  [32mEIP:[31m 0xF0103403
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0023  [32mGS:[30m 0023  [32mSS:[30m 0010[0m
  [32mEAX:[30m 0xF0118000  [32mEBX:[30m 0x00010094  [32mECX:[30m 0xF0110468  [32mEDX:[30m 0xF0110468  [1m[4m[31mo d i t S z A p c 
[0m  [32mESI:[30m 0x00010094  [32mEDI:[30m 0x00000000  [32mEBP:[30m 0xF010CFB8  [32mESP:[30m 0xF010CF94  [32mEIP:[31m 0xF0103403
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0023  [32mGS:[30m 0023  [32mSS:[30m 0010[0m
  [32mEAX:[30m 0xF0118000  [32mEBX:[30m 0x00010094  [32mECX:[30m 0xF0110468  [32mEDX:[30m 0xF0110468  [1m[4m[31mo d i t S z A p c 
[0m  [32mESI:[30m 0x00010094  [32mEDI:[30m 0x00000000  [32mEBP:[30m 0xF010CFB8  [32mESP:[30m 0xF010CF94  [32mEIP:[31m 0xF0103403
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0023  [32mGS:[30m 0023  [32mSS:[30m 0010[0m
=> 0xf0103404 <env_run+119>:	call   0xf0103366 <env_pop_tf>
0xf0103404	595		env_pop_tf(&(e->env_tf));
=> 0xf0103366 <env_pop_tf>:	push   %ebp
env_pop_tf (tf=0xf0118000) at env.c:546
546	{
=> 0xf0103367 <env_pop_tf+1>:	mov    %esp,%ebp
0xf0103367	546	{
=> 0xf0103369 <env_pop_tf+3>:	sub    $0x8,%esp
0xf0103369	546	{
  [32mEAX:[30m 0xF0118000  [32mEBX:[30m 0x00010094  [32mECX:[30m 0xF0110468  [32mEDX:[30m 0xF0110468  [1m[4m[31mo d i t S z A p c 
[0m  [32mESI:[30m 0x00010094  [32mEDI:[30m 0x00000000  [32mEBP:[31m 0xF010CF88  [32mESP:[31m 0xF010CF88  [32mEIP:[31m 0xF0103369
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0023  [32mGS:[30m 0023  [32mSS:[30m 0010[0m
=> 0xf010336c <env_pop_tf+6>:	mov    0x8(%ebp),%esp
547		__asm __volatile("movl %0,%%esp\n"
=> 0xf010336f <env_pop_tf+9>:	popa   
0xf010336f	547		__asm __volatile("movl %0,%%esp\n"
  [32mEAX:[30m 0xF0118000  [32mEBX:[30m 0x00010094  [32mECX:[30m 0xF0110468  [32mEDX:[30m 0xF0110468  [1m[4m[31mo d i t S z a p c 
[0m  [32mESI:[30m 0x00010094  [32mEDI:[30m 0x00000000  [32mEBP:[30m 0xF010CF88  [32mESP:[31m 0xF0118000  [32mEIP:[31m 0xF010336F
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0023  [32mGS:[30m 0023  [32mSS:[30m 0010[0m
=> 0xf0103370 <env_pop_tf+10>:	pop    %es
0xf0103370 in env_pop_tf (tf=<error reading variable: Cannot access memory at address 0x8>) at env.c:547
547		__asm __volatile("movl %0,%%esp\n"
  [32mEAX:[31m 0x00000000  [32mEBX:[31m 0x00000000  [32mECX:[31m 0x00000000  [32mEDX:[31m 0x00000000  [1m[4m[31mo d i t S z a p c 
[0m  [32mESI:[31m 0x00000000  [32mEDI:[30m 0x00000000  [32mEBP:[31m 0x00000000  [32mESP:[31m 0xF0118020  [32mEIP:[31m 0xF0103370
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0023  [32mGS:[30m 0023  [32mSS:[30m 0010[0m
=> 0xf0103371 <env_pop_tf+11>:	pop    %ds
0xf0103371	547		__asm __volatile("movl %0,%%esp\n"
  [32mEAX:[30m 0x00000000  [32mEBX:[30m 0x00000000  [32mECX:[30m 0x00000000  [32mEDX:[30m 0x00000000  [1m[4m[31mo d i t S z a p c 
[0m  [32mESI:[30m 0x00000000  [32mEDI:[30m 0x00000000  [32mEBP:[30m 0x00000000  [32mESP:[31m 0xF0118024  [32mEIP:[31m 0xF0103371
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0023  [32mGS:[30m 0023  [32mSS:[30m 0010[0m
=> 0xf0103372 <env_pop_tf+12>:	add    $0x8,%esp
0xf0103372	547		__asm __volatile("movl %0,%%esp\n"
  [32mEAX:[30m 0x00000000  [32mEBX:[30m 0x00000000  [32mECX:[30m 0x00000000  [32mEDX:[30m 0x00000000  [1m[4m[31mo d i t S z a p c 
[0m  [32mESI:[30m 0x00000000  [32mEDI:[30m 0x00000000  [32mEBP:[30m 0x00000000  [32mESP:[31m 0xF0118028  [32mEIP:[31m 0xF0103372
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0023  [32mGS:[30m 0023  [32mSS:[30m 0010[0m
=> 0xf0103375 <env_pop_tf+15>:	iret   
0xf0103375	547		__asm __volatile("movl %0,%%esp\n"
  [32mEAX:[30m 0x00000000  [32mEBX:[30m 0x00000000  [32mECX:[30m 0x00000000  [32mEDX:[30m 0x00000000  [1m[4m[31mo d i t S z A P c 
[0m  [32mESI:[30m 0x00000000  [32mEDI:[30m 0x00000000  [32mEBP:[30m 0x00000000  [32mESP:[31m 0xF0118030  [32mEIP:[31m 0xF0103375
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0023  [32mGS:[30m 0023  [32mSS:[30m 0010[0m
=> 0xf01000a7 <shitA>:	push   %ebp
shitA () at init.c:49
49	{
  [32mEAX:[30m 0x00000000  [32mEBX:[30m 0x00000000  [32mECX:[30m 0x00000000  [32mEDX:[30m 0x00000000  [1m[4m[31mo d I t s z a p c 
[0m  [32mESI:[30m 0x00000000  [32mEDI:[30m 0x00000000  [32mEBP:[30m 0x00000000  [32mESP:[31m 0xF011803C  [32mEIP:[31m 0xF01000A7
  [32mCS:[30m 0008  [32mDS:[30m 0010  [32mES:[30m 0010  [32mFS:[30m 0023  [32mGS:[30m 0023  [32mSS:[30m 0010[0m
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
.gdbinit:23: Error in sourced command file:
localhost:26000: Connection refused.

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
.gdbinit:23: Error in sourced command file:
localhost:26000: Connection refused.

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
.gdbinit:23: Error in sourced command file:
localhost:26000: Connection refused.

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
.gdbinit:23: Error in sourced command file:
localhost:26000: Connection refused.

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Breakpoint 1 at 0xf0100b28: file pmap.c, line 109.
Breakpoint 2 at 0xf0100aa6: file pmap.c, line 75.
Breakpoint 3 at 0xf0100fe9: file pmap.c, line 335.
Continuing.
The target architecture is assumed to be i386
=> 0xf0100b28 <mem_init>:	push   %ebp

Breakpoint 1, mem_init () at pmap.c:109
109	{
=> 0xf0100b29 <mem_init+1>:	mov    %esp,%ebp
0xf0100b29	109	{
=> 0xf0100b2b <mem_init+3>:	push   %ebx
0xf0100b2b	109	{
=> 0xf0100b2c <mem_init+4>:	sub    $0x24,%esp
0xf0100b2c	109	{
=> 0xf0100b2f <mem_init+7>:	call   0xf0100a27 <i386_detect_memory>
113		i386_detect_memory();
=> 0xf0100b34 <mem_init+12>:	sub    $0xc,%esp
118		kern_pgdir = (pde_t *) boot_alloc(PGSIZE);
=> 0xf0100b37 <mem_init+15>:	push   $0x1000
0xf0100b37	118		kern_pgdir = (pde_t *) boot_alloc(PGSIZE);
=> 0xf0100b3c <mem_init+20>:	call   0xf0100aa6 <boot_alloc>
0xf0100b3c	118		kern_pgdir = (pde_t *) boot_alloc(PGSIZE);
=> 0xf0100aa6 <boot_alloc>:	push   %ebp

Breakpoint 2, boot_alloc (n=0x1000) at pmap.c:75
75	{
=> 0xf0100aa7 <boot_alloc+1>:	mov    %esp,%ebp
0xf0100aa7	75	{
=> 0xf0100aa9 <boot_alloc+3>:	sub    $0x20,%esp
0xf0100aa9	75	{
=> 0xf0100aac <boot_alloc+6>:	mov    0xf032a794,%eax
84		if (!nextfree) {
=> 0xf0100ab1 <boot_alloc+11>:	test   %eax,%eax
0xf0100ab1	84		if (!nextfree) {
=> 0xf0100ab3 <boot_alloc+13>:	jne    0xf0100ae1 <boot_alloc+59>
0xf0100ab3	84		if (!nextfree) {
=> 0xf0100ab5 <boot_alloc+15>:	movl   $0x1000,-0x4(%ebp)
86			nextfree = (char *)ROUNDUP((char *) end, PGSIZE);
=> 0xf0100abc <boot_alloc+22>:	mov    $0xf032b430,%eax
0xf0100abc	86			nextfree = (char *)ROUNDUP((char *) end, PGSIZE);
=> 0xf0100ac1 <boot_alloc+27>:	lea    -0x1(%eax),%edx
0xf0100ac1	86			nextfree = (char *)ROUNDUP((char *) end, PGSIZE);
=> 0xf0100ac4 <boot_alloc+30>:	mov    -0x4(%ebp),%eax
0xf0100ac4	86			nextfree = (char *)ROUNDUP((char *) end, PGSIZE);
=> 0xf0100ac7 <boot_alloc+33>:	add    %edx,%eax
0xf0100ac7	86			nextfree = (char *)ROUNDUP((char *) end, PGSIZE);
=> 0xf0100ac9 <boot_alloc+35>:	mov    %eax,-0x8(%ebp)
0xf0100ac9	86			nextfree = (char *)ROUNDUP((char *) end, PGSIZE);
=> 0xf0100acc <boot_alloc+38>:	mov    -0x8(%ebp),%eax
0xf0100acc	86			nextfree = (char *)ROUNDUP((char *) end, PGSIZE);
=> 0xf0100ae1 <boot_alloc+59>:	mov    0xf032a794,%eax
92		result = nextfree;
=> 0xf0100ae9 <boot_alloc+67>:	cmpl   $0x0,0x8(%ebp)
93		if(n != 0)
=> 0xf0100aef <boot_alloc+73>:	movl   $0x1000,-0x10(%ebp)
94			nextfree = ROUNDUP(nextfree + n, PGSIZE);
=> 0xf0100b23 <boot_alloc+125>:	mov    -0xc(%ebp),%eax
95		return (void *)result;
=> 0xf0100b26 <boot_alloc+128>:	leave  
96	}
=> 0xf0100b49 <mem_init+33>:	mov    0xf032b424,%eax
mem_init () at pmap.c:119
119		memset(kern_pgdir, 0, PGSIZE);
=> 0xf010444f <memset+12>:	test   %ecx,%ecx
memset (v=0xf032c000, c=0x0, n=0x1000) at string.c:119
119		if (n == 0)
=> 0xf0104453 <memset+16>:	test   $0x3,%edi
121		if ((int)v%4 == 0 && n%4 == 0) {
=> 0xf0104460 <memset+29>:	movzbl 0xc(%ebp),%edx
122			c &= 0xFF;
=> 0xf0104464 <memset+33>:	mov    %edx,%ebx
123			c = (c<<24)|(c<<16)|(c<<8)|c;
=> 0xf0104477 <memset+52>:	mov    %ebx,%eax
124			asm volatile("cld; rep stosl\n"
=> 0xf0104489 <memset+70>:	mov    %edi,%eax
132	}
=> 0xf0100b61 <mem_init+57>:	mov    0xf032b424,%eax
mem_init () at pmap.c:127
127		kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;
=> 0xf010096a <_paddr+3>:	mov    0x8(%ebp),%eax
_paddr (kva=0xf032c000) at ./pmap.h:41
41		return (physaddr_t)kva - KERNBASE;
=> 0xf0100972 <_paddr+11>:	pop    %ebp
42	}
=> 0xf0100b82 <mem_init+90>:	mov    0xf032b420,%eax
mem_init () at pmap.c:135
135		pages = (struct PageInfo *) boot_alloc(npages * sizeof(struct PageInfo));
=> 0xf0100aa6 <boot_alloc>:	push   %ebp

Breakpoint 2, boot_alloc (n=0x4000) at pmap.c:75
75	{
=> 0xf0100aac <boot_alloc+6>:	mov    0xf032a794,%eax
84		if (!nextfree) {
=> 0xf0100ae1 <boot_alloc+59>:	mov    0xf032a794,%eax
92		result = nextfree;
=> 0xf0100ae9 <boot_alloc+67>:	cmpl   $0x0,0x8(%ebp)
93		if(n != 0)
=> 0xf0100aef <boot_alloc+73>:	movl   $0x1000,-0x10(%ebp)
94			nextfree = ROUNDUP(nextfree + n, PGSIZE);
=> 0xf0100b23 <boot_alloc+125>:	mov    -0xc(%ebp),%eax
95		return (void *)result;
=> 0xf0100b26 <boot_alloc+128>:	leave  
96	}
=> 0xf0100b9b <mem_init+115>:	mov    0xf032b420,%eax
mem_init () at pmap.c:136
136		memset(pages, 0, npages * sizeof(struct PageInfo));
=> 0xf010444f <memset+12>:	test   %ecx,%ecx
memset (v=0xf032d000, c=0x0, n=0x4000) at string.c:119
119		if (n == 0)
=> 0xf0104453 <memset+16>:	test   $0x3,%edi
121		if ((int)v%4 == 0 && n%4 == 0) {
=> 0xf0104460 <memset+29>:	movzbl 0xc(%ebp),%edx
122			c &= 0xFF;
=> 0xf0104464 <memset+33>:	mov    %edx,%ebx
123			c = (c<<24)|(c<<16)|(c<<8)|c;
=> 0xf0104477 <memset+52>:	mov    %ebx,%eax
124			asm volatile("cld; rep stosl\n"
=> 0xf0104489 <memset+70>:	mov    %edi,%eax
132	}
=> 0xf0100bbb <mem_init+147>:	sub    $0xc,%esp
mem_init () at pmap.c:140
140		envs = (struct Env *)boot_alloc(NENV * sizeof(struct Env));
=> 0xf0100aa6 <boot_alloc>:	push   %ebp

Breakpoint 2, boot_alloc (n=0x1f000) at pmap.c:75
75	{
=> 0xf0100aac <boot_alloc+6>:	mov    0xf032a794,%eax
84		if (!nextfree) {
=> 0xf0100ae1 <boot_alloc+59>:	mov    0xf032a794,%eax
92		result = nextfree;
=> 0xf0100ae9 <boot_alloc+67>:	cmpl   $0x0,0x8(%ebp)
93		if(n != 0)
=> 0xf0100aef <boot_alloc+73>:	movl   $0x1000,-0x10(%ebp)
94			nextfree = ROUNDUP(nextfree + n, PGSIZE);
=> 0xf0100b23 <boot_alloc+125>:	mov    -0xc(%ebp),%eax
95		return (void *)result;
=> 0xf0100b26 <boot_alloc+128>:	leave  
96	}
=> 0xf0100bd0 <mem_init+168>:	call   0xf0100cf5 <page_init>
mem_init () at pmap.c:148
148		page_init();
=> 0xf0100cfb <page_init+6>:	movl   $0x0,0xf032a790
page_init () at pmap.c:222
222		page_free_list = NULL;
=> 0xf0100d05 <page_init+16>:	movl   $0x1,-0x4(%ebp)
223		for (i = 1; i < npages_basemem / PGSIZE; i++) {
=> 0xf0100d58 <page_init+99>:	push   $0x0
228		size_t start = (size_t)PGNUM((uint32_t)boot_alloc(0) - KERNBASE);
=> 0xf0100aa6 <boot_alloc>:	push   %ebp

Breakpoint 2, boot_alloc (n=0x0) at pmap.c:75
75	{
=> 0xf0100aac <boot_alloc+6>:	mov    0xf032a794,%eax
84		if (!nextfree) {
=> 0xf0100ae1 <boot_alloc+59>:	mov    0xf032a794,%eax
92		result = nextfree;
=> 0xf0100ae9 <boot_alloc+67>:	cmpl   $0x0,0x8(%ebp)
93		if(n != 0)
=> 0xf0100b23 <boot_alloc+125>:	mov    -0xc(%ebp),%eax
95		return (void *)result;
=> 0xf0100b26 <boot_alloc+128>:	leave  
96	}
=> 0xf0100d6d <page_init+120>:	mov    -0x8(%ebp),%eax
page_init () at pmap.c:229
229		for(i = start; i < npages; ++i) {
=> 0xf0100d75 <page_init+128>:	mov    0xf032b428,%eax
230			pages[i].pp_ref = 0;
=> 0xf0100d88 <page_init+147>:	mov    0xf032b428,%eax
231			pages[i].pp_link = page_free_list;
=> 0xf0100d9c <page_init+167>:	mov    0xf032b428,%eax
232			page_free_list = &pages[i];
=> 0xf0100dae <page_init+185>:	addl   $0x1,-0x4(%ebp)
229		for(i = start; i < npages; ++i) {
=> 0xf0100d75 <page_init+128>:	mov    0xf032b428,%eax
230			pages[i].pp_ref = 0;
=> 0xf0100d88 <page_init+147>:	mov    0xf032b428,%eax
231			pages[i].pp_link = page_free_list;
=> 0xf0100d9c <page_init+167>:	mov    0xf032b428,%eax
232			page_free_list = &pages[i];
=> 0xf0100dae <page_init+185>:	addl   $0x1,-0x4(%ebp)
229		for(i = start; i < npages; ++i) {
=> 0xf0100d75 <page_init+128>:	mov    0xf032b428,%eax
230			pages[i].pp_ref = 0;
=> 0xf0100d88 <page_init+147>:	mov    0xf032b428,%eax
231			pages[i].pp_link = page_free_list;
=> 0xf0100d9c <page_init+167>:	mov    0xf032b428,%eax
232			page_free_list = &pages[i];
=> 0xf0100dae <page_init+185>:	addl   $0x1,-0x4(%ebp)
229		for(i = start; i < npages; ++i) {
=> 0xf0100d75 <page_init+128>:	mov    0xf032b428,%eax
230			pages[i].pp_ref = 0;
=> 0xf0100d88 <page_init+147>:	mov    0xf032b428,%eax
231			pages[i].pp_link = page_free_list;
=> 0xf0100d9c <page_init+167>:	mov    0xf032b428,%eax
232			page_free_list = &pages[i];
=> 0xf0100dae <page_init+185>:	addl   $0x1,-0x4(%ebp)
229		for(i = start; i < npages; ++i) {
=> 0xf0100d75 <page_init+128>:	mov    0xf032b428,%eax
230			pages[i].pp_ref = 0;
=> 0xf0100d88 <page_init+147>:	mov    0xf032b428,%eax
231			pages[i].pp_link = page_free_list;
=> 0xf0100d9c <page_init+167>:	mov    0xf032b428,%eax
232			page_free_list = &pages[i];
=> 0xf0100dae <page_init+185>:	addl   $0x1,-0x4(%ebp)
229		for(i = start; i < npages; ++i) {
=> 0xf0100d75 <page_init+128>:	mov    0xf032b428,%eax
230			pages[i].pp_ref = 0;
=> 0xf0100d88 <page_init+147>:	mov    0xf032b428,%eax
231			pages[i].pp_link = page_free_list;
=> 0xf0100d9c <page_init+167>:	mov    0xf032b428,%eax
232			page_free_list = &pages[i];
=> 0xf0100dae <page_init+185>:	addl   $0x1,-0x4(%ebp)
229		for(i = start; i < npages; ++i) {
=> 0xf0100d75 <page_init+128>:	mov    0xf032b428,%eax
230			pages[i].pp_ref = 0;
=> 0xf0100d88 <page_init+147>:	mov    0xf032b428,%eax
231			pages[i].pp_link = page_free_list;
=> 0xf0100d9c <page_init+167>:	mov    0xf032b428,%eax
232			page_free_list = &pages[i];
=> 0xf0100dae <page_init+185>:	addl   $0x1,-0x4(%ebp)
229		for(i = start; i < npages; ++i) {
=> 0xf0100d75 <page_init+128>:	mov    0xf032b428,%eax
230			pages[i].pp_ref = 0;
=> 0xf0100d88 <page_init+147>:	mov    0xf032b428,%eax
231			pages[i].pp_link = page_free_list;
=> 0xf0100d9c <page_init+167>:	mov    0xf032b428,%eax
232			page_free_list = &pages[i];
=> 0xf0100dae <page_init+185>:	addl   $0x1,-0x4(%ebp)
229		for(i = start; i < npages; ++i) {
=> 0xf0100d75 <page_init+128>:	mov    0xf032b428,%eax
230			pages[i].pp_ref = 0;
=> 0xf0100d88 <page_init+147>:	mov    0xf032b428,%eax
231			pages[i].pp_link = page_free_list;
=> 0xf0100d9c <page_init+167>:	mov    0xf032b428,%eax
232			page_free_list = &pages[i];
=> 0xf0100dae <page_init+185>:	addl   $0x1,-0x4(%ebp)
229		for(i = start; i < npages; ++i) {
=> 0xf0100d75 <page_init+128>:	mov    0xf032b428,%eax
230			pages[i].pp_ref = 0;
=> 0xf0100d88 <page_init+147>:	mov    0xf032b428,%eax
231			pages[i].pp_link = page_free_list;
=> 0xf0100d9c <page_init+167>:	mov    0xf032b428,%eax
232			page_free_list = &pages[i];
=> 0xf0100dae <page_init+185>:	addl   $0x1,-0x4(%ebp)
229		for(i = start; i < npages; ++i) {
=> 0xf0100d75 <page_init+128>:	mov    0xf032b428,%eax
230			pages[i].pp_ref = 0;
=> 0xf0100d88 <page_init+147>:	mov    0xf032b428,%eax
231			pages[i].pp_link = page_free_list;
=> 0xf0100d9c <page_init+167>:	mov    0xf032b428,%eax
232			page_free_list = &pages[i];
=> 0xf0100dae <page_init+185>:	addl   $0x1,-0x4(%ebp)
229		for(i = start; i < npages; ++i) {
=> 0xf0100d75 <page_init+128>:	mov    0xf032b428,%eax
230			pages[i].pp_ref = 0;
=> 0xf0100d88 <page_init+147>:	mov    0xf032b428,%eax
231			pages[i].pp_link = page_free_list;
=> 0xf0100d9c <page_init+167>:	mov    0xf032b428,%eax
232			page_free_list = &pages[i];
=> 0xf0100dae <page_init+185>:	addl   $0x1,-0x4(%ebp)
229		for(i = start; i < npages; ++i) {
=> 0xf0100d75 <page_init+128>:	mov    0xf032b428,%eax
230			pages[i].pp_ref = 0;
=> 0xf0100d88 <page_init+147>:	mov    0xf032b428,%eax
231			pages[i].pp_link = page_free_list;
=> 0xf0100d9c <page_init+167>:	mov    0xf032b428,%eax
232			page_free_list = &pages[i];
=> 0xf0100dae <page_init+185>:	addl   $0x1,-0x4(%ebp)
229		for(i = start; i < npages; ++i) {
=> 0xf0100d75 <page_init+128>:	mov    0xf032b428,%eax
230			pages[i].pp_ref = 0;
=> 0xf0100d88 <page_init+147>:	mov    0xf032b428,%eax
231			pages[i].pp_link = page_free_list;
=> 0xf0100d9c <page_init+167>:	mov    0xf032b428,%eax
232			page_free_list = &pages[i];
=> 0xf0100dae <page_init+185>:	addl   $0x1,-0x4(%ebp)
229		for(i = start; i < npages; ++i) {
=> 0xf0100d75 <page_init+128>:	mov    0xf032b428,%eax
230			pages[i].pp_ref = 0;
=> 0xf0100d88 <page_init+147>:	mov    0xf032b428,%eax
231			pages[i].pp_link = page_free_list;
=> 0xf0100d9c <page_init+167>:	mov    0xf032b428,%eax
232			page_free_list = &pages[i];
=> 0xf0100dae <page_init+185>:	addl   $0x1,-0x4(%ebp)
229		for(i = start; i < npages; ++i) {
=> 0xf0100d75 <page_init+128>:	mov    0xf032b428,%eax
230			pages[i].pp_ref = 0;
=> 0xf0100d88 <page_init+147>:	mov    0xf032b428,%eax
231			pages[i].pp_link = page_free_list;
=> 0xf0100d9c <page_init+167>:	mov    0xf032b428,%eax
232			page_free_list = &pages[i];
=> 0xf0100dae <page_init+185>:	addl   $0x1,-0x4(%ebp)
229		for(i = start; i < npages; ++i) {
=> 0xf0100d75 <page_init+128>:	mov    0xf032b428,%eax
230			pages[i].pp_ref = 0;
=> 0xf0100d88 <page_init+147>:	mov    0xf032b428,%eax
231			pages[i].pp_link = page_free_list;
=> 0xf0100d9c <page_init+167>:	mov    0xf032b428,%eax
232			page_free_list = &pages[i];
=> 0xf0100dae <page_init+185>:	addl   $0x1,-0x4(%ebp)
229		for(i = start; i < npages; ++i) {
=> 0xf0100d75 <page_init+128>:	mov    0xf032b428,%eax
230			pages[i].pp_ref = 0;
=> 0xf0100d88 <page_init+147>:	mov    0xf032b428,%eax
231			pages[i].pp_link = page_free_list;
=> 0xf0100d9c <page_init+167>:	mov    0xf032b428,%eax
232			page_free_list = &pages[i];
=> 0xf0100dae <page_init+185>:	addl   $0x1,-0x4(%ebp)
229		for(i = start; i < npages; ++i) {
=> 0xf0100d75 <page_init+128>:	mov    0xf032b428,%eax
230			pages[i].pp_ref = 0;
=> 0xf0100d88 <page_init+147>:	mov    0xf032b428,%eax
231			pages[i].pp_link = page_free_list;
=> 0xf0100d9c <page_init+167>:	mov    0xf032b428,%eax
232			page_free_list = &pages[i];
=> 0xf0100dae <page_init+185>:	addl   $0x1,-0x4(%ebp)
229		for(i = start; i < npages; ++i) {
=> 0xf0100d75 <page_init+128>:	mov    0xf032b428,%eax
230			pages[i].pp_ref = 0;
=> 0xf0100d88 <page_init+147>:	mov    0xf032b428,%eax
231			pages[i].pp_link = page_free_list;
=> 0xf0100d9c <page_init+167>:	mov    0xf032b428,%eax
232			page_free_list = &pages[i];
=> 0xf0100dae <page_init+185>:	addl   $0x1,-0x4(%ebp)
229		for(i = start; i < npages; ++i) {
=> 0xf0100d75 <page_init+128>:	mov    0xf032b428,%eax
230			pages[i].pp_ref = 0;
=> 0xf0100d88 <page_init+147>:	mov    0xf032b428,%eax
231			pages[i].pp_link = page_free_list;
=> 0xf0100d9c <page_init+167>:	mov    0xf032b428,%eax
232			page_free_list = &pages[i];
=> 0xf0100dae <page_init+185>:	addl   $0x1,-0x4(%ebp)
229		for(i = start; i < npages; ++i) {
=> 0xf0100d75 <page_init+128>:	mov    0xf032b428,%eax
230			pages[i].pp_ref = 0;
=> 0xf0100d88 <page_init+147>:	mov    0xf032b428,%eax
231			pages[i].pp_link = page_free_list;
=> 0xf0100d9c <page_init+167>:	mov    0xf032b428,%eax
232			page_free_list = &pages[i];
=> 0xf0100dae <page_init+185>:	addl   $0x1,-0x4(%ebp)
229		for(i = start; i < npages; ++i) {
=> 0xf0100d75 <page_init+128>:	mov    0xf032b428,%eax
230			pages[i].pp_ref = 0;
=> 0xf0100d88 <page_init+147>:	mov    0xf032b428,%eax
231			pages[i].pp_link = page_free_list;
=> 0xf0100d9c <page_init+167>:	mov    0xf032b428,%eax
232			page_free_list = &pages[i];
=> 0xf0100dae <page_init+185>:	addl   $0x1,-0x4(%ebp)
229		for(i = start; i < npages; ++i) {
=> 0xf0100d75 <page_init+128>:	mov    0xf032b428,%eax
230			pages[i].pp_ref = 0;
=> 0xf0100d88 <page_init+147>:	mov    0xf032b428,%eax
231			pages[i].pp_link = page_free_list;
=> 0xf0100d9c <page_init+167>:	mov    0xf032b428,%eax
232			page_free_list = &pages[i];
=> 0xf0100dae <page_init+185>:	addl   $0x1,-0x4(%ebp)
229		for(i = start; i < npages; ++i) {
=> 0xf0100d75 <page_init+128>:	mov    0xf032b428,%eax
230			pages[i].pp_ref = 0;
=> 0xf0100d88 <page_init+147>:	mov    0xf032b428,%eax
231			pages[i].pp_link = page_free_list;
=> 0xf0100d9c <page_init+167>:	mov    0xf032b428,%eax
232			page_free_list = &pages[i];
=> 0xf0100dae <page_init+185>:	addl   $0x1,-0x4(%ebp)
229		for(i = start; i < npages; ++i) {
=> 0xf0100d75 <page_init+128>:	mov    0xf032b428,%eax
230			pages[i].pp_ref = 0;
=> 0xf0100d88 <page_init+147>:	mov    0xf032b428,%eax
231			pages[i].pp_link = page_free_list;
=> 0xf0100d9c <page_init+167>:	mov    0xf032b428,%eax
232			page_free_list = &pages[i];
=> 0xf0100dae <page_init+185>:	addl   $0x1,-0x4(%ebp)
229		for(i = start; i < npages; ++i) {
=> 0xf0100d75 <page_init+128>:	mov    0xf032b428,%eax
230			pages[i].pp_ref = 0;
=> 0xf0100d88 <page_init+147>:	mov    0xf032b428,%eax
231			pages[i].pp_link = page_free_list;
=> 0xf0100d9c <page_init+167>:	mov    0xf032b428,%eax
232			page_free_list = &pages[i];
=> 0xf0100dae <page_init+185>:	addl   $0x1,-0x4(%ebp)
229		for(i = start; i < npages; ++i) {
=> 0xf0100d75 <page_init+128>:	mov    0xf032b428,%eax
230			pages[i].pp_ref = 0;
=> 0xf0100d88 <page_init+147>:	mov    0xf032b428,%eax
231			pages[i].pp_link = page_free_list;
=> 0xf0100d9c <page_init+167>:	mov    0xf032b428,%eax
232			page_free_list = &pages[i];
=> 0xf0100dae <page_init+185>:	addl   $0x1,-0x4(%ebp)
229		for(i = start; i < npages; ++i) {
=> 0xf0100d75 <page_init+128>:	mov    0xf032b428,%eax
230			pages[i].pp_ref = 0;
=> 0xf0100d88 <page_init+147>:	mov    0xf032b428,%eax
231			pages[i].pp_link = page_free_list;
=> 0xf0100d9c <page_init+167>:	mov    0xf032b428,%eax
232			page_free_list = &pages[i];
=> 0xf0100dae <page_init+185>:	addl   $0x1,-0x4(%ebp)
229		for(i = start; i < npages; ++i) {
=> 0xf0100d75 <page_init+128>:	mov    0xf032b428,%eax
230			pages[i].pp_ref = 0;
=> 0xf0100d88 <page_init+147>:	mov    0xf032b428,%eax
231			pages[i].pp_link = page_free_list;
=> 0xf0100d9c <page_init+167>:	mov    0xf032b428,%eax
232			page_free_list = &pages[i];
=> 0xf0100dae <page_init+185>:	addl   $0x1,-0x4(%ebp)
229		for(i = start; i < npages; ++i) {
=> 0xf0100d75 <page_init+128>:	mov    0xf032b428,%eax
230			pages[i].pp_ref = 0;
=> 0xf0100d88 <page_init+147>:	mov    0xf032b428,%eax
231			pages[i].pp_link = page_free_list;
=> 0xf0100d9c <page_init+167>:	mov    0xf032b428,%eax
232			page_free_list = &pages[i];
=> 0xf0100dae <page_init+185>:	addl   $0x1,-0x4(%ebp)
229		for(i = start; i < npages; ++i) {
=> 0xf0100d75 <page_init+128>:	mov    0xf032b428,%eax
230			pages[i].pp_ref = 0;
=> 0xf0100d88 <page_init+147>:	mov    0xf032b428,%eax
231			pages[i].pp_link = page_free_list;
=> 0xf0100d9c <page_init+167>:	mov    0xf032b428,%eax
232			page_free_list = &pages[i];
=> 0xf0100dae <page_init+185>:	addl   $0x1,-0x4(%ebp)
229		for(i = start; i < npages; ++i) {
Continuing.
=> 0xf0100fe9 <boot_map_region>:	push   %ebp

Breakpoint 3, boot_map_region (pgdir=0xf032c000, va=0xef000000, size=0x4000, pa=0x32d000, perm=0x5) at pmap.c:335
335	{
=> 0xf0100fef <boot_map_region+6>:	movl   $0x0,-0xc(%ebp)
338		for(i = 0; i < size; i += PGSIZE)
=> 0xf0100ff8 <boot_map_region+15>:	mov    0xc(%ebp),%edx
340			pte_t * temp_pte = pgdir_walk(pgdir, (void *)(va + i), 1);
=> 0xf0100eb9 <pgdir_walk+7>:	mov    0xc(%ebp),%eax
pgdir_walk (pgdir=0xf032c000, va=0xef000000, create=0x1) at pmap.c:299
299		pte_t * page_table = (pte_t *)KADDR(PTE_ADDR(pgdir[PDX(va)]));
=> 0xf0100977 <_kaddr+3>:	mov    0x8(%ebp),%eax
_kaddr (pa=0x0) at ./pmap.h:51
51		return (void *)(pa + KERNBASE);
=> 0xf010097f <_kaddr+11>:	pop    %ebp
52	}
=> 0xf0100ede <pgdir_walk+44>:	mov    0xc(%ebp),%eax
pgdir_walk (pgdir=0xf032c000, va=0xef000000, create=0x1) at pmap.c:301
301		if(!pgdir[PDX(va)])	//the relevant page table page not exist
=> 0xf0100efa <pgdir_walk+72>:	cmpl   $0x0,0x10(%ebp)
303			if(!create)	// not create a new page table page
=> 0xf0100f0a <pgdir_walk+88>:	sub    $0xc,%esp
307			struct PageInfo * new_page_table_page = page_alloc(1);
=> 0xf0100dc5 <page_alloc+6>:	mov    0xf032a790,%eax
page_alloc (alloc_flags=0x1) at pmap.c:245
245		if(!page_free_list)	// out of free memory
=> 0xf0100dd5 <page_alloc+22>:	mov    0xf032a790,%eax
248		struct PageInfo * temp = page_free_list;
=> 0xf0100ddd <page_alloc+30>:	mov    0xf032a790,%eax
249		page_free_list = page_free_list->pp_link;
=> 0xf0100de9 <page_alloc+42>:	mov    -0xc(%ebp),%eax
250		temp->pp_link = NULL;
=> 0xf0100df2 <page_alloc+51>:	mov    0x8(%ebp),%eax
252		if(alloc_flags & ALLOC_ZERO)
=> 0xf0100dfc <page_alloc+61>:	pushl  -0xc(%ebp)
253			memset(page2kva(temp), 0, PGSIZE);
=> 0xf01009af <page2kva+3>:	pushl  0x8(%ebp)
page2kva (pp=0xf0330ff8) at ./pmap.h:90
90		return KADDR(page2pa(pp));
=> 0xf0100984 <page2pa+3>:	mov    0x8(%ebp),%eax
page2pa (pp=0xf0330ff8) at ./pmap.h:78
78		return (pp - pages) << PGSHIFT;
=> 0xf0100995 <page2pa+20>:	pop    %ebp
79	}
=> 0xf0100977 <_kaddr+3>:	mov    0x8(%ebp),%eax
_kaddr (pa=0x7ff000) at ./pmap.h:51
51		return (void *)(pa + KERNBASE);
=> 0xf010097f <_kaddr+11>:	pop    %ebp
52	}
=> 0xf01009c3 <page2kva+23>:	leave  
page2kva (pp=0xf0330ff8) at ./pmap.h:91
91	}
=> 0xf010444f <memset+12>:	test   %ecx,%ecx
memset (v=0xf07ff000, c=0x0, n=0x1000) at string.c:119
119		if (n == 0)
=> 0xf0104453 <memset+16>:	test   $0x3,%edi
121		if ((int)v%4 == 0 && n%4 == 0) {
=> 0xf0104460 <memset+29>:	movzbl 0xc(%ebp),%edx
122			c &= 0xFF;
=> 0xf0104464 <memset+33>:	mov    %edx,%ebx
123			c = (c<<24)|(c<<16)|(c<<8)|c;
=> 0xf0104477 <memset+52>:	mov    %ebx,%eax
124			asm volatile("cld; rep stosl\n"
The target architecture is assumed to be i8086
[f000:e05b]    0x15805b:	add    %al,(%bx,%si)
0x0000e05b in ?? ()
Cannot find bounds of current function
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Breakpoint 1 at 0xf0100fe9: file pmap.c, line 334.
Continuing.
The target architecture is assumed to be i386
=> 0xf0100fe9 <boot_map_region>:	push   %ebp

Breakpoint 1, boot_map_region (pgdir=0xf032c000, va=0xef000000, size=0x4000, pa=0x32d000, perm=0x5) at pmap.c:335
335	{
330	// above UTOP. As such, it should *not* change the pp_ref field on the
331	// mapped pages.
332	//
333	static void
334	boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
335	{
336	
337		size_t i;
338		for(i = 0; i < size; i += PGSIZE)
339		{
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Breakpoint 1 at 0xf0100bd5: file pmap.c, line 159.
Breakpoint 2 at 0xf0100c32: file pmap.c, line 166.
Breakpoint 3 at 0xf0100c63: file pmap.c, line 177.
Breakpoint 4 at 0xf0100c93: file pmap.c, line 185.
Continuing.
The target architecture is assumed to be i386
=> 0xf0100bd5 <mem_init+173>:	mov    0xf032b428,%eax

Breakpoint 1, mem_init () at pmap.c:159
159		boot_map_region(kern_pgdir, UPAGES, ROUNDUP(npages * sizeof(struct PageInfo), PGSIZE), PADDR(pages), PTE_U | PTE_P);
=> 0xf010096a <_paddr+3>:	mov    0x8(%ebp),%eax
_paddr (kva=0xf032d000) at ./pmap.h:41
41		return (physaddr_t)kva - KERNBASE;
=> 0xf0100972 <_paddr+11>:	pop    %ebp
42	}
=> 0xf0100fef <boot_map_region+6>:	movl   $0x0,-0xc(%ebp)
boot_map_region (pgdir=0xf032c000, va=0xef000000, size=0x4000, pa=0x32d000, perm=0x5) at pmap.c:338
338		for(i = 0; i < size; i += PGSIZE)
=> 0xf0100ff8 <boot_map_region+15>:	mov    0xc(%ebp),%edx
340			pte_t * temp_pte = pgdir_walk(pgdir, (void *)(va + i), 1);
=> 0xf0100eb9 <pgdir_walk+7>:	mov    0xc(%ebp),%eax
pgdir_walk (pgdir=0xf032c000, va=0xef000000, create=0x1) at pmap.c:299
299		pte_t * page_table = (pte_t *)KADDR(PTE_ADDR(pgdir[PDX(va)]));
=> 0xf0100977 <_kaddr+3>:	mov    0x8(%ebp),%eax
_kaddr (pa=0x0) at ./pmap.h:51
51		return (void *)(pa + KERNBASE);
=> 0xf010097f <_kaddr+11>:	pop    %ebp
52	}
=> 0xf0100ede <pgdir_walk+44>:	mov    0xc(%ebp),%eax
pgdir_walk (pgdir=0xf032c000, va=0xef000000, create=0x1) at pmap.c:301
301		if(!pgdir[PDX(va)])	//the relevant page table page not exist
=> 0xf0100efa <pgdir_walk+72>:	cmpl   $0x0,0x10(%ebp)
303			if(!create)	// not create a new page table page
Continuing.
=> 0xf0100bd5 <mem_init+173>:	mov    0xf032b428,%eax

Breakpoint 1, mem_init () at pmap.c:159
159		boot_map_region(kern_pgdir, UPAGES, ROUNDUP(npages * sizeof(struct PageInfo), PGSIZE), PADDR(pages), PTE_U | PTE_P);
=> 0xf010096a <_paddr+3>:	mov    0x8(%ebp),%eax
_paddr (kva=0xf032d000) at ./pmap.h:41
41		return (physaddr_t)kva - KERNBASE;
=> 0xf0100972 <_paddr+11>:	pop    %ebp
42	}
=> 0xf0100fef <boot_map_region+6>:	movl   $0x0,-0xc(%ebp)
boot_map_region (pgdir=0xf032c000, va=0xef000000, size=0x4000, pa=0x32d000, perm=0x5) at pmap.c:338
338		for(i = 0; i < size; i += PGSIZE)
=> 0xf0100ff8 <boot_map_region+15>:	mov    0xc(%ebp),%edx
340			pte_t * temp_pte = pgdir_walk(pgdir, (void *)(va + i), 1);
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Breakpoint 1 at 0xf0100893: file pmap.c, line 159.
Continuing.
The target architecture is assumed to be i386
=> 0xf0100893 <mem_init+243>:	mov    0xf0329240,%eax

Breakpoint 1, mem_init () at pmap.c:159
159		boot_map_region(kern_pgdir, UPAGES, ROUNDUP(npages * sizeof(struct PageInfo), PGSIZE), PADDR(pages), PTE_U | PTE_P);
=> 0xf0100898 <mem_init+248>:	pop    %edx
0xf0100898	159		boot_map_region(kern_pgdir, UPAGES, ROUNDUP(npages * sizeof(struct PageInfo), PGSIZE), PADDR(pages), PTE_U | PTE_P);
=> 0xf0100899 <mem_init+249>:	pop    %ebx
0xf0100899	159		boot_map_region(kern_pgdir, UPAGES, ROUNDUP(npages * sizeof(struct PageInfo), PGSIZE), PADDR(pages), PTE_U | PTE_P);
=> 0xf010089a <mem_init+250>:	lea    0xfff(,%eax,8),%ecx
0xf010089a	159		boot_map_region(kern_pgdir, UPAGES, ROUNDUP(npages * sizeof(struct PageInfo), PGSIZE), PADDR(pages), PTE_U | PTE_P);
=> 0xf01008a1 <mem_init+257>:	mov    0xf0329248,%eax
0xf01008a1	159		boot_map_region(kern_pgdir, UPAGES, ROUNDUP(npages * sizeof(struct PageInfo), PGSIZE), PADDR(pages), PTE_U | PTE_P);
=> 0xf01008a6 <mem_init+262>:	push   $0x5
0xf01008a6	159		boot_map_region(kern_pgdir, UPAGES, ROUNDUP(npages * sizeof(struct PageInfo), PGSIZE), PADDR(pages), PTE_U | PTE_P);
=> 0xf01008a8 <mem_init+264>:	mov    $0xef000000,%edx
0xf01008a8	159		boot_map_region(kern_pgdir, UPAGES, ROUNDUP(npages * sizeof(struct PageInfo), PGSIZE), PADDR(pages), PTE_U | PTE_P);
=> 0xf01008ad <mem_init+269>:	and    $0xfffff000,%ecx
0xf01008ad	159		boot_map_region(kern_pgdir, UPAGES, ROUNDUP(npages * sizeof(struct PageInfo), PGSIZE), PADDR(pages), PTE_U | PTE_P);
=> 0xf01008b3 <mem_init+275>:	add    $0x10000000,%eax
0xf01008b3	159		boot_map_region(kern_pgdir, UPAGES, ROUNDUP(npages * sizeof(struct PageInfo), PGSIZE), PADDR(pages), PTE_U | PTE_P);
=> 0xf01008b8 <mem_init+280>:	push   %eax
0xf01008b8	159		boot_map_region(kern_pgdir, UPAGES, ROUNDUP(npages * sizeof(struct PageInfo), PGSIZE), PADDR(pages), PTE_U | PTE_P);
=> 0xf01008b9 <mem_init+281>:	mov    0xf0329244,%eax
0xf01008b9	159		boot_map_region(kern_pgdir, UPAGES, ROUNDUP(npages * sizeof(struct PageInfo), PGSIZE), PADDR(pages), PTE_U | PTE_P);
=> 0xf01008be <mem_init+286>:	call   0xf010074e <boot_map_region>
0xf01008be	159		boot_map_region(kern_pgdir, UPAGES, ROUNDUP(npages * sizeof(struct PageInfo), PGSIZE), PADDR(pages), PTE_U | PTE_P);
=> 0xf010074e <boot_map_region>:	push   %ebp
boot_map_region (pgdir=0xf032a000, va=va@entry=0xef000000, size=0x4000, pa=0x32b000, perm=0x5) at pmap.c:335
335	{
=> 0xf010074f <boot_map_region+1>:	mov    %esp,%ebp
0xf010074f	335	{
=> 0xf0100751 <boot_map_region+3>:	push   %edi
0xf0100751	335	{
=> 0xf0100752 <boot_map_region+4>:	push   %esi
0xf0100752	335	{
=> 0xf0100753 <boot_map_region+5>:	push   %ebx
0xf0100753	335	{
=> 0xf0100754 <boot_map_region+6>:	mov    %eax,%edi
0xf0100754	335	{
=> 0xf0100756 <boot_map_region+8>:	mov    %ecx,%esi
0xf0100756	335	{
=> 0xf0100758 <boot_map_region+10>:	xor    %ebx,%ebx
338		for(i = 0; i < size; i += PGSIZE)
=> 0xf010075a <boot_map_region+12>:	sub    $0x1c,%esp
335	{
=> 0xf010075d <boot_map_region+15>:	mov    0xc(%ebp),%eax
341			*temp_pte = PTE_ADDR(pa + i) | perm | PTE_P;
=> 0xf0100760 <boot_map_region+18>:	or     $0x1,%eax
0xf0100760	341			*temp_pte = PTE_ADDR(pa + i) | perm | PTE_P;
=> 0xf0100763 <boot_map_region+21>:	mov    %eax,-0x1c(%ebp)
0xf0100763	341			*temp_pte = PTE_ADDR(pa + i) | perm | PTE_P;
=> 0xf0100766 <boot_map_region+24>:	cmp    %esi,%ebx
338		for(i = 0; i < size; i += PGSIZE)
=> 0xf0100768 <boot_map_region+26>:	jae    0xf0100798 <boot_map_region+74>
0xf0100768	338		for(i = 0; i < size; i += PGSIZE)
=> 0xf010076a <boot_map_region+28>:	push   %eax
340			pte_t * temp_pte = pgdir_walk(pgdir, (void *)(va + i), 1);
=> 0xf010076b <boot_map_region+29>:	lea    (%ebx,%edx,1),%eax
0xf010076b	340			pte_t * temp_pte = pgdir_walk(pgdir, (void *)(va + i), 1);
=> 0xf010076e <boot_map_region+32>:	push   $0x1
0xf010076e	340			pte_t * temp_pte = pgdir_walk(pgdir, (void *)(va + i), 1);
=> 0xf0100770 <boot_map_region+34>:	mov    %edx,-0x20(%ebp)
0xf0100770	340			pte_t * temp_pte = pgdir_walk(pgdir, (void *)(va + i), 1);
=> 0xf0100773 <boot_map_region+37>:	push   %eax
0xf0100773	340			pte_t * temp_pte = pgdir_walk(pgdir, (void *)(va + i), 1);
=> 0xf0100774 <boot_map_region+38>:	push   %edi
0xf0100774	340			pte_t * temp_pte = pgdir_walk(pgdir, (void *)(va + i), 1);
=> 0xf0100775 <boot_map_region+39>:	call   0xf01006e3 <pgdir_walk>
0xf0100775	340			pte_t * temp_pte = pgdir_walk(pgdir, (void *)(va + i), 1);
=> 0xf01006e3 <pgdir_walk>:	push   %ebp
pgdir_walk (pgdir=0xf032a000, va=0xef000000, create=0x1) at pmap.c:298
298	{
=> 0xf01006e4 <pgdir_walk+1>:	mov    %esp,%ebp
0xf01006e4	298	{
=> 0xf01006e6 <pgdir_walk+3>:	push   %ebx
0xf01006e6	298	{
=> 0xf01006e7 <pgdir_walk+4>:	push   %eax
0xf01006e7	298	{
=> 0xf01006e8 <pgdir_walk+5>:	mov    0xc(%ebp),%ebx
299		pte_t * page_table = (pte_t *)KADDR(PTE_ADDR(pgdir[PDX(va)]));
=> 0xf01006eb <pgdir_walk+8>:	mov    0x8(%ebp),%edx
0xf01006eb	299		pte_t * page_table = (pte_t *)KADDR(PTE_ADDR(pgdir[PDX(va)]));
=> 0xf01006ee <pgdir_walk+11>:	shr    $0x16,%ebx
0xf01006ee	299		pte_t * page_table = (pte_t *)KADDR(PTE_ADDR(pgdir[PDX(va)]));
=> 0xf01006f1 <pgdir_walk+14>:	lea    (%edx,%ebx,4),%ebx
0xf01006f1	299		pte_t * page_table = (pte_t *)KADDR(PTE_ADDR(pgdir[PDX(va)]));
=> 0xf01006f4 <pgdir_walk+17>:	mov    (%ebx),%edx
0xf01006f4	299		pte_t * page_table = (pte_t *)KADDR(PTE_ADDR(pgdir[PDX(va)]));
=> 0xf01006f6 <pgdir_walk+19>:	test   %edx,%edx
301		if(!pgdir[PDX(va)])	//the relevant page table page not exist
=> 0xf01006f8 <pgdir_walk+21>:	jne    0xf0100730 <pgdir_walk+77>
0xf01006f8	301		if(!pgdir[PDX(va)])	//the relevant page table page not exist
=> 0xf01006fa <pgdir_walk+23>:	cmpl   $0x0,0x10(%ebp)
303			if(!create)	// not create a new page table page
=> 0xf01006fe <pgdir_walk+27>:	jne    0xf0100704 <pgdir_walk+33>
0xf01006fe	303			if(!create)	// not create a new page table page
=> 0xf0100704 <pgdir_walk+33>:	sub    $0xc,%esp
307			struct PageInfo * new_page_table_page = page_alloc(1);
=> 0xf0100707 <pgdir_walk+36>:	push   $0x1
0xf0100707	307			struct PageInfo * new_page_table_page = page_alloc(1);
=> 0xf0100709 <pgdir_walk+38>:	call   0xf010063f <page_alloc>
0xf0100709	307			struct PageInfo * new_page_table_page = page_alloc(1);
=> 0xf010063f <page_alloc>:	push   %ebp
page_alloc (alloc_flags=0x1) at pmap.c:244
244	{
=> 0xf0100640 <page_alloc+1>:	mov    %esp,%ebp
0xf0100640	244	{
=> 0xf0100642 <page_alloc+3>:	push   %ebx
0xf0100642	244	{
=> 0xf0100643 <page_alloc+4>:	push   %edx
0xf0100643	244	{
=> 0xf0100644 <page_alloc+5>:	mov    0xf032857c,%ebx
245		if(!page_free_list)	// out of free memory
=> 0xf010064a <page_alloc+11>:	test   %ebx,%ebx
0xf010064a	245		if(!page_free_list)	// out of free memory
=> 0xf010064c <page_alloc+13>:	je     0xf0100685 <page_alloc+70>
0xf010064c	245		if(!page_free_list)	// out of free memory
=> 0xf010064e <page_alloc+15>:	testb  $0x1,0x8(%ebp)
252		if(alloc_flags & ALLOC_ZERO)
=> 0xf0100652 <page_alloc+19>:	mov    (%ebx),%eax
249		page_free_list = page_free_list->pp_link;
=> 0xf0100654 <page_alloc+21>:	movl   $0x0,(%ebx)
250		temp->pp_link = NULL;
=> 0xf010065a <page_alloc+27>:	mov    %eax,0xf032857c
249		page_free_list = page_free_list->pp_link;
=> 0xf010065f <page_alloc+32>:	je     0xf0100685 <page_alloc+70>
252		if(alloc_flags & ALLOC_ZERO)
=> 0xf0100661 <page_alloc+34>:	push   %eax
253			memset(page2kva(temp), 0, PGSIZE);
=> 0xf0100662 <page_alloc+35>:	mov    %ebx,%eax
0xf0100662	253			memset(page2kva(temp), 0, PGSIZE);
=> 0xf0100664 <page_alloc+37>:	sub    0xf0329248,%eax
0xf0100664	253			memset(page2kva(temp), 0, PGSIZE);
=> 0xf010066a <page_alloc+43>:	push   $0x1000
0xf010066a	253			memset(page2kva(temp), 0, PGSIZE);
=> 0xf010066f <page_alloc+48>:	push   $0x0
0xf010066f	253			memset(page2kva(temp), 0, PGSIZE);
=> 0xf0100671 <page_alloc+50>:	sar    $0x3,%eax
0xf0100671	253			memset(page2kva(temp), 0, PGSIZE);
=> 0xf0100674 <page_alloc+53>:	shl    $0xc,%eax
0xf0100674	253			memset(page2kva(temp), 0, PGSIZE);
=> 0xf0100677 <page_alloc+56>:	sub    $0x10000000,%eax
0xf0100677	253			memset(page2kva(temp), 0, PGSIZE);
=> 0xf010067c <page_alloc+61>:	push   %eax
0xf010067c	253			memset(page2kva(temp), 0, PGSIZE);
=> 0xf010067d <page_alloc+62>:	call   0xf01028ee <memset>
0xf010067d	253			memset(page2kva(temp), 0, PGSIZE);
=> 0xf01028ee <memset>:	push   %ebp
memset (v=0xf07ff000, c=0x0, n=0x1000) at string.c:117
117	{
=> 0xf01028ef <memset+1>:	mov    %esp,%ebp
0xf01028ef	117	{
=> 0xf01028f1 <memset+3>:	push   %edi
0xf01028f1	117	{
=> 0xf01028f2 <memset+4>:	push   %esi
0xf01028f2	117	{
=> 0xf01028f3 <memset+5>:	push   %ebx
0xf01028f3	117	{
=> 0xf01028f4 <memset+6>:	mov    0x8(%ebp),%edi
0xf01028f4	117	{
=> 0xf01028f7 <memset+9>:	mov    0x10(%ebp),%ecx
0xf01028f7	117	{
=> 0xf01028fa <memset+12>:	test   %ecx,%ecx
119		if (n == 0)
=> 0xf01028fc <memset+14>:	je     0xf0102934 <memset+70>
0xf01028fc	119		if (n == 0)
=> 0xf01028fe <memset+16>:	test   $0x3,%edi
121		if ((int)v%4 == 0 && n%4 == 0) {
=> 0xf0102904 <memset+22>:	jne    0xf010292e <memset+64>
0xf0102904	121		if ((int)v%4 == 0 && n%4 == 0) {
=> 0xf0102906 <memset+24>:	test   $0x3,%cl
0xf0102906	121		if ((int)v%4 == 0 && n%4 == 0) {
=> 0xf0102909 <memset+27>:	jne    0xf010292e <memset+64>
0xf0102909	121		if ((int)v%4 == 0 && n%4 == 0) {
=> 0xf010290b <memset+29>:	movzbl 0xc(%ebp),%edx
122			c &= 0xFF;
=> 0xf010290f <memset+33>:	mov    %edx,%ebx
123			c = (c<<24)|(c<<16)|(c<<8)|c;
=> 0xf0102911 <memset+35>:	shl    $0x8,%ebx
0xf0102911	123			c = (c<<24)|(c<<16)|(c<<8)|c;
=> 0xf0102914 <memset+38>:	mov    %edx,%esi
0xf0102914	123			c = (c<<24)|(c<<16)|(c<<8)|c;
=> 0xf0102916 <memset+40>:	shl    $0x18,%esi
0xf0102916	123			c = (c<<24)|(c<<16)|(c<<8)|c;
=> 0xf0102919 <memset+43>:	mov    %edx,%eax
0xf0102919	123			c = (c<<24)|(c<<16)|(c<<8)|c;
=> 0xf010291b <memset+45>:	shl    $0x10,%eax
0xf010291b	123			c = (c<<24)|(c<<16)|(c<<8)|c;
=> 0xf010291e <memset+48>:	or     %esi,%eax
0xf010291e	123			c = (c<<24)|(c<<16)|(c<<8)|c;
=> 0xf0102920 <memset+50>:	or     %eax,%edx
0xf0102920	123			c = (c<<24)|(c<<16)|(c<<8)|c;
=> 0xf0102922 <memset+52>:	mov    %ebx,%eax
124			asm volatile("cld; rep stosl\n"
=> 0xf0102924 <memset+54>:	or     %edx,%eax
0xf0102924	124			asm volatile("cld; rep stosl\n"
=> 0xf0102926 <memset+56>:	shr    $0x2,%ecx
0xf0102926	124			asm volatile("cld; rep stosl\n"
=> 0xf0102929 <memset+59>:	cld    
0xf0102929	124			asm volatile("cld; rep stosl\n"
=> 0xf010292a <memset+60>:	rep stos %eax,%es:(%edi)
0xf010292a	124			asm volatile("cld; rep stosl\n"
The target architecture is assumed to be i8086
[f000:e05b]    0x15805b:	add    %al,(%bx,%si)
0x0000e05b in ?? ()
[f000:e062]    0x158062:	add    %al,(%bx,%si)
0x0000e062 in ?? ()
eax            0x0	0x0
ecx            0x0	0x0
edx            0x663	0x663
ebx            0x0	0x0
esp            0x0	0x0
ebp            0x0	0x0
esi            0x0	0x0
edi            0x0	0x0
eip            0xe062	0xe062
eflags         0x2	[ ]
cs             0xf000	0xf000
ss             0x0	0x0
ds             0x0	0x0
es             0x0	0x0
fs             0x0	0x0
gs             0x0	0x0
[34m--------------------------------------------------------------------------[34m[1m[regs]
[0m  [32mEAX:[30m 0x00000000  [32mEBX:[30m 0x00000000  [32mECX:[30m 0x00000000  [32mEDX:[31m 0x00000663  [1m[4m[31mo d i t s z a p c 
[0m  [32mESI:[30m 0x00000000  [32mEDI:[30m 0x00000000  [32mEBP:[30m 0x00000000  [32mESP:[30m 0x00000000  [32mEIP:[31m 0x0000E062
  [32mCS:[30m F000  [32mDS:[30m 0000  [32mES:[30m 0000  [32mFS:[30m 0000  [32mGS:[30m 0000  [32mSS:[30m 0000[0m
[36m[34m[0x0000:0x00000000][34m------------------------------------------------------[34m[1m[stack]
[0m[1m0x00000050 : [0m39 E7 00 F0 59 F8 00 F0[1m - [0m2E E8 00 F0 D2 EF 00 F0 [1m9...Y...........[0m
[1m0x00000040 : [0m26 55 00 C0 4D F8 00 F0[1m - [0m41 F8 00 F0 FE E3 00 F0 [1m&U..M...A.......[0m
[1m0x00000030 : [0m2C D6 00 F0 2C D6 00 F0[1m - [0m57 EF 00 F0 2C D6 00 F0 [1m,...,...W...,...[0m
[1m0x00000020 : [0mA5 FE 00 F0 87 E9 00 F0[1m - [0m2C D6 00 F0 2C D6 00 F0 [1m........,...,...[0m
[1m0x00000010 : [0m53 FF 00 F0 53 FF 00 F0[1m - [0m53 FF 00 F0 53 FF 00 F0 [1mS...S...S...S...[0m
[1m0x00000000 : [0m53 FF 00 F0 53 FF 00 F0[1m - [0mC3 E2 00 F0 53 FF 00 F0 [1mS...S.......S...[0m
[0m[34m[0x0000:0x00000000][34m-------------------------------------------------------[1m[34m[data]
[0m[1m0x00000000 : [0m53 FF 00 F0 53 FF 00 F0[1m - [0mC3 E2 00 F0 53 FF 00 F0 [1mS...S.......S...[0m
[1m0x00000010 : [0m53 FF 00 F0 53 FF 00 F0[1m - [0m53 FF 00 F0 53 FF 00 F0 [1mS...S...S...S...[0m
[1m0x00000020 : [0mA5 FE 00 F0 87 E9 00 F0[1m - [0m2C D6 00 F0 2C D6 00 F0 [1m........,...,...[0m
[1m0x00000030 : [0m2C D6 00 F0 2C D6 00 F0[1m - [0m57 EF 00 F0 2C D6 00 F0 [1m,...,...W...,...[0m
[1m0x00000040 : [0m26 55 00 C0 4D F8 00 F0[1m - [0m41 F8 00 F0 FE E3 00 F0 [1m&U..M...A.......[0m
[1m0x00000050 : [0m39 E7 00 F0 59 F8 00 F0[1m - [0m2E E8 00 F0 D2 EF 00 F0 [1m9...Y...........[0m
[1m0x00000060 : [0m48 D6 00 F0 F2 E6 00 F0[1m - [0m6E FE 00 F0 53 FF 00 F0 [1mH.......n...S...[0m
[1m0x00000070 : [0m53 FF 00 F0 53 FF 00 F0[1m - [0mA4 6A 00 F0 30 89 00 C0 [1mS...S....j..0...[0m
[34m--------------------------------------------------------------------------[34m[1m[code]
[0m=> 0xe062:	add    %al,(%bx,%si)
   0xe064:	add    %al,(%bx,%si)
   0xe066:	add    %al,(%bx,%si)
   0xe068:	add    %al,(%bx,%si)
   0xe06a:	add    %al,(%bx,%si)
   0xe06c:	add    %al,(%bx,%si)
   0xe06e:	add    %al,(%bx,%si)
   0xe070:	add    %al,(%bx,%si)
[34m--------------------------------------------------------------------------------
[0mInvalid register `cr3'
Invalid register `lcr3'
Undefined info command: "cr3".  Try "help info".
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Breakpoint 1 at 0xf0100893: file pmap.c, line 159.
Continuing.
The target architecture is assumed to be i386
=> 0xf0100893 <mem_init+243>:	mov    0xf0329240,%eax

Breakpoint 1, mem_init () at pmap.c:159
159		boot_map_region(kern_pgdir, UPAGES, ROUNDUP(npages * sizeof(struct PageInfo), PGSIZE), PADDR(pages), PTE_U | PTE_P);
=> 0xf0100758 <boot_map_region+10>:	xor    %ebx,%ebx
boot_map_region (pgdir=0xf032a000, va=va@entry=0xef000000, size=0x4000, pa=0x32b000, perm=0x5) at pmap.c:338
338		for(i = 0; i < size; i += PGSIZE)
=> 0xf010075a <boot_map_region+12>:	sub    $0x1c,%esp
335	{
=> 0xf010075d <boot_map_region+15>:	mov    0xc(%ebp),%eax
341			*temp_pte = PTE_ADDR(pa + i) | perm | PTE_P;
=> 0xf0100766 <boot_map_region+24>:	cmp    %esi,%ebx
338		for(i = 0; i < size; i += PGSIZE)
=> 0xf010076a <boot_map_region+28>:	push   %eax
340			pte_t * temp_pte = pgdir_walk(pgdir, (void *)(va + i), 1);
=> 0xf01006e8 <pgdir_walk+5>:	mov    0xc(%ebp),%ebx
pgdir_walk (pgdir=0xf032a000, va=0xef000000, create=0x1) at pmap.c:299
299		pte_t * page_table = (pte_t *)KADDR(PTE_ADDR(pgdir[PDX(va)]));
=> 0xf01006f6 <pgdir_walk+19>:	test   %edx,%edx
301		if(!pgdir[PDX(va)])	//the relevant page table page not exist
=> 0xf01006fa <pgdir_walk+23>:	cmpl   $0x0,0x10(%ebp)
303			if(!create)	// not create a new page table page
=> 0xf0100704 <pgdir_walk+33>:	sub    $0xc,%esp
307			struct PageInfo * new_page_table_page = page_alloc(1);
=> 0xf0100644 <page_alloc+5>:	mov    0xf032857c,%ebx
page_alloc (alloc_flags=0x1) at pmap.c:245
245		if(!page_free_list)	// out of free memory
=> 0xf010064e <page_alloc+15>:	testb  $0x1,0x8(%ebp)
252		if(alloc_flags & ALLOC_ZERO)
=> 0xf0100652 <page_alloc+19>:	mov    (%ebx),%eax
249		page_free_list = page_free_list->pp_link;
=> 0xf0100654 <page_alloc+21>:	movl   $0x0,(%ebx)
250		temp->pp_link = NULL;
=> 0xf010065a <page_alloc+27>:	mov    %eax,0xf032857c
249		page_free_list = page_free_list->pp_link;
=> 0xf010065f <page_alloc+32>:	je     0xf0100685 <page_alloc+70>
252		if(alloc_flags & ALLOC_ZERO)
=> 0xf0100661 <page_alloc+34>:	push   %eax
253			memset(page2kva(temp), 0, PGSIZE);
=> 0xf0100662 <page_alloc+35>:	mov    %ebx,%eax
0xf0100662	253			memset(page2kva(temp), 0, PGSIZE);
=> 0xf0100664 <page_alloc+37>:	sub    0xf0329248,%eax
0xf0100664	253			memset(page2kva(temp), 0, PGSIZE);
=> 0xf010066a <page_alloc+43>:	push   $0x1000
0xf010066a	253			memset(page2kva(temp), 0, PGSIZE);
=> 0xf010066f <page_alloc+48>:	push   $0x0
0xf010066f	253			memset(page2kva(temp), 0, PGSIZE);
=> 0xf0100671 <page_alloc+50>:	sar    $0x3,%eax
0xf0100671	253			memset(page2kva(temp), 0, PGSIZE);
248		struct PageInfo * temp = page_free_list;
249		page_free_list = page_free_list->pp_link;
250		temp->pp_link = NULL;
251	
252		if(alloc_flags & ALLOC_ZERO)
253			memset(page2kva(temp), 0, PGSIZE);
254	
255		return temp;
256	}
257	
warning: bad breakpoint number at or near 'temp'
warning: bad breakpoint number at or near 'alloc_flag'
No symbol "alloc_flag" in current context.
No function contains specified address.
Ambiguous command "in temp": inf, inferior, info, init, init-if-undefined, inspect, int3, intelsyntax, internals...
$1 = (struct PageInfo *) 0xf032eff8
Cannot access memory at address 0xf010c00
$2 = 0x10d021
$3 = 0x3000080
$4 = 0x90030000
$5 = 0x900300
$6 = 0x9003
$7 = 0x3000080
$8 = 0xf010d021
0xf010d021 <entry_pgtable+33>:	0x03000080
0xf010d021 <entry_pgtable+33>:	0x03000080	0x03000090	0x030000a0	0x030000b0
0xf010d031 <entry_pgtable+49>:	0x030000c0	0x030000d0	0x030000e0	0x030000f0
0xf010d041 <entry_pgtable+65>:	0x03000100	0x03000110	0x03000120	0x03000130
0xf010d051 <entry_pgtable+81>:	0x03000140	0x03000150	0x03000160	0x03000170
0xf010d061 <entry_pgtable+97>:	0x03000180	0x03000190	0x030001a0	0x030001b0
0xf010c00:	Cannot access memory at address 0xf010c00
0xf010c000 <entry_pgdir>:	0x0010d021
0xf010c000 <entry_pgdir>:	0x0010d021	0x00000000	0x00000000	0x00000000
0xf010c010 <entry_pgdir+16>:	0x00000000	0x00000000	0x00000000	0x00000000
0xf010c020 <entry_pgdir+32>:	0x00000000	0x00000000	0x00000000	0x00000000
0xf010c030 <entry_pgdir+48>:	0x00000000	0x00000000	0x00000000	0x00000000
0xf010c040 <entry_pgdir+64>:	0x00000000	0x00000000	0x00000000	0x00000000
0xf01102d1:	0x00000000	0x00000000	0x00000000	0x00000000
0xf01102e1:	0x00000000	0x00000000	0x00000000	0x00000000
0xf01102f1:	0x00000000	0x00000000	0x00000000	0x00000000
0xf0110301:	0x00000000	0x00000000	0x00000000	0x00000000
0xf0110311:	0x00000000	0x00000000	0x00000000	0x00000000
No symbol "entry_gptable" in current context.
0xf010d000 <entry_pgtable>:	0x00000003	0x00001003	0x00002003	0x00003003
0xf010d010 <entry_pgtable+16>:	0x00004003	0x00005003	0x00006003	0x00007003
0xf010d020 <entry_pgtable+32>:	0x00008003	0x00009003	0x0000a003	0x0000b003
0xf010d030 <entry_pgtable+48>:	0x0000c003	0x0000d003	0x0000e003	0x0000f003
0xf010d040 <entry_pgtable+64>:	0x00010003	0x00011003	0x00012003	0x00013003
0xf01102b0:	0x00000000	0x00000000	0x00000000	0x00000000
0xf01102c0:	0x00000000	0x00000000	0x00000000	0x00000000
0xf01102d0:	0x00000000	0x00000000	0x00000000	0x00000000
0xf01102e0:	0x00000000	0x00000000	0x00000000	0x00000000
0xf01102f0:	0x00000000	0x00000000	0x00000000	0x00000000
0xf0119ac0:	0x00000000	0x00000000	0x00000000	0x00000000
0xf0119ad0:	0x00000000	0x00000000	0x00000000	0x00000000
0xf0119ae0:	0x00000000	0x00000000	0x00000000	0x00000000
0xf0119af0:	0x00000000	0x00000000	0x00000000	0x00000000
0xf0119b00:	0x00000000	0x00000000	0x00000000	0x00000000
0xf010dcac <entry_pgtable+3244>:	0x0032b063	0x0032c063	0x0032d063	0x0032e063
0xf010dcbc <entry_pgtable+3260>:	0x0032f003	0x00330003	0x00331003	0x00332003
0xf010dccc <entry_pgtable+3276>:	0x00333003	0x00334003	0x00335003	0x00336003
0xf010dcdc <entry_pgtable+3292>:	0x00337003	0x00338003	0x00339003	0x0033a003
0xf010dcec <entry_pgtable+3308>:	0x0033b003	0x0033c003	0x0033d003	0x0033e003
0xf010d010 <entry_pgtable+16>:	0x00004003	0x00005003	0x00006003	0x00007003
0xf010d020 <entry_pgtable+32>:	0x00008003	0x00009003	0x0000a003	0x0000b003
0xf010d030 <entry_pgtable+48>:	0x0000c003	0x0000d003	0x0000e003	0x0000f003
0xf010d040 <entry_pgtable+64>:	0x00010003	0x00011003	0x00012003	0x00013003
0xf010d050 <entry_pgtable+80>:	0x00014003	0x00015003	0x00016003	0x00017003
0xf010dcac <entry_pgtable+3244>:	0x0032b063	0x0032c063	0x0032d063	0x0032e063
0xf010dcbc <entry_pgtable+3260>:	0x0032f003	0x00330003	0x00331003	0x00332003
0xf010dccc <entry_pgtable+3276>:	0x00333003	0x00334003	0x00335003	0x00336003
0xf010dcdc <entry_pgtable+3292>:	0x00337003	0x00338003	0x00339003	0x0033a003
0xf010dcec <entry_pgtable+3308>:	0x0033b003	0x0033c003	0x0033d003	0x0033e003
258	//
259	// Return a page to the free list.
260	// (This function should only be called when pp->pp_ref reaches 0.)
261	//
262	void
263	page_free(struct PageInfo *pp)
264	{
265		if(pp->pp_ref)
266			panic("page_free : pp->pp_ref is nonzero!");
267		if(pp->pp_link)
=> 0xf0100674 <page_alloc+53>:	shl    $0xc,%eax
0xf0100674	253			memset(page2kva(temp), 0, PGSIZE);
=> 0xf0100677 <page_alloc+56>:	sub    $0x10000000,%eax
0xf0100677	253			memset(page2kva(temp), 0, PGSIZE);
=> 0xf010067c <page_alloc+61>:	push   %eax
0xf010067c	253			memset(page2kva(temp), 0, PGSIZE);
=> 0xf010067d <page_alloc+62>:	call   0xf01028ee <memset>
0xf010067d	253			memset(page2kva(temp), 0, PGSIZE);
=> 0xf01028ee <memset>:	push   %ebp
memset (v=0xf07ff000, c=0x0, n=0x1000) at string.c:117
117	{
=> 0xf01028ef <memset+1>:	mov    %esp,%ebp
0xf01028ef	117	{
=> 0xf01028f1 <memset+3>:	push   %edi
0xf01028f1	117	{
=> 0xf01028f2 <memset+4>:	push   %esi
0xf01028f2	117	{
=> 0xf01028f3 <memset+5>:	push   %ebx
0xf01028f3	117	{
=> 0xf01028f4 <memset+6>:	mov    0x8(%ebp),%edi
0xf01028f4	117	{
=> 0xf01028f7 <memset+9>:	mov    0x10(%ebp),%ecx
0xf01028f7	117	{
=> 0xf01028fa <memset+12>:	test   %ecx,%ecx
119		if (n == 0)
=> 0xf01028fc <memset+14>:	je     0xf0102934 <memset+70>
0xf01028fc	119		if (n == 0)
=> 0xf01028fe <memset+16>:	test   $0x3,%edi
121		if ((int)v%4 == 0 && n%4 == 0) {
=> 0xf0102904 <memset+22>:	jne    0xf010292e <memset+64>
0xf0102904	121		if ((int)v%4 == 0 && n%4 == 0) {
=> 0xf0102906 <memset+24>:	test   $0x3,%cl
0xf0102906	121		if ((int)v%4 == 0 && n%4 == 0) {
=> 0xf0102909 <memset+27>:	jne    0xf010292e <memset+64>
0xf0102909	121		if ((int)v%4 == 0 && n%4 == 0) {
=> 0xf010290b <memset+29>:	movzbl 0xc(%ebp),%edx
122			c &= 0xFF;
$9 = 0x0
$10 = (void *) 0xf07ff000
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Breakpoint 1 at 0xf0100893: file pmap.c, line 159.
Continuing.
The target architecture is assumed to be i386
=> 0xf0100893 <mem_init+243>:	mov    0xf0329240,%eax

Breakpoint 1, mem_init () at pmap.c:159
159		boot_map_region(kern_pgdir, UPAGES, ROUNDUP(npages * sizeof(struct PageInfo), PGSIZE), PADDR(pages), PTE_U | PTE_P);
=> 0xf0100898 <mem_init+248>:	pop    %edx
0xf0100898	159		boot_map_region(kern_pgdir, UPAGES, ROUNDUP(npages * sizeof(struct PageInfo), PGSIZE), PADDR(pages), PTE_U | PTE_P);
=> 0xf0100899 <mem_init+249>:	pop    %ebx
0xf0100899	159		boot_map_region(kern_pgdir, UPAGES, ROUNDUP(npages * sizeof(struct PageInfo), PGSIZE), PADDR(pages), PTE_U | PTE_P);
=> 0xf010089a <mem_init+250>:	lea    0xfff(,%eax,8),%ecx
0xf010089a	159		boot_map_region(kern_pgdir, UPAGES, ROUNDUP(npages * sizeof(struct PageInfo), PGSIZE), PADDR(pages), PTE_U | PTE_P);
=> 0xf01008a1 <mem_init+257>:	mov    0xf0329248,%eax
0xf01008a1	159		boot_map_region(kern_pgdir, UPAGES, ROUNDUP(npages * sizeof(struct PageInfo), PGSIZE), PADDR(pages), PTE_U | PTE_P);
=> 0xf01008a6 <mem_init+262>:	push   $0x5
0xf01008a6	159		boot_map_region(kern_pgdir, UPAGES, ROUNDUP(npages * sizeof(struct PageInfo), PGSIZE), PADDR(pages), PTE_U | PTE_P);
=> 0xf0100758 <boot_map_region+10>:	xor    %ebx,%ebx
boot_map_region (pgdir=0xf032a000, va=va@entry=0xef000000, size=0x4000, pa=0x32b000, perm=0x5) at pmap.c:338
338		for(i = 0; i < size; i += PGSIZE)
=> 0xf010075a <boot_map_region+12>:	sub    $0x1c,%esp
335	{
=> 0xf010075d <boot_map_region+15>:	mov    0xc(%ebp),%eax
341			*temp_pte = PTE_ADDR(pa + i) | perm | PTE_P;
=> 0xf0100766 <boot_map_region+24>:	cmp    %esi,%ebx
338		for(i = 0; i < size; i += PGSIZE)
=> 0xf010076a <boot_map_region+28>:	push   %eax
340			pte_t * temp_pte = pgdir_walk(pgdir, (void *)(va + i), 1);
=> 0xf01006e8 <pgdir_walk+5>:	mov    0xc(%ebp),%ebx
pgdir_walk (pgdir=0xf032a000, va=0xef000000, create=0x1) at pmap.c:299
299		pte_t * page_table = (pte_t *)KADDR(PTE_ADDR(pgdir[PDX(va)]));
=> 0xf01006f6 <pgdir_walk+19>:	test   %edx,%edx
301		if(!pgdir[PDX(va)])	//the relevant page table page not exist
=> 0xf01006fa <pgdir_walk+23>:	cmpl   $0x0,0x10(%ebp)
303			if(!create)	// not create a new page table page
=> 0xf0100704 <pgdir_walk+33>:	sub    $0xc,%esp
307			struct PageInfo * new_page_table_page = page_alloc(1);
=> 0xf0100644 <page_alloc+5>:	mov    0xf032857c,%ebx
page_alloc (alloc_flags=0x1) at pmap.c:245
245		if(!page_free_list)	// out of free memory
=> 0xf010064a <page_alloc+11>:	test   %ebx,%ebx
0xf010064a	245		if(!page_free_list)	// out of free memory
=> 0xf010064c <page_alloc+13>:	je     0xf0100685 <page_alloc+70>
0xf010064c	245		if(!page_free_list)	// out of free memory
=> 0xf010064e <page_alloc+15>:	testb  $0x1,0x8(%ebp)
252		if(alloc_flags & ALLOC_ZERO)
=> 0xf0100652 <page_alloc+19>:	mov    (%ebx),%eax
249		page_free_list = page_free_list->pp_link;
244	{
245		if(!page_free_list)	// out of free memory
246			return NULL;
247	
248		struct PageInfo * temp = page_free_list;
249		page_free_list = page_free_list->pp_link;
250		temp->pp_link = NULL;
251	
252		if(alloc_flags & ALLOC_ZERO)
253			memset(page2kva(temp), 0, PGSIZE);
$1 = (struct PageInfo *) 0xf032eff8
$2 = (struct PageInfo *) 0xf032b000
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Breakpoint 1 at 0xf0101cfd: file env.c, line 396.
Continuing.
The target architecture is assumed to be i386
=> 0xf0101cfd <env_create>:	push   %ebp

Breakpoint 1, env_create (binary=0xf010e390 "\177ELF\001\001\001", type=ENV_TYPE_FS) at env.c:396
396	{
0xf032a000:	0x00000000	0x00000000	0x00000000	0x00000000
0xf032a010:	0x00000000	0x00000000	0x00000000	0x00000000
0xf032a020:	0x00000000	0x00000000	0x00000000	0x00000000
0xf032a030:	0x00000000	0x00000000	0x00000000	0x00000000
0xf032a040:	0x00000000	0x00000000	0x00000000	0x00000000
0x0:	Cannot access memory at address 0x0
0xf032a000:	0x00000000	0x00000000	0x00000000	0x00000000
0xf032a010:	0x00000000	0x00000000	0x00000000	0x00000000
0xf032a020:	0x00000000	0x00000000	0x00000000	0x00000000
0xf032a030:	0x00000000	0x00000000	0x00000000	0x00000000
0xf032a040:	0x00000000	0x00000000	0x00000000	0x00000000
0xf032a32a:	0x00000000	0x00000000	0x00000000	0x00000000
0xf032a33a:	0x00000000	0x00000000	0x00000000	0x00000000
0xf032a34a:	0x00000000	0x00000000	0x00000000	0x00000000
0xf032a35a:	0x00000000	0x00000000	0x00000000	0x00000000
0xf032a36a:	0x00000000	0x00000000	0x00000000	0x00000000
0xf032a001:	0x00000000	0x00000000	0x00000000	0x00000000
0xf032a011:	0x00000000	0x00000000	0x00000000	0x00000000
0xf032a021:	0x00000000	0x00000000	0x00000000	0x00000000
0xf032a031:	0x00000000	0x00000000	0x00000000	0x00000000
0xf032a041:	0x00000000	0x00000000	0x00000000	0x00000000
$1 = 0xf010e390 "\177ELF\001\001\001"
0xf010e390:	0x464c457f	0x00010101	0x00000000	0x00000000
0xf010e3a0:	0x00030002	0x00000001	0x00800020	0x00000034
0xf010e3b0:	0x00219cfc	0x00000000	0x00200034	0x00280003
0xf010e3c0:	0x000f0012	0x00000001	0x00200000	0x00200000
0xf010e3d0:	0x00200000	0x00000012	0x00000012	0x00000006
   0xf010e390:	jg     0xf010e3d7
   0xf010e392:	dec    %esp
   0xf010e393:	inc    %esi
   0xf010e394:	add    %eax,(%ecx)
   0xf010e396:	add    %eax,(%eax)
   0xf010e398:	add    %al,(%eax)
   0xf010e39a:	add    %al,(%eax)
   0xf010e39c:	add    %al,(%eax)
   0xf010e39e:	add    %al,(%eax)
   0xf010e3a0:	add    (%eax),%al
   0xf010e3a2:	add    (%eax),%eax
   0xf010e3a4:	add    %eax,(%eax)
   0xf010e3a6:	add    %al,(%eax)
   0xf010e3a8:	and    %al,(%eax)
   0xf010e3aa:	addb   $0x34,(%eax)
   0xf010e3ad:	add    %al,(%eax)
   0xf010e3af:	add    %bh,%ah
   0xf010e3b1:	pushf  
   0xf010e3b2:	and    %eax,(%eax)
   0xf010e3b4:	add    %al,(%eax)
The address where fs has been loaded is missing
$2 = 0x0
Cannot access memory at address 0x219fcc
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
The address where damnfs has been loaded is missing
Reading symbols from damnfs...(no debugging symbols found)...done.
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Reading symbols from damnfs...done.
Breakpoint 1 at 0x80001da4: file damnfs.c, line 674.
Continuing.
[  1b:80001da4]    0x80001ff6 <ide_write+104>:	test   %bx,%bx

Breakpoint 1, bc_init () at damnfs.c:674
674	{
[  1b:80001daa]    0x80001ffc <ide_write+110>:	add    %al,(%bx,%si)
675		set_pgfault_handler(bc_pgfault);
[  1b:80003037]    0x80003289 <vprintfmt+95>:	in     $0xff,%al
set_pgfault_handler (handler=0x800010a9 <bc_pgfault>) at pgfault.c:28
28		if (_pgfault_handler == 0) {
[  1b:80003040]    0x80003292 <vprintfmt+104>:	add    %bh,0x0(%bp,%di)
30			if((r = sys_page_alloc(0, (void *)(UXSTACKTOP - PGSIZE), PTE_P|PTE_U|PTE_W)) < 0)
[  1b:80002b02]    0x80002d54 <devfile_trunc+31>:	add    (%bx,%si),%al
sys_page_alloc (envid=0x0, va=0xeebff000, perm=0x7) at syscall.c:71
71		return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
[  1b:80002b02]    0x80002d54 <devfile_trunc+31>:	add    (%bx,%si),%al
syscall (a5=0x0, a4=0x0, a3=0x7, a2=0xeebff000, a1=0x0, check=0x1, num=0x4) at syscall.c:21
21		asm volatile("int %1\n"
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Function "ff_init" not defined.
Function "fs_init" not defined.
Function "mem_nit" not defined.
Breakpoint 1 at 0xf0100201: file pmap.c, line 109.
Continuing.
The target architecture is assumed to be i386
=> 0xf0100201 <mem_init>:	push   %ebp

Breakpoint 1, mem_init () at pmap.c:109
109	{
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Reading symbols from damnfs...done.
Breakpoint 1 at 0x80001da4: file damnfs.c, line 674.
Continuing.
[  1b:80001da4]    0x80001ff6 <ide_write+104>:	test   %bx,%bx

Breakpoint 1, bc_init () at damnfs.c:674
674	{
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Reading symbols from damnfs...done.
Breakpoint 1 at 0x80001da4: file damnfs.c, line 674.
Continuing.
[  1b:80001da4]    0x80001ff6 <ide_write+104>:	test   %bx,%bx

Breakpoint 1, bc_init () at damnfs.c:674
674	{
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Breakpoint 1 at 0xf0103391: file env.c, line 115.
Continuing.
The target architecture is assumed to be i386
=> 0xf0103391 <env_init>:	push   %ebp

Breakpoint 1, env_init () at env.c:115
115	{
Reading symbols from damnfs...done.
Error in re-setting breakpoint 1: Function "env_init" not defined.
Breakpoint 2 at 0x80001da4: file damnfs.c, line 674.
Continuing.
The target architecture is assumed to be i8086
[  1b:80001da4]    0x80001ff6 <ide_write+104>:	test   %bx,%bx

Breakpoint 2, bc_init () at damnfs.c:674
674	{
[  1b:80001da5]    0x80001ff7 <ide_write+105>:	(bad)  0x2f(%si)
0x80001da5	674	{
[  1b:80001da7]    0x80001ff9 <ide_write+107>:	das    
0x80001da7	674	{
[  1b:80001daa]    0x80001ffc <ide_write+110>:	add    %al,(%bx,%si)
675		set_pgfault_handler(bc_pgfault);
[  1b:80001daf]    0x80002001 <ide_write+115>:	(bad)  
0x80001daf	675		set_pgfault_handler(bc_pgfault);
[  1b:80003031]    0x80003283 <vprintfmt+89>:	(bad)  
set_pgfault_handler (handler=0x800010a9 <bc_pgfault>) at pgfault.c:25
25	{
[  1b:80003032]    0x80003284 <vprintfmt+90>:	(bad)  
0x80003032	25	{
[  1b:80003034]    0x80003286 <vprintfmt+92>:	inc    %di
0x80003034	25	{
[  1b:80003037]    0x80003289 <vprintfmt+95>:	in     $0xff,%al
28		if (_pgfault_handler == 0) {
[  1b:8000303e]    0x80003290 <vprintfmt+102>:	add    %al,(%bx,%si)
0x8000303e	28		if (_pgfault_handler == 0) {
[  1b:80003040]    0x80003292 <vprintfmt+104>:	add    %bh,0x0(%bp,%di)
30			if((r = sys_page_alloc(0, (void *)(UXSTACKTOP - PGSIZE), PTE_P|PTE_U|PTE_W)) < 0)
[  1b:80003043]    0x80003295 <vprintfmt+107>:	add    %al,(%bx,%si)
0x80003043	30			if((r = sys_page_alloc(0, (void *)(UXSTACKTOP - PGSIZE), PTE_P|PTE_U|PTE_W)) < 0)
[  1b:80003045]    0x80003297 <vprintfmt+109>:	add    %ch,%bl
0x80003045	30			if((r = sys_page_alloc(0, (void *)(UXSTACKTOP - PGSIZE), PTE_P|PTE_U|PTE_W)) < 0)
[  1b:8000304a]    0x8000329c <vprintfmt+114>:	adc    %al,%dh
0x8000304a	30			if((r = sys_page_alloc(0, (void *)(UXSTACKTOP - PGSIZE), PTE_P|PTE_U|PTE_W)) < 0)
[  1b:8000304c]    0x8000329e <vprintfmt+116>:	inc    %bp
0x8000304c	30			if((r = sys_page_alloc(0, (void *)(UXSTACKTOP - PGSIZE), PTE_P|PTE_U|PTE_W)) < 0)
[  1b:80002af9]    0x80002d4b <devfile_trunc+22>:	mov    $0x0,%al
sys_page_alloc (envid=0x0, va=0xeebff000, perm=0x7) at syscall.c:70
70	{
[  1b:80002afa]    0x80002d4c <devfile_trunc+23>:	add    %al,0xba(%bx,%si)
0x80002afa	70	{
[  1b:80002afc]    0x80002d4e <devfile_trunc+25>:	mov    $0x0,%dx
0x80002afc	70	{
[  1b:80002afd]    0x80002d4f <devfile_trunc+26>:	add    %al,(%bx,%si)
0x80002afd	70	{
[  1b:80002afe]    0x80002d50 <devfile_trunc+27>:	add    %al,(%bx,%si)
0x80002afe	70	{
[  1b:80002aff]    0x80002d51 <devfile_trunc+28>:	add    %al,(%bx,%si)
0x80002aff	70	{
[  1b:80002b02]    0x80002d54 <devfile_trunc+31>:	add    (%bx,%si),%al
syscall (a5=0x0, a4=0x0, a3=0x7, a2=0xeebff000, a1=0x0, check=0x1, num=0x4) at syscall.c:21
21		asm volatile("int %1\n"
[  1b:80002b07]    0x80002d59 <devfile_trunc+36>:	(bad)  
0x80002b07	21		asm volatile("int %1\n"
[  1b:80002b0c]    0x80002d5e <devfile_trunc+41>:	ret    
0x80002b0c	21		asm volatile("int %1\n"
[  1b:80002b0f]    0x80002d61 <devfile_flush+2>:	in     $0x83,%ax
0x80002b0f	21		asm volatile("int %1\n"
[  1b:80002b12]    0x80002d64 <devfile_flush+5>:	or     %cl,0x845(%bp,%di)
0x80002b12	21		asm volatile("int %1\n"
[  1b:80002b15]    0x80002d67 <devfile_flush+8>:	or     %cl,0xc40(%bp,%di)
0x80002b15	21		asm volatile("int %1\n"
[  1b:80002b17]    0x80002d69 <devfile_flush+10>:	inc    %ax
0x80002b17	21		asm volatile("int %1\n"
The target architecture is assumed to be i386
=> 0xf0101652:	push   $0x30
0xf0101652 in ?? ()
=> 0xf0101654:	jmp    0xf010165c
0xf0101654 in ?? ()
=> 0xf010165c:	push   %ds
0xf010165c in ?? ()
=> 0xf010165d:	push   %es
0xf010165d in ?? ()
Reading symbols from kernel...done.
Error in re-setting breakpoint 2: Function "bc_init" not defined.
=> 0xf010165e <_alltraps+2>:	pusha  
_alltraps () at trapentry.S:80
80		pushal
=> 0xf010165f <_alltraps+3>:	mov    $0x10,%ax
_alltraps () at trapentry.S:82
82		movw $(GD_KD), %ax
=> 0xf0101663 <_alltraps+7>:	mov    %eax,%ds
83		movw %ax, %ds
=> 0xf0101665 <_alltraps+9>:	mov    %eax,%es
84		movw %ax, %es
=> 0xf0101667 <_alltraps+11>:	push   %esp
86		pushl %esp
=> 0xf0101668 <_alltraps+12>:	call   0xf01025a6 <trap>
_alltraps () at trapentry.S:87
87		call trap
=> 0xf01025a6 <trap>:	push   %ebp
trap (tf=0xefffffbc) at trap.c:260
260	{
=> 0xf01025a7 <trap+1>:	mov    %esp,%ebp
0xf01025a7	260	{
=> 0xf01025a9 <trap+3>:	push   %edi
0xf01025a9	260	{
=> 0xf01025aa <trap+4>:	push   %esi
0xf01025aa	260	{
=> 0xf01025ab <trap+5>:	push   %ebx
0xf01025ab	260	{
=> 0xf01025ac <trap+6>:	sub    $0xc,%esp
0xf01025ac	260	{
=> 0xf01025af <trap+9>:	cld    
263		asm volatile("cld" ::: "cc");
=> 0xf01025b0 <trap+10>:	mov    0x8(%ebp),%eax
266		if ((tf->tf_cs & 3) == 3) {
=> 0xf01025b3 <trap+13>:	movzwl 0x34(%eax),%eax
0xf01025b3	266		if ((tf->tf_cs & 3) == 3) {
=> 0xf01025b7 <trap+17>:	movzwl %ax,%eax
0xf01025b7	266		if ((tf->tf_cs & 3) == 3) {
=> 0xf01025ba <trap+20>:	and    $0x3,%eax
0xf01025ba	266		if ((tf->tf_cs & 3) == 3) {
=> 0xf01025bd <trap+23>:	cmp    $0x3,%eax
0xf01025bd	266		if ((tf->tf_cs & 3) == 3) {
=> 0xf01025c0 <trap+26>:	jne    0xf0102614 <trap+110>
0xf01025c0	266		if ((tf->tf_cs & 3) == 3) {
=> 0xf01025c2 <trap+28>:	call   0xf010166d <lock_kernel>
270			lock_kernel();
=> 0xf010166d <lock_kernel>:	push   %ebp
lock_kernel () at ./spinlock.h:22
22	{
=> 0xf010166e <lock_kernel+1>:	mov    %esp,%ebp
0xf010166e	22	{
=> 0xf0101670 <lock_kernel+3>:	sub    $0x8,%esp
0xf0101670	22	{
=> 0xf0101673 <lock_kernel+6>:	sub    $0xc,%esp
23		spin_lock(&kernel_lock);
=> 0xf0101676 <lock_kernel+9>:	push   $0xf012c46c
0xf0101676	23		spin_lock(&kernel_lock);
=> 0xf010167b <lock_kernel+14>:	call   0xf0103b11 <spin_lock>
0xf010167b	23		spin_lock(&kernel_lock);
=> 0xf0103b11 <spin_lock>:	push   %ebp
spin_lock (lk=0xf012c46c <kernel_lock>) at spinlock.c:23
23	{
=> 0xf0103b12 <spin_lock+1>:	mov    %esp,%ebp
0xf0103b12	23	{
=> 0xf0103b14 <spin_lock+3>:	jmp    0xf0103b18 <spin_lock+7>
28		while (xchg(&lk->locked, 1) != 0)
=> 0xf0103b18 <spin_lock+7>:	mov    0x8(%ebp),%eax
28		while (xchg(&lk->locked, 1) != 0)
=> 0xf0103b1b <spin_lock+10>:	push   $0x1
0xf0103b1b	28		while (xchg(&lk->locked, 1) != 0)
=> 0xf0103b1d <spin_lock+12>:	push   %eax
0xf0103b1d	28		while (xchg(&lk->locked, 1) != 0)
=> 0xf0103b1e <spin_lock+13>:	call   0xf0103ae8 <xchg>
0xf0103b1e	28		while (xchg(&lk->locked, 1) != 0)
=> 0xf0103ae8 <xchg>:	push   %ebp
xchg (addr=0xf012c46c <kernel_lock>, newval=0x1) at ./x86.h:319
319	{
=> 0xf0103ae9 <xchg+1>:	mov    %esp,%ebp
0xf0103ae9	319	{
=> 0xf0103aeb <xchg+3>:	sub    $0x10,%esp
0xf0103aeb	319	{
=> 0xf0103aee <xchg+6>:	mov    0x8(%ebp),%edx
323		asm volatile("lock; xchgl %0, %1" :
=> 0xf0103af1 <xchg+9>:	mov    0xc(%ebp),%eax
0xf0103af1	323		asm volatile("lock; xchgl %0, %1" :
=> 0xf0103af4 <xchg+12>:	mov    0x8(%ebp),%ecx
0xf0103af4	323		asm volatile("lock; xchgl %0, %1" :
=> 0xf0103af7 <xchg+15>:	lock xchg %eax,(%edx)
0xf0103af7	323		asm volatile("lock; xchgl %0, %1" :
=> 0xf0103afa <xchg+18>:	mov    %eax,-0x4(%ebp)
0xf0103afa	323		asm volatile("lock; xchgl %0, %1" :
=> 0xf0103afd <xchg+21>:	mov    -0x4(%ebp),%eax
327		return result;
=> 0xf0103b00 <xchg+24>:	leave  
328	}
=> 0xf0103b01 <xchg+25>:	ret    
0xf0103b01 in xchg (addr=0xf012c46c <kernel_lock>, newval=0x1) at ./x86.h:328
328	}
=> 0xf0103b23 <spin_lock+18>:	add    $0x8,%esp
0xf0103b23 in spin_lock (lk=0xf012c46c <kernel_lock>) at spinlock.c:28
28		while (xchg(&lk->locked, 1) != 0)
=> 0xf0103b26 <spin_lock+21>:	test   %eax,%eax
0xf0103b26	28		while (xchg(&lk->locked, 1) != 0)
=> 0xf0103b28 <spin_lock+23>:	jne    0xf0103b16 <spin_lock+5>
0xf0103b28	28		while (xchg(&lk->locked, 1) != 0)
=> 0xf0103b2a <spin_lock+25>:	nop
30	}
=> 0xf0103b2b <spin_lock+26>:	leave  
0xf0103b2b	30	}
=> 0xf0103b2c <spin_lock+27>:	ret    
0xf0103b2c in spin_lock (lk=0xf012c46c <kernel_lock>) at spinlock.c:30
30	}
=> 0xf0101680 <lock_kernel+19>:	add    $0x10,%esp
0xf0101680 in lock_kernel () at ./spinlock.h:23
23		spin_lock(&kernel_lock);
=> 0xf0101683 <lock_kernel+22>:	nop
24	}
=> 0xf0101684 <lock_kernel+23>:	leave  
0xf0101684	24	}
=> 0xf0101685 <lock_kernel+24>:	ret    
0xf0101685 in lock_kernel () at ./spinlock.h:24
24	}
=> 0xf01025c7 <trap+33>:	mov    0xf012c054,%eax
trap (tf=0xefffffbc) at trap.c:273
273			if (curenv->env_status == ENV_DYING) {
=> 0xf01025cc <trap+38>:	mov    0x54(%eax),%eax
0xf01025cc	273			if (curenv->env_status == ENV_DYING) {
=> 0xf01025cf <trap+41>:	cmp    $0x1,%eax
0xf01025cf	273			if (curenv->env_status == ENV_DYING) {
=> 0xf01025d2 <trap+44>:	jne    0xf01025f4 <trap+78>
0xf01025d2	273			if (curenv->env_status == ENV_DYING) {
=> 0xf01025f4 <trap+78>:	mov    0xf012c054,%edx
282			curenv->env_tf = *tf;
277			}
278	
279			// Copy trap frame (which is currently on the stack)
280			// into 'curenv->env_tf', so that running the environment
281			// will restart at the trap point.
282			curenv->env_tf = *tf;
283			// The trapframe on the stack should be ignored from here on.
284			tf = &curenv->env_tf;
285		}
286		// Record that tf is the last real trapframe so
=> 0xf01025fa <trap+84>:	mov    0x8(%ebp),%eax
0xf01025fa	282			curenv->env_tf = *tf;
=> 0xf01025fd <trap+87>:	mov    %eax,%ebx
0xf01025fd	282			curenv->env_tf = *tf;
=> 0xf01025ff <trap+89>:	mov    $0x11,%eax
0xf01025ff	282			curenv->env_tf = *tf;
=> 0xf0102604 <trap+94>:	mov    %edx,%edi
0xf0102604	282			curenv->env_tf = *tf;
=> 0xf0102606 <trap+96>:	mov    %ebx,%esi
0xf0102606	282			curenv->env_tf = *tf;
=> 0xf0102608 <trap+98>:	mov    %eax,%ecx
0xf0102608	282			curenv->env_tf = *tf;
=> 0xf010260a <trap+100>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a	282			curenv->env_tf = *tf;
=> 0xf010260a <trap+100>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a	282			curenv->env_tf = *tf;
=> 0xf010260a <trap+100>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a	282			curenv->env_tf = *tf;
=> 0xf010260a <trap+100>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a	282			curenv->env_tf = *tf;
=> 0xf010260a <trap+100>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a	282			curenv->env_tf = *tf;
=> 0xf010260a <trap+100>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a	282			curenv->env_tf = *tf;
=> 0xf010260a <trap+100>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a	282			curenv->env_tf = *tf;
=> 0xf010260a <trap+100>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a	282			curenv->env_tf = *tf;
=> 0xf010260a <trap+100>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a	282			curenv->env_tf = *tf;
=> 0xf010260a <trap+100>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a	282			curenv->env_tf = *tf;
=> 0xf010260a <trap+100>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a	282			curenv->env_tf = *tf;
=> 0xf010260a <trap+100>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a	282			curenv->env_tf = *tf;
=> 0xf010260a <trap+100>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a	282			curenv->env_tf = *tf;
=> 0xf010260a <trap+100>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a	282			curenv->env_tf = *tf;
=> 0xf010260a <trap+100>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a	282			curenv->env_tf = *tf;
=> 0xf010260a <trap+100>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a	282			curenv->env_tf = *tf;
=> 0xf010260a <trap+100>:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a	282			curenv->env_tf = *tf;
=> 0xf010260c <trap+102>:	mov    0xf012c054,%eax
284			tf = &curenv->env_tf;
=> 0xf0102611 <trap+107>:	mov    %eax,0x8(%ebp)
0xf0102611	284			tf = &curenv->env_tf;
=> 0xf0102614 <trap+110>:	mov    0x8(%ebp),%eax
288		last_tf = tf;
=> 0xf0102617 <trap+113>:	mov    %eax,0xf012c048
0xf0102617	288		last_tf = tf;
=> 0xf010261c <trap+118>:	sub    $0xc,%esp
291		trap_dispatch(tf);
=> 0xf010261f <trap+121>:	pushl  0x8(%ebp)
0xf010261f	291		trap_dispatch(tf);
=> 0xf0102622 <trap+124>:	call   0xf010244f <trap_dispatch>
0xf0102622	291		trap_dispatch(tf);
=> 0xf010244f <trap_dispatch>:	push   %ebp
trap_dispatch (tf=0xf0132000) at trap.c:191
191	{
=> 0xf0102450 <trap_dispatch+1>:	mov    %esp,%ebp
0xf0102450	191	{
=> 0xf0102452 <trap_dispatch+3>:	push   %edi
0xf0102452	191	{
=> 0xf0102453 <trap_dispatch+4>:	push   %esi
0xf0102453	191	{
=> 0xf0102454 <trap_dispatch+5>:	push   %ebx
0xf0102454	191	{
=> 0xf0102455 <trap_dispatch+6>:	sub    $0x1c,%esp
0xf0102455	191	{
=> 0xf0102458 <trap_dispatch+9>:	mov    0x8(%ebp),%eax
192		cprintf("----Trap No: 0x%u\n", tf->tf_trapno);
=> 0xf010245b <trap_dispatch+12>:	mov    0x28(%eax),%eax
0xf010245b	192		cprintf("----Trap No: 0x%u\n", tf->tf_trapno);
=> 0xf010245e <trap_dispatch+15>:	sub    $0x8,%esp
0xf010245e	192		cprintf("----Trap No: 0x%u\n", tf->tf_trapno);
=> 0xf0102461 <trap_dispatch+18>:	push   %eax
0xf0102461	192		cprintf("----Trap No: 0x%u\n", tf->tf_trapno);
=> 0xf0102462 <trap_dispatch+19>:	push   $0xf0104b1f
0xf0102462	192		cprintf("----Trap No: 0x%u\n", tf->tf_trapno);
=> 0xf0102467 <trap_dispatch+24>:	call   0xf0103b8e <cprintf>
0xf0102467	192		cprintf("----Trap No: 0x%u\n", tf->tf_trapno);
=> 0xf0103b8e <cprintf>:	push   %ebp
cprintf (fmt=0xf0104b1f "----Trap No: 0x%u\n") at stdio.c:52
52	{
=> 0xf0103b8f <cprintf+1>:	mov    %esp,%ebp
0xf0103b8f	52	{
=> 0xf0103b91 <cprintf+3>:	sub    $0x18,%esp
0xf0103b91	52	{
=> 0xf0103b94 <cprintf+6>:	lea    0xc(%ebp),%eax
56		va_start(ap, fmt);
=> 0xf0103b97 <cprintf+9>:	mov    %eax,-0x10(%ebp)
0xf0103b97	56		va_start(ap, fmt);
=> 0xf0103b9a <cprintf+12>:	mov    -0x10(%ebp),%eax
57		cnt = vcprintf(fmt, ap);
=> 0xf0103b9d <cprintf+15>:	sub    $0x8,%esp
0xf0103b9d	57		cnt = vcprintf(fmt, ap);
=> 0xf0103ba0 <cprintf+18>:	push   %eax
0xf0103ba0	57		cnt = vcprintf(fmt, ap);
=> 0xf0103ba1 <cprintf+19>:	pushl  0x8(%ebp)
0xf0103ba1	57		cnt = vcprintf(fmt, ap);
=> 0xf0103ba4 <cprintf+22>:	call   0xf0103b65 <vcprintf>
0xf0103ba4	57		cnt = vcprintf(fmt, ap);
=> 0xf0103b65 <vcprintf>:	push   %ebp
vcprintf (fmt=0xf0104b1f "----Trap No: 0x%u\n", ap=0xefffff4c "0") at stdio.c:43
43	{
=> 0xf0103b66 <vcprintf+1>:	mov    %esp,%ebp
0xf0103b66	43	{
=> 0xf0103b68 <vcprintf+3>:	sub    $0x18,%esp
0xf0103b68	43	{
=> 0xf0103b6b <vcprintf+6>:	movl   $0x0,-0xc(%ebp)
44		int cnt = 0;
=> 0xf0103b72 <vcprintf+13>:	pushl  0xc(%ebp)
46		vprintfmt((void*)putch, &cnt, fmt, ap);
=> 0xf0103b75 <vcprintf+16>:	pushl  0x8(%ebp)
0xf0103b75	46		vprintfmt((void*)putch, &cnt, fmt, ap);
=> 0xf0103b78 <vcprintf+19>:	lea    -0xc(%ebp),%eax
0xf0103b78	46		vprintfmt((void*)putch, &cnt, fmt, ap);
=> 0xf0103b7b <vcprintf+22>:	push   %eax
0xf0103b7b	46		vprintfmt((void*)putch, &cnt, fmt, ap);
=> 0xf0103b7c <vcprintf+23>:	push   $0xf0103b41
0xf0103b7c	46		vprintfmt((void*)putch, &cnt, fmt, ap);
=> 0xf0103b81 <vcprintf+28>:	call   0xf0103cec <vprintfmt>
0xf0103b81	46		vprintfmt((void*)putch, &cnt, fmt, ap);
=> 0xf0103cec <vprintfmt>:	push   %ebp
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b1f "----Trap No: 0x%u\n", ap=0xefffff4c "0") at stdio.c:260
260	{
=> 0xf0103ced <vprintfmt+1>:	mov    %esp,%ebp
0xf0103ced	260	{
=> 0xf0103cef <vprintfmt+3>:	push   %esi
0xf0103cef	260	{
=> 0xf0103cf0 <vprintfmt+4>:	push   %ebx
0xf0103cf0	260	{
=> 0xf0103cf1 <vprintfmt+5>:	sub    $0x20,%esp
0xf0103cf1	260	{
=> 0xf0103cf4 <vprintfmt+8>:	jmp    0xf0103d0d <vprintfmt+33>
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103d10 <vprintfmt+36>:	lea    0x1(%eax),%edx
0xf0103d10	268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103d13 <vprintfmt+39>:	mov    %edx,0x10(%ebp)
0xf0103d13	268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103d16 <vprintfmt+42>:	movzbl (%eax),%eax
0xf0103d16	268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103d19 <vprintfmt+45>:	movzbl %al,%ebx
0xf0103d19	268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103d1c <vprintfmt+48>:	cmp    $0x25,%ebx
0xf0103d1c	268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103d1f <vprintfmt+51>:	jne    0xf0103cf6 <vprintfmt+10>
0xf0103d1f	268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cf8 <vprintfmt+12>:	je     0xf0104085 <vprintfmt+921>
0xf0103cf8	269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103d01 <vprintfmt+21>:	pushl  0xc(%ebp)
0xf0103d01	271				putch(ch, putdat);
=> 0xf0103d04 <vprintfmt+24>:	push   %ebx
0xf0103d04	271				putch(ch, putdat);
=> 0xf0103d05 <vprintfmt+25>:	mov    0x8(%ebp),%eax
0xf0103d05	271				putch(ch, putdat);
=> 0xf0103d08 <vprintfmt+28>:	call   *%eax
0xf0103d08	271				putch(ch, putdat);
=> 0xf0103b41 <putch>:	push   %ebp
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:36
36	{
=> 0xf0103b42 <putch+1>:	mov    %esp,%ebp
0xf0103b42	36	{
=> 0xf0103b44 <putch+3>:	sub    $0x8,%esp
0xf0103b44	36	{
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
37		cputchar(ch);
=> 0xf0103b4a <putch+9>:	pushl  0x8(%ebp)
0xf0103b4a	37		cputchar(ch);
=> 0xf0103b4d <putch+12>:	call   0xf01012be <cputchar>
0xf0103b4d	37		cputchar(ch);
=> 0xf01012be <cputchar>:	push   %ebp
cputchar (c=0x2d) at console.c:436
436	{
=> 0xf01012bf <cputchar+1>:	mov    %esp,%ebp
0xf01012bf	436	{
=> 0xf01012c1 <cputchar+3>:	sub    $0x8,%esp
0xf01012c1	436	{
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
437		cons_putc(c);
=> 0xf01012c7 <cputchar+9>:	pushl  0x8(%ebp)
0xf01012c7	437		cons_putc(c);
=> 0xf01012ca <cputchar+12>:	call   0xf0100ff0 <cons_putc>
0xf01012ca	437		cons_putc(c);
=> 0xf0100ff0 <cons_putc>:	push   %ebp
cons_putc (c=0x2d) at console.c:200
200	{
=> 0xf0100ff1 <cons_putc+1>:	mov    %esp,%ebp
0xf0100ff1	200	{
=> 0xf0100ff3 <cons_putc+3>:	sub    $0x8,%esp
0xf0100ff3	200	{
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
201		serial_putc(c);
=> 0xf0100ff9 <cons_putc+9>:	call   0xf0100b35 <serial_putc>
0xf0100ff9	201		serial_putc(c);
=> 0xf0100b35 <serial_putc>:	push   %ebp
serial_putc (c=0x2d) at console.c:64
64	{
=> 0xf0100b36 <serial_putc+1>:	mov    %esp,%ebp
0xf0100b36	64	{
=> 0xf0100b38 <serial_putc+3>:	sub    $0x30,%esp
0xf0100b38	64	{
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
67		for (i = 0;
=> 0xf0100b42 <serial_putc+13>:	jmp    0xf0100b4d <serial_putc+24>
0xf0100b42	67		for (i = 0;
=> 0xf0100b4d <serial_putc+24>:	movl   $0x3fd,-0x20(%ebp)
0xf0100b4d	69		     i++)
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b57 <serial_putc+34>:	mov    %eax,%edx
0xf0100b57	72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b59 <serial_putc+36>:	in     (%dx),%al
0xf0100b59	72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5a <serial_putc+37>:	mov    %al,-0x21(%ebp)
0xf0100b5a	72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x2d) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b64 <serial_putc+47>:	and    $0x20,%eax
0xf0100b64	68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b69 <serial_putc+52>:	jne    0xf0100b74 <serial_putc+63>
0xf0100b69	67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100b78 <serial_putc+67>:	jne    0xf0100c35 <serial_putc+256>
0xf0100b78	72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c38 <serial_putc+259>:	movzbl %al,%eax
0xf0100c38	87		outb(COM1 + COM_TX, c);
=> 0xf0100c3b <serial_putc+262>:	movl   $0x3f8,-0x1c(%ebp)
0xf0100c3b	87		outb(COM1 + COM_TX, c);
=> 0xf0100c42 <serial_putc+269>:	mov    %al,-0x27(%ebp)
0xf0100c42	87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x2d, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c49 <serial_putc+276>:	mov    -0x1c(%ebp),%edx
0xf0100c49	122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4c <serial_putc+279>:	out    %al,(%dx)
0xf0100c4c	122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x2d) at console.c:88
88	}
=> 0xf0100c4e <serial_putc+281>:	ret    
0xf0100c4e in serial_putc (c=0x2d) at console.c:88
88	}
=> 0xf0100ffe <cons_putc+14>:	add    $0x4,%esp
0xf0100ffe in cons_putc (c=0x2d) at console.c:201
201		serial_putc(c);
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
202		cga_putc(c);
=> 0xf0101004 <cons_putc+20>:	pushl  0x8(%ebp)
0xf0101004	202		cga_putc(c);
=> 0xf0101007 <cons_putc+23>:	call   0xf0100de8 <cga_putc>
0xf0101007	202		cga_putc(c);
=> 0xf0100de8 <cga_putc>:	push   %ebp
cga_putc (c=0x2d) at console.c:153
153	{
=> 0xf0100de9 <cga_putc+1>:	mov    %esp,%ebp
0xf0100de9	153	{
=> 0xf0100deb <cga_putc+3>:	push   %ebx
0xf0100deb	153	{
=> 0xf0100dec <cga_putc+4>:	sub    $0x24,%esp
0xf0100dec	153	{
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
155		if (!(c & ~0xFF))
=> 0xf0100df2 <cga_putc+10>:	mov    $0x0,%al
0xf0100df2	155		if (!(c & ~0xFF))
=> 0xf0100df4 <cga_putc+12>:	test   %eax,%eax
0xf0100df4	155		if (!(c & ~0xFF))
=> 0xf0100df6 <cga_putc+14>:	jne    0xf0100dff <cga_putc+23>
0xf0100df6	155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100e02 <cga_putc+26>:	movzbl %al,%eax
0xf0100e02	158		switch (c & 0xff) {
=> 0xf0100e05 <cga_putc+29>:	cmp    $0x9,%eax
0xf0100e05	158		switch (c & 0xff) {
=> 0xf0100e08 <cga_putc+32>:	je     0xf0100eb9 <cga_putc+209>
0xf0100e08	158		switch (c & 0xff) {
=> 0xf0100e0e <cga_putc+38>:	cmp    $0x9,%eax
0xf0100e0e	158		switch (c & 0xff) {
=> 0xf0100e11 <cga_putc+41>:	jg     0xf0100e1d <cga_putc+53>
0xf0100e11	158		switch (c & 0xff) {
=> 0xf0100e1d <cga_putc+53>:	cmp    $0xa,%eax
0xf0100e1d	158		switch (c & 0xff) {
=> 0xf0100e20 <cga_putc+56>:	je     0xf0100e6f <cga_putc+135>
0xf0100e20	158		switch (c & 0xff) {
=> 0xf0100e22 <cga_putc+58>:	cmp    $0xd,%eax
0xf0100e22	158		switch (c & 0xff) {
=> 0xf0100e25 <cga_putc+61>:	je     0xf0100e7f <cga_putc+151>
0xf0100e25	158		switch (c & 0xff) {
=> 0xf0100e27 <cga_putc+63>:	jmp    0xf0100eef <cga_putc+263>
0xf0100e27	158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100ef5 <cga_putc+269>:	movzwl 0xf012b5ac,%eax
0xf0100ef5	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100efc <cga_putc+276>:	lea    0x1(%eax),%edx
0xf0100efc	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100eff <cga_putc+279>:	mov    %dx,0xf012b5ac
0xf0100eff	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f06 <cga_putc+286>:	movzwl %ax,%eax
0xf0100f06	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f09 <cga_putc+289>:	add    %eax,%eax
0xf0100f09	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f0b <cga_putc+291>:	add    %ecx,%eax
0xf0100f0b	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f0d <cga_putc+293>:	mov    0x8(%ebp),%edx
0xf0100f0d	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f10 <cga_putc+296>:	mov    %dx,(%eax)
0xf0100f10	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f1d <cga_putc+309>:	cmp    $0x7cf,%ax
0xf0100f1d	182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f21 <cga_putc+313>:	jbe    0xf0100f7c <cga_putc+404>
0xf0100f21	182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f81 <cga_putc+409>:	mov    %eax,-0x10(%ebp)
0xf0100f81	191		outb(addr_6845, 14);
=> 0xf0100f84 <cga_putc+412>:	movb   $0xe,-0x20(%ebp)
0xf0100f84	191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f8c <cga_putc+420>:	mov    -0x10(%ebp),%edx
0xf0100f8c	122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f8f <cga_putc+423>:	out    %al,(%dx)
0xf0100f8f	122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100f97 <cga_putc+431>:	shr    $0x8,%ax
0xf0100f97	192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100f9b <cga_putc+435>:	movzbl %al,%eax
0xf0100f9b	192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100f9e <cga_putc+438>:	mov    0xf012b5a4,%edx
0xf0100f9e	192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fa4 <cga_putc+444>:	add    $0x1,%edx
0xf0100fa4	192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fa7 <cga_putc+447>:	mov    %edx,-0x14(%ebp)
0xf0100fa7	192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100faa <cga_putc+450>:	mov    %al,-0x1f(%ebp)
0xf0100faa	192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb1 <cga_putc+457>:	mov    -0x14(%ebp),%edx
0xf0100fb1	122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb4 <cga_putc+460>:	out    %al,(%dx)
0xf0100fb4	122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x72d) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fba <cga_putc+466>:	mov    %eax,-0x18(%ebp)
0xf0100fba	193		outb(addr_6845, 15);
=> 0xf0100fbd <cga_putc+469>:	movb   $0xf,-0x1e(%ebp)
0xf0100fbd	193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc5 <cga_putc+477>:	mov    -0x18(%ebp),%edx
0xf0100fc5	122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc8 <cga_putc+480>:	out    %al,(%dx)
0xf0100fc8	122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fd0 <cga_putc+488>:	movzbl %al,%eax
0xf0100fd0	194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fd3 <cga_putc+491>:	mov    0xf012b5a4,%edx
0xf0100fd3	194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fd9 <cga_putc+497>:	add    $0x1,%edx
0xf0100fd9	194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fdc <cga_putc+500>:	mov    %edx,-0x1c(%ebp)
0xf0100fdc	194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fdf <cga_putc+503>:	mov    %al,-0x1d(%ebp)
0xf0100fdf	194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x41, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fe6 <cga_putc+510>:	mov    -0x1c(%ebp),%edx
0xf0100fe6	122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fe9 <cga_putc+513>:	out    %al,(%dx)
0xf0100fe9	122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x72d) at console.c:195
195	}
=> 0xf0100feb <cga_putc+515>:	mov    -0x4(%ebp),%ebx
0xf0100feb	195	}
=> 0xf0100fee <cga_putc+518>:	leave  
0xf0100fee	195	}
=> 0xf0100fef <cga_putc+519>:	ret    
0xf0100fef in cga_putc (c=0x72d) at console.c:195
195	}
=> 0xf010100c <cons_putc+28>:	add    $0x10,%esp
0xf010100c in cons_putc (c=0x2d) at console.c:202
202		cga_putc(c);
=> 0xf010100f <cons_putc+31>:	nop
203	}
=> 0xf0101010 <cons_putc+32>:	leave  
0xf0101010	203	}
=> 0xf0101011 <cons_putc+33>:	ret    
0xf0101011 in cons_putc (c=0x2d) at console.c:203
203	}
=> 0xf01012cf <cputchar+17>:	add    $0x10,%esp
0xf01012cf in cputchar (c=0x2d) at console.c:437
437		cons_putc(c);
=> 0xf01012d2 <cputchar+20>:	nop
438	}
=> 0xf01012d3 <cputchar+21>:	leave  
0xf01012d3	438	}
=> 0xf01012d4 <cputchar+22>:	ret    
0xf01012d4 in cputchar (c=0x2d) at console.c:438
438	}
=> 0xf0103b52 <putch+17>:	add    $0x10,%esp
0xf0103b52 in putch (ch=0x2d, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
38		++(*cnt);
=> 0xf0103b58 <putch+23>:	mov    (%eax),%eax
0xf0103b58	38		++(*cnt);
=> 0xf0103b5a <putch+25>:	lea    0x1(%eax),%edx
0xf0103b5a	38		++(*cnt);
=> 0xf0103b5d <putch+28>:	mov    0xc(%ebp),%eax
0xf0103b5d	38		++(*cnt);
=> 0xf0103b60 <putch+31>:	mov    %edx,(%eax)
0xf0103b60	38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103b63 <putch+34>:	leave  
0xf0103b63	39	}
=> 0xf0103b64 <putch+35>:	ret    
0xf0103b64 in putch (ch=0x2d, cnt=0xefffff04) at stdio.c:39
39	}
=> 0xf0103d0a <vprintfmt+30>:	add    $0x10,%esp
0xf0103d0a in vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b20 "---Trap No: 0x%u\n", ap=0xefffff4c "0") at stdio.c:271
271				putch(ch, putdat);
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103d10 <vprintfmt+36>:	lea    0x1(%eax),%edx
0xf0103d10	268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103d13 <vprintfmt+39>:	mov    %edx,0x10(%ebp)
0xf0103d13	268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103d16 <vprintfmt+42>:	movzbl (%eax),%eax
0xf0103d16	268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103d19 <vprintfmt+45>:	movzbl %al,%ebx
0xf0103d19	268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103d1c <vprintfmt+48>:	cmp    $0x25,%ebx
0xf0103d1c	268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103d1f <vprintfmt+51>:	jne    0xf0103cf6 <vprintfmt+10>
0xf0103d1f	268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cf8 <vprintfmt+12>:	je     0xf0104085 <vprintfmt+921>
0xf0103cf8	269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103d01 <vprintfmt+21>:	pushl  0xc(%ebp)
0xf0103d01	271				putch(ch, putdat);
=> 0xf0103d04 <vprintfmt+24>:	push   %ebx
0xf0103d04	271				putch(ch, putdat);
=> 0xf0103d05 <vprintfmt+25>:	mov    0x8(%ebp),%eax
0xf0103d05	271				putch(ch, putdat);
=> 0xf0103d08 <vprintfmt+28>:	call   *%eax
0xf0103d08	271				putch(ch, putdat);
=> 0xf0103b41 <putch>:	push   %ebp
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:36
36	{
=> 0xf0103b42 <putch+1>:	mov    %esp,%ebp
0xf0103b42	36	{
=> 0xf0103b44 <putch+3>:	sub    $0x8,%esp
0xf0103b44	36	{
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
37		cputchar(ch);
=> 0xf0103b4a <putch+9>:	pushl  0x8(%ebp)
0xf0103b4a	37		cputchar(ch);
=> 0xf0103b4d <putch+12>:	call   0xf01012be <cputchar>
0xf0103b4d	37		cputchar(ch);
=> 0xf01012be <cputchar>:	push   %ebp
cputchar (c=0x2d) at console.c:436
436	{
=> 0xf01012bf <cputchar+1>:	mov    %esp,%ebp
0xf01012bf	436	{
=> 0xf01012c1 <cputchar+3>:	sub    $0x8,%esp
0xf01012c1	436	{
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
437		cons_putc(c);
=> 0xf01012c7 <cputchar+9>:	pushl  0x8(%ebp)
0xf01012c7	437		cons_putc(c);
=> 0xf01012ca <cputchar+12>:	call   0xf0100ff0 <cons_putc>
0xf01012ca	437		cons_putc(c);
=> 0xf0100ff0 <cons_putc>:	push   %ebp
cons_putc (c=0x2d) at console.c:200
200	{
=> 0xf0100ff1 <cons_putc+1>:	mov    %esp,%ebp
0xf0100ff1	200	{
=> 0xf0100ff3 <cons_putc+3>:	sub    $0x8,%esp
0xf0100ff3	200	{
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
201		serial_putc(c);
=> 0xf0100ff9 <cons_putc+9>:	call   0xf0100b35 <serial_putc>
0xf0100ff9	201		serial_putc(c);
=> 0xf0100b35 <serial_putc>:	push   %ebp
serial_putc (c=0x2d) at console.c:64
64	{
=> 0xf0100b36 <serial_putc+1>:	mov    %esp,%ebp
0xf0100b36	64	{
=> 0xf0100b38 <serial_putc+3>:	sub    $0x30,%esp
0xf0100b38	64	{
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
67		for (i = 0;
=> 0xf0100b42 <serial_putc+13>:	jmp    0xf0100b4d <serial_putc+24>
0xf0100b42	67		for (i = 0;
=> 0xf0100b4d <serial_putc+24>:	movl   $0x3fd,-0x20(%ebp)
0xf0100b4d	69		     i++)
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b57 <serial_putc+34>:	mov    %eax,%edx
0xf0100b57	72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b59 <serial_putc+36>:	in     (%dx),%al
0xf0100b59	72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5a <serial_putc+37>:	mov    %al,-0x21(%ebp)
0xf0100b5a	72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x2d) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b64 <serial_putc+47>:	and    $0x20,%eax
0xf0100b64	68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b69 <serial_putc+52>:	jne    0xf0100b74 <serial_putc+63>
0xf0100b69	67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100b78 <serial_putc+67>:	jne    0xf0100c35 <serial_putc+256>
0xf0100b78	72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c38 <serial_putc+259>:	movzbl %al,%eax
0xf0100c38	87		outb(COM1 + COM_TX, c);
=> 0xf0100c3b <serial_putc+262>:	movl   $0x3f8,-0x1c(%ebp)
0xf0100c3b	87		outb(COM1 + COM_TX, c);
=> 0xf0100c42 <serial_putc+269>:	mov    %al,-0x27(%ebp)
0xf0100c42	87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x2d, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c49 <serial_putc+276>:	mov    -0x1c(%ebp),%edx
0xf0100c49	122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4c <serial_putc+279>:	out    %al,(%dx)
0xf0100c4c	122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x2d) at console.c:88
88	}
=> 0xf0100c4e <serial_putc+281>:	ret    
0xf0100c4e in serial_putc (c=0x2d) at console.c:88
88	}
=> 0xf0100ffe <cons_putc+14>:	add    $0x4,%esp
0xf0100ffe in cons_putc (c=0x2d) at console.c:201
201		serial_putc(c);
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
202		cga_putc(c);
=> 0xf0101004 <cons_putc+20>:	pushl  0x8(%ebp)
0xf0101004	202		cga_putc(c);
=> 0xf0101007 <cons_putc+23>:	call   0xf0100de8 <cga_putc>
0xf0101007	202		cga_putc(c);
=> 0xf0100de8 <cga_putc>:	push   %ebp
cga_putc (c=0x2d) at console.c:153
153	{
=> 0xf0100de9 <cga_putc+1>:	mov    %esp,%ebp
0xf0100de9	153	{
=> 0xf0100deb <cga_putc+3>:	push   %ebx
0xf0100deb	153	{
=> 0xf0100dec <cga_putc+4>:	sub    $0x24,%esp
0xf0100dec	153	{
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
155		if (!(c & ~0xFF))
=> 0xf0100df2 <cga_putc+10>:	mov    $0x0,%al
0xf0100df2	155		if (!(c & ~0xFF))
=> 0xf0100df4 <cga_putc+12>:	test   %eax,%eax
0xf0100df4	155		if (!(c & ~0xFF))
=> 0xf0100df6 <cga_putc+14>:	jne    0xf0100dff <cga_putc+23>
0xf0100df6	155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100e02 <cga_putc+26>:	movzbl %al,%eax
0xf0100e02	158		switch (c & 0xff) {
=> 0xf0100e05 <cga_putc+29>:	cmp    $0x9,%eax
0xf0100e05	158		switch (c & 0xff) {
=> 0xf0100e08 <cga_putc+32>:	je     0xf0100eb9 <cga_putc+209>
0xf0100e08	158		switch (c & 0xff) {
=> 0xf0100e0e <cga_putc+38>:	cmp    $0x9,%eax
0xf0100e0e	158		switch (c & 0xff) {
=> 0xf0100e11 <cga_putc+41>:	jg     0xf0100e1d <cga_putc+53>
0xf0100e11	158		switch (c & 0xff) {
=> 0xf0100e1d <cga_putc+53>:	cmp    $0xa,%eax
0xf0100e1d	158		switch (c & 0xff) {
=> 0xf0100e20 <cga_putc+56>:	je     0xf0100e6f <cga_putc+135>
0xf0100e20	158		switch (c & 0xff) {
=> 0xf0100e22 <cga_putc+58>:	cmp    $0xd,%eax
0xf0100e22	158		switch (c & 0xff) {
=> 0xf0100e25 <cga_putc+61>:	je     0xf0100e7f <cga_putc+151>
0xf0100e25	158		switch (c & 0xff) {
=> 0xf0100e27 <cga_putc+63>:	jmp    0xf0100eef <cga_putc+263>
0xf0100e27	158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100ef5 <cga_putc+269>:	movzwl 0xf012b5ac,%eax
0xf0100ef5	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100efc <cga_putc+276>:	lea    0x1(%eax),%edx
0xf0100efc	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100eff <cga_putc+279>:	mov    %dx,0xf012b5ac
0xf0100eff	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f06 <cga_putc+286>:	movzwl %ax,%eax
0xf0100f06	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f09 <cga_putc+289>:	add    %eax,%eax
0xf0100f09	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f0b <cga_putc+291>:	add    %ecx,%eax
0xf0100f0b	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f0d <cga_putc+293>:	mov    0x8(%ebp),%edx
0xf0100f0d	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f10 <cga_putc+296>:	mov    %dx,(%eax)
0xf0100f10	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f1d <cga_putc+309>:	cmp    $0x7cf,%ax
0xf0100f1d	182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f21 <cga_putc+313>:	jbe    0xf0100f7c <cga_putc+404>
0xf0100f21	182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f81 <cga_putc+409>:	mov    %eax,-0x10(%ebp)
0xf0100f81	191		outb(addr_6845, 14);
=> 0xf0100f84 <cga_putc+412>:	movb   $0xe,-0x20(%ebp)
0xf0100f84	191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f8c <cga_putc+420>:	mov    -0x10(%ebp),%edx
0xf0100f8c	122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f8f <cga_putc+423>:	out    %al,(%dx)
0xf0100f8f	122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100f97 <cga_putc+431>:	shr    $0x8,%ax
0xf0100f97	192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100f9b <cga_putc+435>:	movzbl %al,%eax
0xf0100f9b	192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100f9e <cga_putc+438>:	mov    0xf012b5a4,%edx
0xf0100f9e	192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fa4 <cga_putc+444>:	add    $0x1,%edx
0xf0100fa4	192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fa7 <cga_putc+447>:	mov    %edx,-0x14(%ebp)
0xf0100fa7	192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100faa <cga_putc+450>:	mov    %al,-0x1f(%ebp)
0xf0100faa	192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb1 <cga_putc+457>:	mov    -0x14(%ebp),%edx
0xf0100fb1	122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb4 <cga_putc+460>:	out    %al,(%dx)
0xf0100fb4	122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x72d) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fba <cga_putc+466>:	mov    %eax,-0x18(%ebp)
0xf0100fba	193		outb(addr_6845, 15);
=> 0xf0100fbd <cga_putc+469>:	movb   $0xf,-0x1e(%ebp)
0xf0100fbd	193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc5 <cga_putc+477>:	mov    -0x18(%ebp),%edx
0xf0100fc5	122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc8 <cga_putc+480>:	out    %al,(%dx)
0xf0100fc8	122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fd0 <cga_putc+488>:	movzbl %al,%eax
0xf0100fd0	194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fd3 <cga_putc+491>:	mov    0xf012b5a4,%edx
0xf0100fd3	194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fd9 <cga_putc+497>:	add    $0x1,%edx
0xf0100fd9	194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fdc <cga_putc+500>:	mov    %edx,-0x1c(%ebp)
0xf0100fdc	194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fdf <cga_putc+503>:	mov    %al,-0x1d(%ebp)
0xf0100fdf	194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x42, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fe6 <cga_putc+510>:	mov    -0x1c(%ebp),%edx
0xf0100fe6	122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fe9 <cga_putc+513>:	out    %al,(%dx)
0xf0100fe9	122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x72d) at console.c:195
195	}
=> 0xf0100feb <cga_putc+515>:	mov    -0x4(%ebp),%ebx
0xf0100feb	195	}
=> 0xf0100fee <cga_putc+518>:	leave  
0xf0100fee	195	}
=> 0xf0100fef <cga_putc+519>:	ret    
0xf0100fef in cga_putc (c=0x72d) at console.c:195
195	}
=> 0xf010100c <cons_putc+28>:	add    $0x10,%esp
0xf010100c in cons_putc (c=0x2d) at console.c:202
202		cga_putc(c);
=> 0xf010100f <cons_putc+31>:	nop
203	}
=> 0xf0101010 <cons_putc+32>:	leave  
0xf0101010	203	}
=> 0xf0101011 <cons_putc+33>:	ret    
0xf0101011 in cons_putc (c=0x2d) at console.c:203
203	}
=> 0xf01012cf <cputchar+17>:	add    $0x10,%esp
0xf01012cf in cputchar (c=0x2d) at console.c:437
437		cons_putc(c);
=> 0xf01012d2 <cputchar+20>:	nop
438	}
=> 0xf01012d3 <cputchar+21>:	leave  
0xf01012d3	438	}
=> 0xf01012d4 <cputchar+22>:	ret    
0xf01012d4 in cputchar (c=0x2d) at console.c:438
438	}
=> 0xf0103b52 <putch+17>:	add    $0x10,%esp
0xf0103b52 in putch (ch=0x2d, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
38		++(*cnt);
=> 0xf0103b58 <putch+23>:	mov    (%eax),%eax
0xf0103b58	38		++(*cnt);
=> 0xf0103b5a <putch+25>:	lea    0x1(%eax),%edx
0xf0103b5a	38		++(*cnt);
=> 0xf0103b5d <putch+28>:	mov    0xc(%ebp),%eax
0xf0103b5d	38		++(*cnt);
=> 0xf0103b60 <putch+31>:	mov    %edx,(%eax)
0xf0103b60	38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103b63 <putch+34>:	leave  
0xf0103b63	39	}
=> 0xf0103b64 <putch+35>:	ret    
0xf0103b64 in putch (ch=0x2d, cnt=0xefffff04) at stdio.c:39
39	}
=> 0xf0103d0a <vprintfmt+30>:	add    $0x10,%esp
0xf0103d0a in vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b21 "--Trap No: 0x%u\n", ap=0xefffff4c "0") at stdio.c:271
271				putch(ch, putdat);
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103d10 <vprintfmt+36>:	lea    0x1(%eax),%edx
0xf0103d10	268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103d13 <vprintfmt+39>:	mov    %edx,0x10(%ebp)
0xf0103d13	268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103d16 <vprintfmt+42>:	movzbl (%eax),%eax
0xf0103d16	268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103d19 <vprintfmt+45>:	movzbl %al,%ebx
0xf0103d19	268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103d1c <vprintfmt+48>:	cmp    $0x25,%ebx
0xf0103d1c	268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103d1f <vprintfmt+51>:	jne    0xf0103cf6 <vprintfmt+10>
0xf0103d1f	268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cf8 <vprintfmt+12>:	je     0xf0104085 <vprintfmt+921>
0xf0103cf8	269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103d01 <vprintfmt+21>:	pushl  0xc(%ebp)
0xf0103d01	271				putch(ch, putdat);
=> 0xf0103d04 <vprintfmt+24>:	push   %ebx
0xf0103d04	271				putch(ch, putdat);
=> 0xf0103d05 <vprintfmt+25>:	mov    0x8(%ebp),%eax
0xf0103d05	271				putch(ch, putdat);
=> 0xf0103d08 <vprintfmt+28>:	call   *%eax
0xf0103d08	271				putch(ch, putdat);
=> 0xf0103b41 <putch>:	push   %ebp
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:36
36	{
=> 0xf0103b42 <putch+1>:	mov    %esp,%ebp
0xf0103b42	36	{
=> 0xf0103b44 <putch+3>:	sub    $0x8,%esp
0xf0103b44	36	{
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
37		cputchar(ch);
=> 0xf0103b4a <putch+9>:	pushl  0x8(%ebp)
0xf0103b4a	37		cputchar(ch);
=> 0xf0103b4d <putch+12>:	call   0xf01012be <cputchar>
0xf0103b4d	37		cputchar(ch);
=> 0xf01012be <cputchar>:	push   %ebp
cputchar (c=0x2d) at console.c:436
436	{
=> 0xf01012bf <cputchar+1>:	mov    %esp,%ebp
0xf01012bf	436	{
=> 0xf01012c1 <cputchar+3>:	sub    $0x8,%esp
0xf01012c1	436	{
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
437		cons_putc(c);
=> 0xf01012c7 <cputchar+9>:	pushl  0x8(%ebp)
0xf01012c7	437		cons_putc(c);
=> 0xf01012ca <cputchar+12>:	call   0xf0100ff0 <cons_putc>
0xf01012ca	437		cons_putc(c);
=> 0xf0100ff0 <cons_putc>:	push   %ebp
cons_putc (c=0x2d) at console.c:200
200	{
=> 0xf0100ff1 <cons_putc+1>:	mov    %esp,%ebp
0xf0100ff1	200	{
=> 0xf0100ff3 <cons_putc+3>:	sub    $0x8,%esp
0xf0100ff3	200	{
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
201		serial_putc(c);
=> 0xf0100ff9 <cons_putc+9>:	call   0xf0100b35 <serial_putc>
0xf0100ff9	201		serial_putc(c);
=> 0xf0100b35 <serial_putc>:	push   %ebp
serial_putc (c=0x2d) at console.c:64
64	{
=> 0xf0100b36 <serial_putc+1>:	mov    %esp,%ebp
0xf0100b36	64	{
=> 0xf0100b38 <serial_putc+3>:	sub    $0x30,%esp
0xf0100b38	64	{
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
67		for (i = 0;
=> 0xf0100b42 <serial_putc+13>:	jmp    0xf0100b4d <serial_putc+24>
0xf0100b42	67		for (i = 0;
=> 0xf0100b4d <serial_putc+24>:	movl   $0x3fd,-0x20(%ebp)
0xf0100b4d	69		     i++)
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b57 <serial_putc+34>:	mov    %eax,%edx
0xf0100b57	72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b59 <serial_putc+36>:	in     (%dx),%al
0xf0100b59	72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5a <serial_putc+37>:	mov    %al,-0x21(%ebp)
0xf0100b5a	72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x2d) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b64 <serial_putc+47>:	and    $0x20,%eax
0xf0100b64	68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b69 <serial_putc+52>:	jne    0xf0100b74 <serial_putc+63>
0xf0100b69	67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100b78 <serial_putc+67>:	jne    0xf0100c35 <serial_putc+256>
0xf0100b78	72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c38 <serial_putc+259>:	movzbl %al,%eax
0xf0100c38	87		outb(COM1 + COM_TX, c);
=> 0xf0100c3b <serial_putc+262>:	movl   $0x3f8,-0x1c(%ebp)
0xf0100c3b	87		outb(COM1 + COM_TX, c);
=> 0xf0100c42 <serial_putc+269>:	mov    %al,-0x27(%ebp)
0xf0100c42	87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x2d, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c49 <serial_putc+276>:	mov    -0x1c(%ebp),%edx
0xf0100c49	122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4c <serial_putc+279>:	out    %al,(%dx)
0xf0100c4c	122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x2d) at console.c:88
88	}
=> 0xf0100c4e <serial_putc+281>:	ret    
0xf0100c4e in serial_putc (c=0x2d) at console.c:88
88	}
=> 0xf0100ffe <cons_putc+14>:	add    $0x4,%esp
0xf0100ffe in cons_putc (c=0x2d) at console.c:201
201		serial_putc(c);
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
202		cga_putc(c);
=> 0xf0101004 <cons_putc+20>:	pushl  0x8(%ebp)
0xf0101004	202		cga_putc(c);
=> 0xf0101007 <cons_putc+23>:	call   0xf0100de8 <cga_putc>
0xf0101007	202		cga_putc(c);
=> 0xf0100de8 <cga_putc>:	push   %ebp
cga_putc (c=0x2d) at console.c:153
153	{
=> 0xf0100de9 <cga_putc+1>:	mov    %esp,%ebp
0xf0100de9	153	{
=> 0xf0100deb <cga_putc+3>:	push   %ebx
0xf0100deb	153	{
=> 0xf0100dec <cga_putc+4>:	sub    $0x24,%esp
0xf0100dec	153	{
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
155		if (!(c & ~0xFF))
=> 0xf0100df2 <cga_putc+10>:	mov    $0x0,%al
0xf0100df2	155		if (!(c & ~0xFF))
=> 0xf0100df4 <cga_putc+12>:	test   %eax,%eax
0xf0100df4	155		if (!(c & ~0xFF))
=> 0xf0100df6 <cga_putc+14>:	jne    0xf0100dff <cga_putc+23>
0xf0100df6	155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100e02 <cga_putc+26>:	movzbl %al,%eax
0xf0100e02	158		switch (c & 0xff) {
=> 0xf0100e05 <cga_putc+29>:	cmp    $0x9,%eax
0xf0100e05	158		switch (c & 0xff) {
=> 0xf0100e08 <cga_putc+32>:	je     0xf0100eb9 <cga_putc+209>
0xf0100e08	158		switch (c & 0xff) {
=> 0xf0100e0e <cga_putc+38>:	cmp    $0x9,%eax
0xf0100e0e	158		switch (c & 0xff) {
=> 0xf0100e11 <cga_putc+41>:	jg     0xf0100e1d <cga_putc+53>
0xf0100e11	158		switch (c & 0xff) {
=> 0xf0100e1d <cga_putc+53>:	cmp    $0xa,%eax
0xf0100e1d	158		switch (c & 0xff) {
=> 0xf0100e20 <cga_putc+56>:	je     0xf0100e6f <cga_putc+135>
0xf0100e20	158		switch (c & 0xff) {
=> 0xf0100e22 <cga_putc+58>:	cmp    $0xd,%eax
0xf0100e22	158		switch (c & 0xff) {
=> 0xf0100e25 <cga_putc+61>:	je     0xf0100e7f <cga_putc+151>
0xf0100e25	158		switch (c & 0xff) {
=> 0xf0100e27 <cga_putc+63>:	jmp    0xf0100eef <cga_putc+263>
0xf0100e27	158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100ef5 <cga_putc+269>:	movzwl 0xf012b5ac,%eax
0xf0100ef5	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100efc <cga_putc+276>:	lea    0x1(%eax),%edx
0xf0100efc	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100eff <cga_putc+279>:	mov    %dx,0xf012b5ac
0xf0100eff	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f06 <cga_putc+286>:	movzwl %ax,%eax
0xf0100f06	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f09 <cga_putc+289>:	add    %eax,%eax
0xf0100f09	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f0b <cga_putc+291>:	add    %ecx,%eax
0xf0100f0b	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f0d <cga_putc+293>:	mov    0x8(%ebp),%edx
0xf0100f0d	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f10 <cga_putc+296>:	mov    %dx,(%eax)
0xf0100f10	178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f1d <cga_putc+309>:	cmp    $0x7cf,%ax
0xf0100f1d	182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f21 <cga_putc+313>:	jbe    0xf0100f7c <cga_putc+404>
0xf0100f21	182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f81 <cga_putc+409>:	mov    %eax,-0x10(%ebp)
0xf0100f81	191		outb(addr_6845, 14);
=> 0xf0100f84 <cga_putc+412>:	movb   $0xe,-0x20(%ebp)
0xf0100f84	191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f8c <cga_putc+420>:	mov    -0x10(%ebp),%edx
0xf0100f8c	122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f8f <cga_putc+423>:	out    %al,(%dx)
0xf0100f8f	122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100f97 <cga_putc+431>:	shr    $0x8,%ax
0xf0100f97	192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100f9b <cga_putc+435>:	movzbl %al,%eax
0xf0100f9b	192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100f9e <cga_putc+438>:	mov    0xf012b5a4,%edx
0xf0100f9e	192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fa4 <cga_putc+444>:	add    $0x1,%edx
0xf0100fa4	192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fa7 <cga_putc+447>:	mov    %edx,-0x14(%ebp)
0xf0100fa7	192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100faa <cga_putc+450>:	mov    %al,-0x1f(%ebp)
0xf0100faa	192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb1 <cga_putc+457>:	mov    -0x14(%ebp),%edx
0xf0100fb1	122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb4 <cga_putc+460>:	out    %al,(%dx)
0xf0100fb4	122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x72d) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fba <cga_putc+466>:	mov    %eax,-0x18(%ebp)
0xf0100fba	193		outb(addr_6845, 15);
=> 0xf0100fbd <cga_putc+469>:	movb   $0xf,-0x1e(%ebp)
0xf0100fbd	193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc5 <cga_putc+477>:	mov    -0x18(%ebp),%edx
0xf0100fc5	122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc8 <cga_putc+480>:	out    %al,(%dx)
0xf0100fc8	122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fd0 <cga_putc+488>:	movzbl %al,%eax
0xf0100fd0	194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fd3 <cga_putc+491>:	mov    0xf012b5a4,%edx
0xf0100fd3	194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fd9 <cga_putc+497>:	add    $0x1,%edx
0xf0100fd9	194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fdc <cga_putc+500>:	mov    %edx,-0x1c(%ebp)
0xf0100fdc	194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fdf <cga_putc+503>:	mov    %al,-0x1d(%ebp)
0xf0100fdf	194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x43, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fe6 <cga_putc+510>:	mov    -0x1c(%ebp),%edx
0xf0100fe6	122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fe9 <cga_putc+513>:	out    %al,(%dx)
0xf0100fe9	122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x72d) at console.c:195
195	}
=> 0xf0100feb <cga_putc+515>:	mov    -0x4(%ebp),%ebx
0xf0100feb	195	}
=> 0xf0100fee <cga_putc+518>:	leave  
0xf0100fee	195	}
=> 0xf0100fef <cga_putc+519>:	ret    
0xf0100fef in cga_putc (c=0x72d) at console.c:195
195	}
=> 0xf010100c <cons_putc+28>:	add    $0x10,%esp
0xf010100c in cons_putc (c=0x2d) at console.c:202
202		cga_putc(c);
=> 0xf010100f <cons_putc+31>:	nop
203	}
=> 0xf0101010 <cons_putc+32>:	leave  
0xf0101010	203	}
=> 0xf0101011 <cons_putc+33>:	ret    
0xf0101011 in cons_putc (c=0x2d) at console.c:203
203	}
=> 0xf01012cf <cputchar+17>:	add    $0x10,%esp
0xf01012cf in cputchar (c=0x2d) at console.c:437
437		cons_putc(c);
=> 0xf01012d2 <cputchar+20>:	nop
438	}
=> 0xf01012d3 <cputchar+21>:	leave  
0xf01012d3	438	}
=> 0xf01012d4 <cputchar+22>:	ret    
0xf01012d4 in cputchar (c=0x2d) at console.c:438
438	}
=> 0xf0103b52 <putch+17>:	add    $0x10,%esp
0xf0103b52 in putch (ch=0x2d, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
38		++(*cnt);
=> 0xf0103b58 <putch+23>:	mov    (%eax),%eax
0xf0103b58	38		++(*cnt);
=> 0xf0103b5a <putch+25>:	lea    0x1(%eax),%edx
0xf0103b5a	38		++(*cnt);
=> 0xf0103b5d <putch+28>:	mov    0xc(%ebp),%eax
0xf0103b5d	38		++(*cnt);
=> 0xf0103b60 <putch+31>:	mov    %edx,(%eax)
0xf0103b60	38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103b63 <putch+34>:	leave  
0xf0103b63	39	}
=> 0xf0103b64 <putch+35>:	ret    
0xf0103b64 in putch (ch=0x2d, cnt=0xefffff04) at stdio.c:39
39	}
=> 0xf0103d0a <vprintfmt+30>:	add    $0x10,%esp
0xf0103d0a in vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b22 "-Trap No: 0x%u\n", ap=0xefffff4c "0") at stdio.c:271
271				putch(ch, putdat);
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103d10 <vprintfmt+36>:	lea    0x1(%eax),%edx
0xf0103d10	268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103d13 <vprintfmt+39>:	mov    %edx,0x10(%ebp)
0xf0103d13	268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103d16 <vprintfmt+42>:	movzbl (%eax),%eax
0xf0103d16	268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103d19 <vprintfmt+45>:	movzbl %al,%ebx
0xf0103d19	268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103d1c <vprintfmt+48>:	cmp    $0x25,%ebx
0xf0103d1c	268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103d1f <vprintfmt+51>:	jne    0xf0103cf6 <vprintfmt+10>
0xf0103d1f	268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cf8 <vprintfmt+12>:	je     0xf0104085 <vprintfmt+921>
0xf0103cf8	269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103d01 <vprintfmt+21>:	pushl  0xc(%ebp)
0xf0103d01	271				putch(ch, putdat);
=> 0xf0103d04 <vprintfmt+24>:	push   %ebx
0xf0103d04	271				putch(ch, putdat);
=> 0xf0103d05 <vprintfmt+25>:	mov    0x8(%ebp),%eax
0xf0103d05	271				putch(ch, putdat);
=> 0xf0103d08 <vprintfmt+28>:	call   *%eax
0xf0103d08	271				putch(ch, putdat);
=> 0xf0103b41 <putch>:	push   %ebp
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:36
36	{
=> 0xf0103b42 <putch+1>:	mov    %esp,%ebp
0xf0103b42	36	{
=> 0xf0103b44 <putch+3>:	sub    $0x8,%esp
0xf0103b44	36	{
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
37		cputchar(ch);
=> 0xf0103b4a <putch+9>:	pushl  0x8(%ebp)
0xf0103b4a	37		cputchar(ch);
=> 0xf0103b4d <putch+12>:	call   0xf01012be <cputchar>
0xf0103b4d	37		cputchar(ch);
=> 0xf01012be <cputchar>:	push   %ebp
cputchar (c=0x2d) at console.c:436
436	{
=> 0xf01012bf <cputchar+1>:	mov    %esp,%ebp
0xf01012bf	436	{
=> 0xf01012c1 <cputchar+3>:	sub    $0x8,%esp
0xf01012c1	436	{
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
437		cons_putc(c);
=> 0xf01012c7 <cputchar+9>:	pushl  0x8(%ebp)
0xf01012c7	437		cons_putc(c);
=> 0xf01012ca <cputchar+12>:	call   0xf0100ff0 <cons_putc>
0xf01012ca	437		cons_putc(c);
=> 0xf0100ff0 <cons_putc>:	push   %ebp
cons_putc (c=0x2d) at console.c:200
200	{
=> 0xf0100ff1 <cons_putc+1>:	mov    %esp,%ebp
0xf0100ff1	200	{
=> 0xf0100ff3 <cons_putc+3>:	sub    $0x8,%esp
0xf0100ff3	200	{
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
201		serial_putc(c);
=> 0xf0100ff9 <cons_putc+9>:	call   0xf0100b35 <serial_putc>
0xf0100ff9	201		serial_putc(c);
=> 0xf0100b35 <serial_putc>:	push   %ebp
serial_putc (c=0x2d) at console.c:64
64	{
Breakpoint 3 at 0xf0102d72: file trap.c, line 786.
Continuing.
=> 0xf0102d72 <syscall+5>:	cmpl   $0xd,0x8(%ebp)

Breakpoint 3, syscall (syscallno=0x2, a1=0x0, a2=0x0, a3=0x0, a4=0x0, a5=0x0) at trap.c:786
786		switch (syscallno) {
=> 0xf0102d76 <syscall+9>:	ja     0xf0102d87 <syscall+26>
0xf0102d76	786		switch (syscallno) {
=> 0xf0102d78 <syscall+11>:	mov    0x8(%ebp),%eax
0xf0102d78	786		switch (syscallno) {
=> 0xf0102d7b <syscall+14>:	shl    $0x2,%eax
0xf0102d7b	786		switch (syscallno) {
=> 0xf0102d7e <syscall+17>:	add    $0xf0104bcc,%eax
0xf0102d7e	786		switch (syscallno) {
=> 0xf0102d83 <syscall+22>:	mov    (%eax),%eax
0xf0102d83	786		switch (syscallno) {
=> 0xf0102d85 <syscall+24>:	jmp    *%eax
0xf0102d85	786		switch (syscallno) {
=> 0xf0102db7 <syscall+74>:	call   0xf01027d7 <sys_getenvid>
798			return (int32_t)sys_getenvid();
$1 = 0x2
$2 = 0x2
=> 0xf01027d7 <sys_getenvid>:	push   %ebp
sys_getenvid () at trap.c:405
405	{
=> 0xf01027d8 <sys_getenvid+1>:	mov    %esp,%ebp
0xf01027d8	405	{
=> 0xf01027da <sys_getenvid+3>:	mov    0xf012c054,%eax
406		return curenv->env_id;
=> 0xf01027df <sys_getenvid+8>:	mov    0x48(%eax),%eax
0xf01027df	406		return curenv->env_id;
=> 0xf01027e2 <sys_getenvid+11>:	pop    %ebp
407	}
=> 0xf01027e3 <sys_getenvid+12>:	ret    
0xf01027e3 in sys_getenvid () at trap.c:407
407	}
=> 0xf0102dbc <syscall+79>:	jmp    0xf0102ea9 <syscall+316>
0xf0102dbc in syscall (syscallno=0x2, a1=0x0, a2=0x0, a3=0x0, a4=0x0, a5=0x0) at trap.c:798
798			return (int32_t)sys_getenvid();
=> 0xf0102ea9 <syscall+316>:	lea    -0x8(%ebp),%esp
826	}
=> 0xf0102eac <syscall+319>:	pop    %ebx
0xf0102eac	826	}
=> 0xf0102ead <syscall+320>:	pop    %esi
0xf0102ead	826	}
=> 0xf0102eae <syscall+321>:	pop    %ebp
0xf0102eae	826	}
=> 0xf0102eaf <syscall+322>:	ret    
0xf0102eaf in syscall (syscallno=0x2, a1=0x0, a2=0x0, a3=0x0, a4=0x0, a5=0x0) at trap.c:826
826	}
=> 0xf01024e7 <trap_dispatch+152>:	add    $0x20,%esp
0xf01024e7 in trap_dispatch (tf=0xf0132000) at trap.c:206
206			int32_t temp_ret = syscall(tf->tf_regs.reg_eax,
=> 0xf01024ea <trap_dispatch+155>:	mov    %eax,-0x1c(%ebp)
0xf01024ea	206			int32_t temp_ret = syscall(tf->tf_regs.reg_eax,
=> 0xf01024ed <trap_dispatch+158>:	mov    -0x1c(%ebp),%edx
209			tf->tf_regs.reg_eax = temp_ret;
=> 0xf01024f0 <trap_dispatch+161>:	mov    0x8(%ebp),%eax
0xf01024f0	209			tf->tf_regs.reg_eax = temp_ret;
=> 0xf01024f3 <trap_dispatch+164>:	mov    %edx,0x1c(%eax)
0xf01024f3	209			tf->tf_regs.reg_eax = temp_ret;
=> 0xf01024f6 <trap_dispatch+167>:	jmp    0xf010259e <trap_dispatch+335>
210			return;
=> 0xf010259e <trap_dispatch+335>:	lea    -0xc(%ebp),%esp
253	}
$3 = (struct Env *) 0xf0132000
$4 = {env_tf = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0xeebfdf00, reg_oesp = 0xefffffdc, reg_ebx = 0x0, reg_edx = 0x0, reg_ecx = 0x0, reg_eax = 0x1000}, tf_es = 0x23, tf_padding1 = 0x0, tf_ds = 0x23, tf_padding2 = 0x0, tf_trapno = 0x30, tf_err = 0x0, tf_eip = 0x80002ad5, tf_cs = 0x1b, tf_padding3 = 0x0, tf_eflags = 0x3292, tf_esp = 0xeebfdef4, tf_ss = 0x23, tf_padding4 = 0x0}, env_link = 0xf013207c, env_id = 0x1000, env_parent_id = 0x0, env_type = ENV_TYPE_FS, env_status = 0x3, env_runs = 0x1, env_cpunum = 0x0, env_pgdir = 0xf0044000, env_pgfault_upcall = 0x0, env_ipc_recving = 0x0, env_ipc_dstva = 0x0, env_ipc_value = 0x0, env_ipc_from = 0x0, env_ipc_perm = 0x0}
=> 0xf01025a1 <trap_dispatch+338>:	pop    %ebx
0xf01025a1	253	}
=> 0xf01025a2 <trap_dispatch+339>:	pop    %esi
0xf01025a2	253	}
=> 0xf01025a3 <trap_dispatch+340>:	pop    %edi
0xf01025a3	253	}
=> 0xf01025a4 <trap_dispatch+341>:	pop    %ebp
0xf01025a4	253	}
=> 0xf01025a5 <trap_dispatch+342>:	ret    
0xf01025a5 in trap_dispatch (tf=0xf0132000) at trap.c:253
253	}
=> 0xf0102627 <trap+129>:	add    $0x10,%esp
0xf0102627 in trap (tf=0xf0132000) at trap.c:291
291		trap_dispatch(tf);
=> 0xf010262a <trap+132>:	mov    0xf012c054,%eax
296		if (curenv && curenv->env_status == ENV_RUNNING)
=> 0xf010262f <trap+137>:	test   %eax,%eax
0xf010262f	296		if (curenv && curenv->env_status == ENV_RUNNING)
=> 0xf0102631 <trap+139>:	je     0xf010264e <trap+168>
0xf0102631	296		if (curenv && curenv->env_status == ENV_RUNNING)
=> 0xf0102633 <trap+141>:	mov    0xf012c054,%eax
0xf0102633	296		if (curenv && curenv->env_status == ENV_RUNNING)
=> 0xf0102638 <trap+146>:	mov    0x54(%eax),%eax
0xf0102638	296		if (curenv && curenv->env_status == ENV_RUNNING)
=> 0xf010263b <trap+149>:	cmp    $0x3,%eax
0xf010263b	296		if (curenv && curenv->env_status == ENV_RUNNING)
=> 0xf010263e <trap+152>:	jne    0xf010264e <trap+168>
0xf010263e	296		if (curenv && curenv->env_status == ENV_RUNNING)
=> 0xf0102640 <trap+154>:	mov    0xf012c054,%eax
297			env_run(curenv);
=> 0xf0102645 <trap+159>:	sub    $0xc,%esp
0xf0102645	297			env_run(curenv);
=> 0xf0102648 <trap+162>:	push   %eax
0xf0102648	297			env_run(curenv);
=> 0xf0102649 <trap+163>:	call   0xf0103a6c <env_run>
0xf0102649	297			env_run(curenv);
=> 0xf0103a6c <env_run>:	push   %ebp
env_run (e=0xf0132000) at env.c:508
508	{
=> 0xf0103a6d <env_run+1>:	mov    %esp,%ebp
0xf0103a6d	508	{
=> 0xf0103a6f <env_run+3>:	sub    $0x18,%esp
0xf0103a6f	508	{
=> 0xf0103a72 <env_run+6>:	mov    0xf012c054,%eax
526		if (curenv != e)
=> 0xf0103a77 <env_run+11>:	cmp    0x8(%ebp),%eax
0xf0103a77	526		if (curenv != e)
=> 0xf0103a7a <env_run+14>:	je     0xf0103ad7 <env_run+107>
0xf0103a7a	526		if (curenv != e)
=> 0xf0103ad7 <env_run+107>:	call   0xf01032ca <unlock_kernel>
535		unlock_kernel();
=> 0xf01032ca <unlock_kernel>:	push   %ebp
unlock_kernel () at ./spinlock.h:28
28	{
=> 0xf01032cb <unlock_kernel+1>:	mov    %esp,%ebp
0xf01032cb	28	{
=> 0xf01032cd <unlock_kernel+3>:	sub    $0x8,%esp
0xf01032cd	28	{
=> 0xf01032d0 <unlock_kernel+6>:	sub    $0xc,%esp
29		spin_unlock(&kernel_lock);
=> 0xf01032d3 <unlock_kernel+9>:	push   $0xf012c46c
0xf01032d3	29		spin_unlock(&kernel_lock);
=> 0xf01032d8 <unlock_kernel+14>:	call   0xf0103b2d <spin_unlock>
0xf01032d8	29		spin_unlock(&kernel_lock);
=> 0xf0103b2d <spin_unlock>:	push   %ebp
spin_unlock (lk=0xf012c46c <kernel_lock>) at spinlock.c:35
35	{
=> 0xf0103b2e <spin_unlock+1>:	mov    %esp,%ebp
0xf0103b2e	35	{
=> 0xf0103b30 <spin_unlock+3>:	mov    0x8(%ebp),%eax
46		xchg(&lk->locked, 0);
=> 0xf0103b33 <spin_unlock+6>:	push   $0x0
0xf0103b33	46		xchg(&lk->locked, 0);
=> 0xf0103b35 <spin_unlock+8>:	push   %eax
0xf0103b35	46		xchg(&lk->locked, 0);
=> 0xf0103b36 <spin_unlock+9>:	call   0xf0103ae8 <xchg>
0xf0103b36	46		xchg(&lk->locked, 0);
=> 0xf0103ae8 <xchg>:	push   %ebp
xchg (addr=0xf012c46c <kernel_lock>, newval=0x0) at ./x86.h:319
319	{
=> 0xf0103ae9 <xchg+1>:	mov    %esp,%ebp
0xf0103ae9	319	{
=> 0xf0103aeb <xchg+3>:	sub    $0x10,%esp
0xf0103aeb	319	{
=> 0xf0103aee <xchg+6>:	mov    0x8(%ebp),%edx
323		asm volatile("lock; xchgl %0, %1" :
=> 0xf0103af1 <xchg+9>:	mov    0xc(%ebp),%eax
0xf0103af1	323		asm volatile("lock; xchgl %0, %1" :
=> 0xf0103af4 <xchg+12>:	mov    0x8(%ebp),%ecx
0xf0103af4	323		asm volatile("lock; xchgl %0, %1" :
=> 0xf0103af7 <xchg+15>:	lock xchg %eax,(%edx)
0xf0103af7	323		asm volatile("lock; xchgl %0, %1" :
=> 0xf0103afa <xchg+18>:	mov    %eax,-0x4(%ebp)
0xf0103afa	323		asm volatile("lock; xchgl %0, %1" :
=> 0xf0103afd <xchg+21>:	mov    -0x4(%ebp),%eax
327		return result;
=> 0xf0103b00 <xchg+24>:	leave  
328	}
=> 0xf0103b01 <xchg+25>:	ret    
0xf0103b01 in xchg (addr=0xf012c46c <kernel_lock>, newval=0x0) at ./x86.h:328
328	}
=> 0xf0103b3b <spin_unlock+14>:	add    $0x8,%esp
0xf0103b3b in spin_unlock (lk=0xf012c46c <kernel_lock>) at spinlock.c:46
46		xchg(&lk->locked, 0);
=> 0xf0103b3e <spin_unlock+17>:	nop
47	}
=> 0xf0103b3f <spin_unlock+18>:	leave  
0xf0103b3f	47	}
=> 0xf0103b40 <spin_unlock+19>:	ret    
0xf0103b40 in spin_unlock (lk=0xf012c46c <kernel_lock>) at spinlock.c:47
47	}
=> 0xf01032dd <unlock_kernel+19>:	add    $0x10,%esp
0xf01032dd in unlock_kernel () at ./spinlock.h:29
29		spin_unlock(&kernel_lock);
=> 0xf01032e0 <unlock_kernel+22>:	pause  
35		asm volatile("pause");
=> 0xf01032e3 <unlock_kernel+25>:	leave  
0xf01032e3	36	}
=> 0xf01032e4 <unlock_kernel+26>:	ret    
0xf01032e4 in unlock_kernel () at ./spinlock.h:36
36	}
=> 0xf0103adc <env_run+112>:	mov    0x8(%ebp),%eax
env_run (e=0xf0132000) at env.c:536
536		env_pop_tf(&(e->env_tf));
=> 0xf0103adf <env_run+115>:	sub    $0xc,%esp
0xf0103adf	536		env_pop_tf(&(e->env_tf));
=> 0xf0103ae2 <env_run+118>:	push   %eax
0xf0103ae2	536		env_pop_tf(&(e->env_tf));
=> 0xf0103ae3 <env_run+119>:	call   0xf0103a45 <env_pop_tf>
0xf0103ae3	536		env_pop_tf(&(e->env_tf));
=> 0xf0103a45 <env_pop_tf>:	push   %ebp
env_pop_tf (tf=0xf0132000) at env.c:487
487	{
=> 0xf0103a46 <env_pop_tf+1>:	mov    %esp,%ebp
0xf0103a46	487	{
=> 0xf0103a48 <env_pop_tf+3>:	sub    $0x8,%esp
0xf0103a48	487	{
=> 0xf0103a4b <env_pop_tf+6>:	mov    0x8(%ebp),%esp
488		__asm __volatile("movl %0,%%esp\n"
=> 0xf0103a4e <env_pop_tf+9>:	popa   
0xf0103a4e	488		__asm __volatile("movl %0,%%esp\n"
=> 0xf0103a4f <env_pop_tf+10>:	pop    %es
0xf0103a4f in env_pop_tf (tf=0x7) at env.c:488
488		__asm __volatile("movl %0,%%esp\n"
=> 0xf0103a50 <env_pop_tf+11>:	pop    %ds
0xf0103a50	488		__asm __volatile("movl %0,%%esp\n"
=> 0xf0103a51 <env_pop_tf+12>:	add    $0x8,%esp
0xf0103a51	488		__asm __volatile("movl %0,%%esp\n"
=> 0xf0103a54 <env_pop_tf+15>:	iret   
0xf0103a54	488		__asm __volatile("movl %0,%%esp\n"
The target architecture is assumed to be i8086
[  1b:80002ad5]    0x80002d27:	push   $0x0
0x80002ad5 in ?? ()
[  1b:80002ad6]    0x80002d28:	add    %ch,%al
0x80002ad6 in ?? ()
[  1b:80002ad7]    0x80002d29:	call   0x80002f04
0x80002ad7 in ?? ()
[  1b:80002ad8]    0x80002d2a:	fadds  (%bx,%di)
0x80002ad8 in ?? ()
[  1b:80002ad9]    0x80002d2b:	add    %ax,(%bx,%si)
0x80002ad9 in ?? ()
[  1b:800038a1]    0x80003af3:	add    %al,-0x11(%bx,%si)
0x800038a1 in ?? ()
[  1b:800038a4]    0x80003af6:	mov    0x0(%bp,%di),%ax
0x800038a4 in ?? ()
[  1b:800038a7]    0x80003af9:	add    %cl,(%bx,%si)
0x800038a7 in ?? ()
Reading symbols from damnfs...done.
[  1b:800038aa]    0x80003afc <fd_alloc+33>:	test   $0x1,%al
0x800038aa	554		cprintf("[%08x] user panic in %s at %s:%d: ",
549		va_list ap;
550	
551		va_start(ap, fmt);
552	
553		// Print the panic message
554		cprintf("[%08x] user panic in %s at %s:%d: ",
555			sys_getenvid(), binaryname, file, line);
556		vcprintf(fmt, ap);
557		cprintf("\n");
558	
[  1b:800038ab]    0x80003afd <fd_alloc+34>:	add    %si,0x2e(%si)
0x800038ab	554		cprintf("[%08x] user panic in %s at %s:%d: ",
[  1b:800038ac]    0x80003afe <fd_alloc+35>:	je     0x80003b2e <fd_alloc+83>
0x800038ac	554		cprintf("[%08x] user panic in %s at %s:%d: ",
[  1b:800038b1]    0x80003b03 <fd_alloc+40>:	add    %ah,(%bx,%si)
0x800038b1	554		cprintf("[%08x] user panic in %s at %s:%d: ",
[  1b:80003666]    0x800038b8 <_panic+42>:	sbb    %dl,-0x1(%bp,%di)
cprintf (fmt=0x80004aa8 "[%08x] user panic in %s at %s:%d: ") at stdio.c:112
112	{
[  1b:80003667]    0x800038b9 <_panic+43>:	push   %bx
0x80003667	112	{
107		return b.cnt;
108	}
109	
110	int
111	cprintf(const char *fmt, ...)
112	{
113		va_list ap;
114		int cnt;
115	
116		va_start(ap, fmt);
Invalid character '\' in expression.
   0x800038ab <_panic+29>:	push   %ax
   0x800038ac <_panic+30>:	push   $0x4aa8
   0x800038af <_panic+33>:	add    %al,-0x4f18(%bx,%si)
   0x800038b3 <_panic+37>:	std    
   0x800038b4 <_panic+38>:	(bad)  
   0x800038b5 <_panic+39>:	incw   0x18c4(%bp,%di)
   0x800038b9 <_panic+43>:	push   %bx
   0x800038ba <_panic+44>:	pushw  0x10(%di)
   0x800038bd <_panic+47>:	call   0x80003613 <vprintfmt+1001>
   0x800038c0 <_panic+50>:	(bad)  
   0x800038c1 <_panic+51>:	inc    %di
   0x800038c3 <_panic+53>:	add    $0x24,%al
   0x800038c5 <_panic+55>:	pop    %si
   0x800038c6 <_panic+56>:	inc    %bp
   0x800038c7 <_panic+57>:	add    %al,-0x6718(%bx,%si)
   0x800038cb <_panic+61>:	std    
   0x800038cc <_panic+62>:	(bad)  
   0x800038cd <_panic+63>:	incw   0x10c4(%bp,%di)
   0x800038d1 <_panic+67>:	int3   
   0x800038d2 <_panic+68>:	jmp    0x800038d1 <_panic+67>
   0x80002ad7 <sys_getenvid+28>:	pop    %di
   0x80002ad8 <sys_getenvid+29>:	pop    %bp
   0x80002ad9 <sys_getenvid+30>:	ret    
   0x80002ada <sys_yield>:	push   %bp
   0x80002adb <sys_yield+1>:	mov    %sp,%bp
   0x80002add <sys_yield+3>:	push   %di
   0x80002ade <sys_yield+4>:	push   %si
   0x80002adf <sys_yield+5>:	push   %bx
   0x80002ae0 <sys_yield+6>:	mov    $0x0,%dx
   0x80002ae3 <sys_yield+9>:	add    %al,(%bx,%si)
   0x80002ae5 <sys_yield+11>:	mov    $0xb,%ax
   0x80002ae8 <sys_yield+14>:	add    %al,(%bx,%si)
   0x80002aea <sys_yield+16>:	mov    %dx,%cx
   0x80002aec <sys_yield+18>:	mov    %dx,%bx
   0x80002aee <sys_yield+20>:	mov    %dx,%di
   0x80002af0 <sys_yield+22>:	mov    %dx,%si
   0x80002af2 <sys_yield+24>:	int    $0x30
   0x80002af4 <sys_yield+26>:	pop    %bx
   0x80002af5 <sys_yield+27>:	pop    %si
   0x80002af6 <sys_yield+28>:	pop    %di
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Breakpoint 1 at 0xf01025a6: file trap.c, line 260.
Continuing.
The target architecture is assumed to be i386
=> 0xf01025a6 <trap>:	push   %ebp

Breakpoint 1, trap (tf=0xefffffbc) at trap.c:260
260	{
$1 = (struct Trapframe *) 0xefffffbc
$2 = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0xeebfdfd0, reg_oesp = 0xefffffdc, reg_ebx = 0x0, reg_edx = 0x0, reg_ecx = 0x0, reg_eax = 0x2}, tf_es = 0x23, tf_padding1 = 0x0, tf_ds = 0x23, tf_padding2 = 0x0, tf_trapno = 0x30, tf_err = 0x0, tf_eip = 0x80002ad5, tf_cs = 0x1b, tf_padding3 = 0x0, tf_eflags = 0x3296, tf_esp = 0xeebfdfc4, tf_ss = 0x23, tf_padding4 = 0x0}
Breakpoint 2 at 0xf0102d72: file trap.c, line 786.
Continuing.
=> 0xf0102d72 <syscall+5>:	cmpl   $0xd,0x8(%ebp)

Breakpoint 2, syscall (syscallno=0x2, a1=0x0, a2=0x0, a3=0x0, a4=0x0, a5=0x0) at trap.c:786
786		switch (syscallno) {
Continuing.
=> 0xf01025a6 <trap>:	push   %ebp

Breakpoint 1, trap (tf=0xefffffbc) at trap.c:260
260	{
Reading symbols from damnfs...done.
Error in re-setting breakpoint 1: Function "trap" not defined.
Note: breakpoint 2 also set at pc 0x80002a43.
Note: breakpoint 2 also set at pc 0x80002a61.
Note: breakpoint 2 also set at pc 0x80002a83.
Note: breakpoint 2 also set at pc 0x80002ac1.
Note: breakpoint 2 also set at pc 0x80002ae0.
Note: breakpoint 2 also set at pc 0x80002b02.
Note: breakpoint 2 also set at pc 0x80002b45.
Note: breakpoint 2 also set at pc 0x80002b87.
Note: breakpoint 2 also set at pc 0x80002bc9.
Note: breakpoint 2 also set at pc 0x80002c0b.
Note: breakpoint 2 also set at pc 0x80002c4d.
Note: breakpoint 2 also set at pc 0x80002c8c.
Note: breakpoint 2 also set at pc 0x80002cb2.
Breakpoint 3 at 0x80002a43: syscall. (13 locations)
Continuing.
The target architecture is assumed to be i8086
[  1b:80002a43]    0x80002c95 <sys_ipc_try_send+15>:	add    %cl,0xc4d(%bp,%di)

Breakpoint 2, sys_cputs (s=0xeebfde78 "FS can do I/O\n", len=0xe) at syscall.c:41
41		syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
[  1b:80002a48]    0x80002c9a <sys_ipc_try_send+20>:	push   %bp
0x80002a48 in syscall (a5=0x0, a4=0x0, a3=0x0, a2=0xe, a1=0xeebfde78, check=0x0, num=0x0) at syscall.c:21
21		asm volatile("int %1\n"
[  1b:80002a4b]    0x80002c9d <sys_ipc_try_send+23>:	pop    %bp
0x80002a4b	21		asm volatile("int %1\n"
Continuing.
[  1b:80002a43]    0x80002c95 <sys_ipc_try_send+15>:	add    %cl,0xc4d(%bp,%di)

Breakpoint 2, sys_cputs (s=0xeebfde48 "Device 1 presence: 1\n", len=0x15) at syscall.c:41
41		syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
[  1b:80002a48]    0x80002c9a <sys_ipc_try_send+20>:	push   %bp
0x80002a48 in syscall (a5=0x0, a4=0x0, a3=0x0, a2=0x15, a1=0xeebfde48, check=0x0, num=0x0) at syscall.c:21
21		asm volatile("int %1\n"
[  1b:80002a4b]    0x80002c9d <sys_ipc_try_send+23>:	pop    %bp
0x80002a4b	21		asm volatile("int %1\n"
[  1b:80002a4e]    0x80002ca0 <sys_ipc_try_send+26>:	jge    0x80002cb6 <sys_ipc_recv+13>
0x80002a4e	21		asm volatile("int %1\n"
[  1b:80002a50]    0x80002ca2 <sys_ipc_try_send+28>:	int    $0x30
0x80002a50	21		asm volatile("int %1\n"
[  1b:80002a52]    0x80002ca4 <sys_ipc_try_send+30>:	pop    %bx
0x80002a52	21		asm volatile("int %1\n"
[  1b:80002a54]    0x80002ca6 <sys_ipc_try_send+32>:	pop    %di
0x80002a54	21		asm volatile("int %1\n"
The target architecture is assumed to be i386
=> 0xf0101652:	push   $0x30
0xf0101652 in ?? ()
=> 0xf0101654:	jmp    0xf010165c
0xf0101654 in ?? ()
=> 0xf010165c:	push   %ds
0xf010165c in ?? ()
=> 0xf010165d:	push   %es
0xf010165d in ?? ()
=> 0xf010165e:	pusha  
0xf010165e in ?? ()
=> 0xf010165f:	mov    $0x10,%ax
0xf010165f in ?? ()
=> 0xf0101663:	mov    %eax,%ds
0xf0101663 in ?? ()
=> 0xf0101665:	mov    %eax,%es
0xf0101665 in ?? ()
=> 0xf0101667:	push   %esp
0xf0101667 in ?? ()
=> 0xf0101668:	call   0xf01025a6
0xf0101668 in ?? ()
=> 0xf01025a6:	push   %ebp
0xf01025a6 in ?? ()
=> 0xf01025a7:	mov    %esp,%ebp
0xf01025a7 in ?? ()
=> 0xf01025a9:	push   %edi
0xf01025a9 in ?? ()
=> 0xf01025aa:	push   %esi
0xf01025aa in ?? ()
=> 0xf01025ab:	push   %ebx
0xf01025ab in ?? ()
=> 0xf01025ac:	sub    $0xc,%esp
0xf01025ac in ?? ()
=> 0xf01025af:	cld    
0xf01025af in ?? ()
=> 0xf01025b0:	mov    0x8(%ebp),%eax
0xf01025b0 in ?? ()
=> 0xf01025b3:	movzwl 0x34(%eax),%eax
0xf01025b3 in ?? ()
=> 0xf01025b7:	movzwl %ax,%eax
0xf01025b7 in ?? ()
=> 0xf01025ba:	and    $0x3,%eax
0xf01025ba in ?? ()
=> 0xf01025bd:	cmp    $0x3,%eax
0xf01025bd in ?? ()
=> 0xf01025c0:	jne    0xf0102614
0xf01025c0 in ?? ()
=> 0xf01025c2:	call   0xf010166d
0xf01025c2 in ?? ()
=> 0xf010166d:	push   %ebp
0xf010166d in ?? ()
=> 0xf010166e:	mov    %esp,%ebp
0xf010166e in ?? ()
=> 0xf0101670:	sub    $0x8,%esp
0xf0101670 in ?? ()
=> 0xf0101673:	sub    $0xc,%esp
0xf0101673 in ?? ()
=> 0xf0101676:	push   $0xf012c46c
0xf0101676 in ?? ()
=> 0xf010167b:	call   0xf0103b11
0xf010167b in ?? ()
=> 0xf0103b11:	push   %ebp
0xf0103b11 in ?? ()
=> 0xf0103b12:	mov    %esp,%ebp
0xf0103b12 in ?? ()
=> 0xf0103b14:	jmp    0xf0103b18
0xf0103b14 in ?? ()
=> 0xf0103b18:	mov    0x8(%ebp),%eax
0xf0103b18 in ?? ()
=> 0xf0103b1b:	push   $0x1
0xf0103b1b in ?? ()
=> 0xf0103b1d:	push   %eax
0xf0103b1d in ?? ()
=> 0xf0103b1e:	call   0xf0103ae8
0xf0103b1e in ?? ()
=> 0xf0103ae8:	push   %ebp
0xf0103ae8 in ?? ()
=> 0xf0103ae9:	mov    %esp,%ebp
0xf0103ae9 in ?? ()
=> 0xf0103aeb:	sub    $0x10,%esp
0xf0103aeb in ?? ()
=> 0xf0103aee:	mov    0x8(%ebp),%edx
0xf0103aee in ?? ()
=> 0xf0103af1:	mov    0xc(%ebp),%eax
0xf0103af1 in ?? ()
=> 0xf0103af4:	mov    0x8(%ebp),%ecx
0xf0103af4 in ?? ()
=> 0xf0103af7:	lock xchg %eax,(%edx)
0xf0103af7 in ?? ()
=> 0xf0103afa:	mov    %eax,-0x4(%ebp)
0xf0103afa in ?? ()
=> 0xf0103afd:	mov    -0x4(%ebp),%eax
0xf0103afd in ?? ()
=> 0xf0103b00:	leave  
0xf0103b00 in ?? ()
=> 0xf0103b01:	ret    
0xf0103b01 in ?? ()
=> 0xf0103b23:	add    $0x8,%esp
0xf0103b23 in ?? ()
=> 0xf0103b26:	test   %eax,%eax
0xf0103b26 in ?? ()
=> 0xf0103b28:	jne    0xf0103b16
0xf0103b28 in ?? ()
=> 0xf0103b2a:	nop
0xf0103b2a in ?? ()
=> 0xf0103b2b:	leave  
0xf0103b2b in ?? ()
=> 0xf0103b2c:	ret    
0xf0103b2c in ?? ()
=> 0xf0101680:	add    $0x10,%esp
0xf0101680 in ?? ()
=> 0xf0101683:	nop
0xf0101683 in ?? ()
=> 0xf0101684:	leave  
0xf0101684 in ?? ()
=> 0xf0101685:	ret    
0xf0101685 in ?? ()
=> 0xf01025c7:	mov    0xf012c054,%eax
0xf01025c7 in ?? ()
=> 0xf01025cc:	mov    0x54(%eax),%eax
0xf01025cc in ?? ()
=> 0xf01025cf:	cmp    $0x1,%eax
0xf01025cf in ?? ()
=> 0xf01025d2:	jne    0xf01025f4
0xf01025d2 in ?? ()
=> 0xf01025f4:	mov    0xf012c054,%edx
0xf01025f4 in ?? ()
=> 0xf01025fa:	mov    0x8(%ebp),%eax
0xf01025fa in ?? ()
=> 0xf01025fd:	mov    %eax,%ebx
0xf01025fd in ?? ()
=> 0xf01025ff:	mov    $0x11,%eax
0xf01025ff in ?? ()
=> 0xf0102604:	mov    %edx,%edi
0xf0102604 in ?? ()
=> 0xf0102606:	mov    %ebx,%esi
0xf0102606 in ?? ()
=> 0xf0102608:	mov    %eax,%ecx
0xf0102608 in ?? ()
=> 0xf010260a:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a in ?? ()
=> 0xf010260a:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a in ?? ()
=> 0xf010260a:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a in ?? ()
=> 0xf010260a:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a in ?? ()
=> 0xf010260a:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a in ?? ()
=> 0xf010260a:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a in ?? ()
=> 0xf010260a:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a in ?? ()
=> 0xf010260a:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a in ?? ()
=> 0xf010260a:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a in ?? ()
=> 0xf010260a:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a in ?? ()
=> 0xf010260a:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a in ?? ()
=> 0xf010260a:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a in ?? ()
=> 0xf010260a:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a in ?? ()
=> 0xf010260a:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a in ?? ()
=> 0xf010260a:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a in ?? ()
=> 0xf010260a:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a in ?? ()
=> 0xf010260a:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a in ?? ()
=> 0xf010260c:	mov    0xf012c054,%eax
0xf010260c in ?? ()
=> 0xf0102611:	mov    %eax,0x8(%ebp)
0xf0102611 in ?? ()
=> 0xf0102614:	mov    0x8(%ebp),%eax
0xf0102614 in ?? ()
=> 0xf0102617:	mov    %eax,0xf012c048
0xf0102617 in ?? ()
=> 0xf010261c:	sub    $0xc,%esp
0xf010261c in ?? ()
=> 0xf010261f:	pushl  0x8(%ebp)
0xf010261f in ?? ()
=> 0xf0102622:	call   0xf010244f
0xf0102622 in ?? ()
=> 0xf010244f:	push   %ebp
0xf010244f in ?? ()
=> 0xf0102450:	mov    %esp,%ebp
0xf0102450 in ?? ()
=> 0xf0102452:	push   %edi
0xf0102452 in ?? ()
=> 0xf0102453:	push   %esi
0xf0102453 in ?? ()
=> 0xf0102454:	push   %ebx
0xf0102454 in ?? ()
=> 0xf0102455:	sub    $0x1c,%esp
0xf0102455 in ?? ()
=> 0xf0102458:	mov    0x8(%ebp),%eax
0xf0102458 in ?? ()
=> 0xf010245b:	mov    0x28(%eax),%eax
0xf010245b in ?? ()
=> 0xf010245e:	sub    $0x8,%esp
0xf010245e in ?? ()
=> 0xf0102461:	push   %eax
0xf0102461 in ?? ()
=> 0xf0102462:	push   $0xf0104b1f
0xf0102462 in ?? ()
=> 0xf0102467:	call   0xf0103b8e
0xf0102467 in ?? ()
=> 0xf0103b8e:	push   %ebp
0xf0103b8e in ?? ()
=> 0xf0103b8f:	mov    %esp,%ebp
0xf0103b8f in ?? ()
=> 0xf0103b91:	sub    $0x18,%esp
0xf0103b91 in ?? ()
=> 0xf0103b94:	lea    0xc(%ebp),%eax
0xf0103b94 in ?? ()
=> 0xf0103b97:	mov    %eax,-0x10(%ebp)
0xf0103b97 in ?? ()
=> 0xf0103b9a:	mov    -0x10(%ebp),%eax
0xf0103b9a in ?? ()
=> 0xf0103b9d:	sub    $0x8,%esp
0xf0103b9d in ?? ()
=> 0xf0103ba0:	push   %eax
0xf0103ba0 in ?? ()
=> 0xf0103ba1:	pushl  0x8(%ebp)
0xf0103ba1 in ?? ()
=> 0xf0103ba4:	call   0xf0103b65
0xf0103ba4 in ?? ()
=> 0xf0103b65:	push   %ebp
0xf0103b65 in ?? ()
=> 0xf0103b66:	mov    %esp,%ebp
0xf0103b66 in ?? ()
=> 0xf0103b68:	sub    $0x18,%esp
0xf0103b68 in ?? ()
=> 0xf0103b6b:	movl   $0x0,-0xc(%ebp)
0xf0103b6b in ?? ()
=> 0xf0103b72:	pushl  0xc(%ebp)
0xf0103b72 in ?? ()
=> 0xf0103b75:	pushl  0x8(%ebp)
0xf0103b75 in ?? ()
=> 0xf0103b78:	lea    -0xc(%ebp),%eax
0xf0103b78 in ?? ()
=> 0xf0103b7b:	push   %eax
0xf0103b7b in ?? ()
=> 0xf0103b7c:	push   $0xf0103b41
0xf0103b7c in ?? ()
=> 0xf0103b81:	call   0xf0103cec
0xf0103b81 in ?? ()
=> 0xf0103cec:	push   %ebp
0xf0103cec in ?? ()
=> 0xf0103ced:	mov    %esp,%ebp
0xf0103ced in ?? ()
=> 0xf0103cef:	push   %esi
0xf0103cef in ?? ()
=> 0xf0103cf0:	push   %ebx
0xf0103cf0 in ?? ()
=> 0xf0103cf1:	sub    $0x20,%esp
0xf0103cf1 in ?? ()
=> 0xf0103cf4:	jmp    0xf0103d0d
0xf0103cf4 in ?? ()
=> 0xf0103d0d:	mov    0x10(%ebp),%eax
0xf0103d0d in ?? ()
=> 0xf0103d10:	lea    0x1(%eax),%edx
0xf0103d10 in ?? ()
=> 0xf0103d13:	mov    %edx,0x10(%ebp)
0xf0103d13 in ?? ()
=> 0xf0103d16:	movzbl (%eax),%eax
0xf0103d16 in ?? ()
=> 0xf0103d19:	movzbl %al,%ebx
0xf0103d19 in ?? ()
=> 0xf0103d1c:	cmp    $0x25,%ebx
0xf0103d1c in ?? ()
=> 0xf0103d1f:	jne    0xf0103cf6
0xf0103d1f in ?? ()
=> 0xf0103cf6:	test   %ebx,%ebx
0xf0103cf6 in ?? ()
=> 0xf0103cf8:	je     0xf0104085
0xf0103cf8 in ?? ()
=> 0xf0103cfe:	sub    $0x8,%esp
0xf0103cfe in ?? ()
=> 0xf0103d01:	pushl  0xc(%ebp)
0xf0103d01 in ?? ()
=> 0xf0103d04:	push   %ebx
0xf0103d04 in ?? ()
=> 0xf0103d05:	mov    0x8(%ebp),%eax
0xf0103d05 in ?? ()
=> 0xf0103d08:	call   *%eax
0xf0103d08 in ?? ()
=> 0xf0103b41:	push   %ebp
0xf0103b41 in ?? ()
=> 0xf0103b42:	mov    %esp,%ebp
0xf0103b42 in ?? ()
=> 0xf0103b44:	sub    $0x8,%esp
0xf0103b44 in ?? ()
=> 0xf0103b47:	sub    $0xc,%esp
0xf0103b47 in ?? ()
=> 0xf0103b4a:	pushl  0x8(%ebp)
0xf0103b4a in ?? ()
=> 0xf0103b4d:	call   0xf01012be
0xf0103b4d in ?? ()
=> 0xf01012be:	push   %ebp
0xf01012be in ?? ()
=> 0xf01012bf:	mov    %esp,%ebp
0xf01012bf in ?? ()
=> 0xf01012c1:	sub    $0x8,%esp
0xf01012c1 in ?? ()
=> 0xf01012c4:	sub    $0xc,%esp
0xf01012c4 in ?? ()
=> 0xf01012c7:	pushl  0x8(%ebp)
0xf01012c7 in ?? ()
=> 0xf01012ca:	call   0xf0100ff0
0xf01012ca in ?? ()
=> 0xf0100ff0:	push   %ebp
0xf0100ff0 in ?? ()
=> 0xf0100ff1:	mov    %esp,%ebp
0xf0100ff1 in ?? ()
=> 0xf0100ff3:	sub    $0x8,%esp
0xf0100ff3 in ?? ()
=> 0xf0100ff6:	pushl  0x8(%ebp)
0xf0100ff6 in ?? ()
=> 0xf0100ff9:	call   0xf0100b35
0xf0100ff9 in ?? ()
=> 0xf0100b35:	push   %ebp
0xf0100b35 in ?? ()
=> 0xf0100b36:	mov    %esp,%ebp
0xf0100b36 in ?? ()
=> 0xf0100b38:	sub    $0x30,%esp
0xf0100b38 in ?? ()
=> 0xf0100b3b:	movl   $0x0,-0x4(%ebp)
0xf0100b3b in ?? ()
=> 0xf0100b42:	jmp    0xf0100b4d
0xf0100b42 in ?? ()
=> 0xf0100b4d:	movl   $0x3fd,-0x20(%ebp)
0xf0100b4d in ?? ()
=> 0xf0100b54:	mov    -0x20(%ebp),%eax
0xf0100b54 in ?? ()
=> 0xf0100b57:	mov    %eax,%edx
0xf0100b57 in ?? ()
=> 0xf0100b59:	in     (%dx),%al
0xf0100b59 in ?? ()
=> 0xf0100b5a:	mov    %al,-0x21(%ebp)
0xf0100b5a in ?? ()
=> 0xf0100b5d:	movzbl -0x21(%ebp),%eax
0xf0100b5d in ?? ()
=> 0xf0100b61:	movzbl %al,%eax
0xf0100b61 in ?? ()
=> 0xf0100b64:	and    $0x20,%eax
0xf0100b64 in ?? ()
=> 0xf0100b67:	test   %eax,%eax
0xf0100b67 in ?? ()
=> 0xf0100b69:	jne    0xf0100b74
0xf0100b69 in ?? ()
=> 0xf0100b74:	cmpl   $0x8,0x8(%ebp)
0xf0100b74 in ?? ()
=> 0xf0100b78:	jne    0xf0100c35
0xf0100b78 in ?? ()
=> 0xf0100c35:	mov    0x8(%ebp),%eax
0xf0100c35 in ?? ()
=> 0xf0100c38:	movzbl %al,%eax
0xf0100c38 in ?? ()
=> 0xf0100c3b:	movl   $0x3f8,-0x1c(%ebp)
0xf0100c3b in ?? ()
=> 0xf0100c42:	mov    %al,-0x27(%ebp)
0xf0100c42 in ?? ()
=> 0xf0100c45:	movzbl -0x27(%ebp),%eax
0xf0100c45 in ?? ()
=> 0xf0100c49:	mov    -0x1c(%ebp),%edx
0xf0100c49 in ?? ()
=> 0xf0100c4c:	out    %al,(%dx)
0xf0100c4c in ?? ()
=> 0xf0100c4d:	leave  
0xf0100c4d in ?? ()
=> 0xf0100c4e:	ret    
0xf0100c4e in ?? ()
=> 0xf0100ffe:	add    $0x4,%esp
0xf0100ffe in ?? ()
=> 0xf0101001:	sub    $0xc,%esp
0xf0101001 in ?? ()
=> 0xf0101004:	pushl  0x8(%ebp)
0xf0101004 in ?? ()
=> 0xf0101007:	call   0xf0100de8
0xf0101007 in ?? ()
=> 0xf0100de8:	push   %ebp
0xf0100de8 in ?? ()
=> 0xf0100de9:	mov    %esp,%ebp
0xf0100de9 in ?? ()
=> 0xf0100deb:	push   %ebx
0xf0100deb in ?? ()
=> 0xf0100dec:	sub    $0x24,%esp
0xf0100dec in ?? ()
=> 0xf0100def:	mov    0x8(%ebp),%eax
0xf0100def in ?? ()
=> 0xf0100df2:	mov    $0x0,%al
0xf0100df2 in ?? ()
=> 0xf0100df4:	test   %eax,%eax
0xf0100df4 in ?? ()
=> 0xf0100df6:	jne    0xf0100dff
0xf0100df6 in ?? ()
=> 0xf0100df8:	orl    $0x700,0x8(%ebp)
0xf0100df8 in ?? ()
=> 0xf0100dff:	mov    0x8(%ebp),%eax
0xf0100dff in ?? ()
=> 0xf0100e02:	movzbl %al,%eax
0xf0100e02 in ?? ()
=> 0xf0100e05:	cmp    $0x9,%eax
0xf0100e05 in ?? ()
=> 0xf0100e08:	je     0xf0100eb9
0xf0100e08 in ?? ()
=> 0xf0100e0e:	cmp    $0x9,%eax
0xf0100e0e in ?? ()
=> 0xf0100e11:	jg     0xf0100e1d
0xf0100e11 in ?? ()
=> 0xf0100e1d:	cmp    $0xa,%eax
0xf0100e1d in ?? ()
=> 0xf0100e20:	je     0xf0100e6f
0xf0100e20 in ?? ()
=> 0xf0100e22:	cmp    $0xd,%eax
0xf0100e22 in ?? ()
=> 0xf0100e25:	je     0xf0100e7f
0xf0100e25 in ?? ()
=> 0xf0100e27:	jmp    0xf0100eef
0xf0100e27 in ?? ()
=> 0xf0100eef:	mov    0xf012b5a8,%ecx
0xf0100eef in ?? ()
=> 0xf0100ef5:	movzwl 0xf012b5ac,%eax
0xf0100ef5 in ?? ()
=> 0xf0100efc:	lea    0x1(%eax),%edx
0xf0100efc in ?? ()
=> 0xf0100eff:	mov    %dx,0xf012b5ac
0xf0100eff in ?? ()
=> 0xf0100f06:	movzwl %ax,%eax
0xf0100f06 in ?? ()
=> 0xf0100f09:	add    %eax,%eax
0xf0100f09 in ?? ()
=> 0xf0100f0b:	add    %ecx,%eax
0xf0100f0b in ?? ()
=> 0xf0100f0d:	mov    0x8(%ebp),%edx
0xf0100f0d in ?? ()
=> 0xf0100f10:	mov    %dx,(%eax)
0xf0100f10 in ?? ()
=> 0xf0100f13:	jmp    0xf0100f16
0xf0100f13 in ?? ()
=> 0xf0100f16:	movzwl 0xf012b5ac,%eax
0xf0100f16 in ?? ()
=> 0xf0100f1d:	cmp    $0x7cf,%ax
0xf0100f1d in ?? ()
=> 0xf0100f21:	jbe    0xf0100f7c
0xf0100f21 in ?? ()
=> 0xf0100f7c:	mov    0xf012b5a4,%eax
0xf0100f7c in ?? ()
=> 0xf0100f81:	mov    %eax,-0x10(%ebp)
0xf0100f81 in ?? ()
=> 0xf0100f84:	movb   $0xe,-0x20(%ebp)
0xf0100f84 in ?? ()
=> 0xf0100f88:	movzbl -0x20(%ebp),%eax
0xf0100f88 in ?? ()
=> 0xf0100f8c:	mov    -0x10(%ebp),%edx
0xf0100f8c in ?? ()
=> 0xf0100f8f:	out    %al,(%dx)
0xf0100f8f in ?? ()
=> 0xf0100f90:	movzwl 0xf012b5ac,%eax
0xf0100f90 in ?? ()
=> 0xf0100f97:	shr    $0x8,%ax
0xf0100f97 in ?? ()
=> 0xf0100f9b:	movzbl %al,%eax
0xf0100f9b in ?? ()
=> 0xf0100f9e:	mov    0xf012b5a4,%edx
0xf0100f9e in ?? ()
=> 0xf0100fa4:	add    $0x1,%edx
0xf0100fa4 in ?? ()
=> 0xf0100fa7:	mov    %edx,-0x14(%ebp)
0xf0100fa7 in ?? ()
=> 0xf0100faa:	mov    %al,-0x1f(%ebp)
0xf0100faa in ?? ()
=> 0xf0100fad:	movzbl -0x1f(%ebp),%eax
0xf0100fad in ?? ()
=> 0xf0100fb1:	mov    -0x14(%ebp),%edx
0xf0100fb1 in ?? ()
=> 0xf0100fb4:	out    %al,(%dx)
0xf0100fb4 in ?? ()
=> 0xf0100fb5:	mov    0xf012b5a4,%eax
0xf0100fb5 in ?? ()
=> 0xf0100fba:	mov    %eax,-0x18(%ebp)
0xf0100fba in ?? ()
=> 0xf0100fbd:	movb   $0xf,-0x1e(%ebp)
0xf0100fbd in ?? ()
=> 0xf0100fc1:	movzbl -0x1e(%ebp),%eax
0xf0100fc1 in ?? ()
=> 0xf0100fc5:	mov    -0x18(%ebp),%edx
0xf0100fc5 in ?? ()
=> 0xf0100fc8:	out    %al,(%dx)
0xf0100fc8 in ?? ()
=> 0xf0100fc9:	movzwl 0xf012b5ac,%eax
0xf0100fc9 in ?? ()
=> 0xf0100fd0:	movzbl %al,%eax
0xf0100fd0 in ?? ()
=> 0xf0100fd3:	mov    0xf012b5a4,%edx
0xf0100fd3 in ?? ()
=> 0xf0100fd9:	add    $0x1,%edx
0xf0100fd9 in ?? ()
=> 0xf0100fdc:	mov    %edx,-0x1c(%ebp)
0xf0100fdc in ?? ()
=> 0xf0100fdf:	mov    %al,-0x1d(%ebp)
0xf0100fdf in ?? ()
=> 0xf0100fe2:	movzbl -0x1d(%ebp),%eax
0xf0100fe2 in ?? ()
=> 0xf0100fe6:	mov    -0x1c(%ebp),%edx
0xf0100fe6 in ?? ()
=> 0xf0100fe9:	out    %al,(%dx)
0xf0100fe9 in ?? ()
=> 0xf0100fea:	nop
0xf0100fea in ?? ()
=> 0xf0100feb:	mov    -0x4(%ebp),%ebx
0xf0100feb in ?? ()
=> 0xf0100fee:	leave  
0xf0100fee in ?? ()
=> 0xf0100fef:	ret    
0xf0100fef in ?? ()
=> 0xf010100c:	add    $0x10,%esp
0xf010100c in ?? ()
=> 0xf010100f:	nop
0xf010100f in ?? ()
=> 0xf0101010:	leave  
0xf0101010 in ?? ()
=> 0xf0101011:	ret    
0xf0101011 in ?? ()
=> 0xf01012cf:	add    $0x10,%esp
0xf01012cf in ?? ()
=> 0xf01012d2:	nop
0xf01012d2 in ?? ()
=> 0xf01012d3:	leave  
0xf01012d3 in ?? ()
=> 0xf01012d4:	ret    
0xf01012d4 in ?? ()
=> 0xf0103b52:	add    $0x10,%esp
0xf0103b52 in ?? ()
=> 0xf0103b55:	mov    0xc(%ebp),%eax
0xf0103b55 in ?? ()
=> 0xf0103b58:	mov    (%eax),%eax
0xf0103b58 in ?? ()
=> 0xf0103b5a:	lea    0x1(%eax),%edx
0xf0103b5a in ?? ()
=> 0xf0103b5d:	mov    0xc(%ebp),%eax
0xf0103b5d in ?? ()
=> 0xf0103b60:	mov    %edx,(%eax)
0xf0103b60 in ?? ()
=> 0xf0103b62:	nop
0xf0103b62 in ?? ()
=> 0xf0103b63:	leave  
0xf0103b63 in ?? ()
=> 0xf0103b64:	ret    
0xf0103b64 in ?? ()
=> 0xf0103d0a:	add    $0x10,%esp
0xf0103d0a in ?? ()
=> 0xf0103d0d:	mov    0x10(%ebp),%eax
0xf0103d0d in ?? ()
=> 0xf0103d10:	lea    0x1(%eax),%edx
0xf0103d10 in ?? ()
=> 0xf0103d13:	mov    %edx,0x10(%ebp)
0xf0103d13 in ?? ()
=> 0xf0103d16:	movzbl (%eax),%eax
0xf0103d16 in ?? ()
=> 0xf0103d19:	movzbl %al,%ebx
0xf0103d19 in ?? ()
=> 0xf0103d1c:	cmp    $0x25,%ebx
0xf0103d1c in ?? ()
=> 0xf0103d1f:	jne    0xf0103cf6
0xf0103d1f in ?? ()
=> 0xf0103cf6:	test   %ebx,%ebx
0xf0103cf6 in ?? ()
=> 0xf0103cf8:	je     0xf0104085
0xf0103cf8 in ?? ()
=> 0xf0103cfe:	sub    $0x8,%esp
0xf0103cfe in ?? ()
=> 0xf0103d01:	pushl  0xc(%ebp)
0xf0103d01 in ?? ()
=> 0xf0103d04:	push   %ebx
0xf0103d04 in ?? ()
=> 0xf0103d05:	mov    0x8(%ebp),%eax
0xf0103d05 in ?? ()
=> 0xf0103d08:	call   *%eax
0xf0103d08 in ?? ()
=> 0xf0103b41:	push   %ebp
0xf0103b41 in ?? ()
=> 0xf0103b42:	mov    %esp,%ebp
0xf0103b42 in ?? ()
=> 0xf0103b44:	sub    $0x8,%esp
0xf0103b44 in ?? ()
=> 0xf0103b47:	sub    $0xc,%esp
0xf0103b47 in ?? ()
=> 0xf0103b4a:	pushl  0x8(%ebp)
0xf0103b4a in ?? ()
=> 0xf0103b4d:	call   0xf01012be
0xf0103b4d in ?? ()
=> 0xf01012be:	push   %ebp
0xf01012be in ?? ()
=> 0xf01012bf:	mov    %esp,%ebp
0xf01012bf in ?? ()
=> 0xf01012c1:	sub    $0x8,%esp
0xf01012c1 in ?? ()
=> 0xf01012c4:	sub    $0xc,%esp
0xf01012c4 in ?? ()
=> 0xf01012c7:	pushl  0x8(%ebp)
0xf01012c7 in ?? ()
=> 0xf01012ca:	call   0xf0100ff0
0xf01012ca in ?? ()
=> 0xf0100ff0:	push   %ebp
0xf0100ff0 in ?? ()
=> 0xf0100ff1:	mov    %esp,%ebp
0xf0100ff1 in ?? ()
=> 0xf0100ff3:	sub    $0x8,%esp
0xf0100ff3 in ?? ()
=> 0xf0100ff6:	pushl  0x8(%ebp)
0xf0100ff6 in ?? ()
=> 0xf0100ff9:	call   0xf0100b35
0xf0100ff9 in ?? ()
=> 0xf0100b35:	push   %ebp
0xf0100b35 in ?? ()
=> 0xf0100b36:	mov    %esp,%ebp
0xf0100b36 in ?? ()
=> 0xf0100b38:	sub    $0x30,%esp
0xf0100b38 in ?? ()
=> 0xf0100b3b:	movl   $0x0,-0x4(%ebp)
0xf0100b3b in ?? ()
=> 0xf0100b42:	jmp    0xf0100b4d
0xf0100b42 in ?? ()
=> 0xf0100b4d:	movl   $0x3fd,-0x20(%ebp)
0xf0100b4d in ?? ()
=> 0xf0100b54:	mov    -0x20(%ebp),%eax
0xf0100b54 in ?? ()
=> 0xf0100b57:	mov    %eax,%edx
0xf0100b57 in ?? ()
=> 0xf0100b59:	in     (%dx),%al
0xf0100b59 in ?? ()
=> 0xf0100b5a:	mov    %al,-0x21(%ebp)
0xf0100b5a in ?? ()
=> 0xf0100b5d:	movzbl -0x21(%ebp),%eax
0xf0100b5d in ?? ()
=> 0xf0100b61:	movzbl %al,%eax
0xf0100b61 in ?? ()
=> 0xf0100b64:	and    $0x20,%eax
0xf0100b64 in ?? ()
=> 0xf0100b67:	test   %eax,%eax
0xf0100b67 in ?? ()
=> 0xf0100b69:	jne    0xf0100b74
0xf0100b69 in ?? ()
=> 0xf0100b74:	cmpl   $0x8,0x8(%ebp)
0xf0100b74 in ?? ()
=> 0xf0100b78:	jne    0xf0100c35
0xf0100b78 in ?? ()
=> 0xf0100c35:	mov    0x8(%ebp),%eax
0xf0100c35 in ?? ()
=> 0xf0100c38:	movzbl %al,%eax
0xf0100c38 in ?? ()
=> 0xf0100c3b:	movl   $0x3f8,-0x1c(%ebp)
0xf0100c3b in ?? ()
=> 0xf0100c42:	mov    %al,-0x27(%ebp)
0xf0100c42 in ?? ()
=> 0xf0100c45:	movzbl -0x27(%ebp),%eax
0xf0100c45 in ?? ()
=> 0xf0100c49:	mov    -0x1c(%ebp),%edx
0xf0100c49 in ?? ()
=> 0xf0100c4c:	out    %al,(%dx)
0xf0100c4c in ?? ()
=> 0xf0100c4d:	leave  
0xf0100c4d in ?? ()
=> 0xf0100c4e:	ret    
0xf0100c4e in ?? ()
=> 0xf0100ffe:	add    $0x4,%esp
0xf0100ffe in ?? ()
=> 0xf0101001:	sub    $0xc,%esp
0xf0101001 in ?? ()
=> 0xf0101004:	pushl  0x8(%ebp)
0xf0101004 in ?? ()
=> 0xf0101007:	call   0xf0100de8
0xf0101007 in ?? ()
=> 0xf0100de8:	push   %ebp
0xf0100de8 in ?? ()
=> 0xf0100de9:	mov    %esp,%ebp
0xf0100de9 in ?? ()
=> 0xf0100deb:	push   %ebx
0xf0100deb in ?? ()
=> 0xf0100dec:	sub    $0x24,%esp
0xf0100dec in ?? ()
=> 0xf0100def:	mov    0x8(%ebp),%eax
0xf0100def in ?? ()
=> 0xf0100df2:	mov    $0x0,%al
0xf0100df2 in ?? ()
=> 0xf0100df4:	test   %eax,%eax
0xf0100df4 in ?? ()
=> 0xf0100df6:	jne    0xf0100dff
0xf0100df6 in ?? ()
=> 0xf0100df8:	orl    $0x700,0x8(%ebp)
0xf0100df8 in ?? ()
=> 0xf0100dff:	mov    0x8(%ebp),%eax
0xf0100dff in ?? ()
=> 0xf0100e02:	movzbl %al,%eax
0xf0100e02 in ?? ()
=> 0xf0100e05:	cmp    $0x9,%eax
0xf0100e05 in ?? ()
=> 0xf0100e08:	je     0xf0100eb9
0xf0100e08 in ?? ()
=> 0xf0100e0e:	cmp    $0x9,%eax
0xf0100e0e in ?? ()
=> 0xf0100e11:	jg     0xf0100e1d
0xf0100e11 in ?? ()
=> 0xf0100e1d:	cmp    $0xa,%eax
0xf0100e1d in ?? ()
=> 0xf0100e20:	je     0xf0100e6f
0xf0100e20 in ?? ()
=> 0xf0100e22:	cmp    $0xd,%eax
0xf0100e22 in ?? ()
=> 0xf0100e25:	je     0xf0100e7f
0xf0100e25 in ?? ()
=> 0xf0100e27:	jmp    0xf0100eef
0xf0100e27 in ?? ()
=> 0xf0100eef:	mov    0xf012b5a8,%ecx
0xf0100eef in ?? ()
=> 0xf0100ef5:	movzwl 0xf012b5ac,%eax
0xf0100ef5 in ?? ()
=> 0xf0100efc:	lea    0x1(%eax),%edx
0xf0100efc in ?? ()
=> 0xf0100eff:	mov    %dx,0xf012b5ac
0xf0100eff in ?? ()
=> 0xf0100f06:	movzwl %ax,%eax
0xf0100f06 in ?? ()
=> 0xf0100f09:	add    %eax,%eax
0xf0100f09 in ?? ()
=> 0xf0100f0b:	add    %ecx,%eax
0xf0100f0b in ?? ()
=> 0xf0100f0d:	mov    0x8(%ebp),%edx
0xf0100f0d in ?? ()
=> 0xf0100f10:	mov    %dx,(%eax)
0xf0100f10 in ?? ()
=> 0xf0100f13:	jmp    0xf0100f16
0xf0100f13 in ?? ()
=> 0xf0100f16:	movzwl 0xf012b5ac,%eax
0xf0100f16 in ?? ()
=> 0xf0100f1d:	cmp    $0x7cf,%ax
0xf0100f1d in ?? ()
=> 0xf0100f21:	jbe    0xf0100f7c
0xf0100f21 in ?? ()
=> 0xf0100f7c:	mov    0xf012b5a4,%eax
0xf0100f7c in ?? ()
=> 0xf0100f81:	mov    %eax,-0x10(%ebp)
0xf0100f81 in ?? ()
=> 0xf0100f84:	movb   $0xe,-0x20(%ebp)
0xf0100f84 in ?? ()
=> 0xf0100f88:	movzbl -0x20(%ebp),%eax
0xf0100f88 in ?? ()
=> 0xf0100f8c:	mov    -0x10(%ebp),%edx
0xf0100f8c in ?? ()
=> 0xf0100f8f:	out    %al,(%dx)
0xf0100f8f in ?? ()
=> 0xf0100f90:	movzwl 0xf012b5ac,%eax
0xf0100f90 in ?? ()
=> 0xf0100f97:	shr    $0x8,%ax
0xf0100f97 in ?? ()
=> 0xf0100f9b:	movzbl %al,%eax
0xf0100f9b in ?? ()
=> 0xf0100f9e:	mov    0xf012b5a4,%edx
0xf0100f9e in ?? ()
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Reading symbols from damnfs...done.
Breakpoint 1 at 0x80001da4: file damnfs.c, line 674.
Continuing.
[  1b:80001da4]    0x80001ff6 <ide_write+104>:	test   %bx,%bx

Breakpoint 1, bc_init () at damnfs.c:674
674	{
[  1b:80001da5]    0x80001ff7 <ide_write+105>:	(bad)  0x2f(%si)
0x80001da5	674	{
[  1b:80001da7]    0x80001ff9 <ide_write+107>:	das    
0x80001da7	674	{
[  1b:80001daa]    0x80001ffc <ide_write+110>:	add    %al,(%bx,%si)
675		set_pgfault_handler(bc_pgfault);
[  1b:80001daf]    0x80002001 <ide_write+115>:	(bad)  
0x80001daf	675		set_pgfault_handler(bc_pgfault);
[  1b:80003031]    0x80003283 <vprintfmt+89>:	(bad)  
set_pgfault_handler (handler=0x800010a9 <bc_pgfault>) at pgfault.c:25
25	{
[  1b:80003032]    0x80003284 <vprintfmt+90>:	(bad)  
0x80003032	25	{
[  1b:80003034]    0x80003286 <vprintfmt+92>:	inc    %di
0x80003034	25	{
[  1b:80003037]    0x80003289 <vprintfmt+95>:	in     $0xff,%al
28		if (_pgfault_handler == 0) {
[  1b:8000303e]    0x80003290 <vprintfmt+102>:	add    %al,(%bx,%si)
0x8000303e	28		if (_pgfault_handler == 0) {
[  1b:80003040]    0x80003292 <vprintfmt+104>:	add    %bh,0x0(%bp,%di)
30			if((r = sys_page_alloc(0, (void *)(UXSTACKTOP - PGSIZE), PTE_P|PTE_U|PTE_W)) < 0)
[  1b:80003043]    0x80003295 <vprintfmt+107>:	add    %al,(%bx,%si)
0x80003043	30			if((r = sys_page_alloc(0, (void *)(UXSTACKTOP - PGSIZE), PTE_P|PTE_U|PTE_W)) < 0)
[  1b:80003045]    0x80003297 <vprintfmt+109>:	add    %ch,%bl
0x80003045	30			if((r = sys_page_alloc(0, (void *)(UXSTACKTOP - PGSIZE), PTE_P|PTE_U|PTE_W)) < 0)
[  1b:8000304a]    0x8000329c <vprintfmt+114>:	adc    %al,%dh
0x8000304a	30			if((r = sys_page_alloc(0, (void *)(UXSTACKTOP - PGSIZE), PTE_P|PTE_U|PTE_W)) < 0)
[  1b:8000304c]    0x8000329e <vprintfmt+116>:	inc    %bp
0x8000304c	30			if((r = sys_page_alloc(0, (void *)(UXSTACKTOP - PGSIZE), PTE_P|PTE_U|PTE_W)) < 0)
[  1b:80002af9]    0x80002d4b <devfile_trunc+22>:	mov    $0x0,%al
sys_page_alloc (envid=0x0, va=0xeebff000, perm=0x7) at syscall.c:70
70	{
[  1b:80002afa]    0x80002d4c <devfile_trunc+23>:	add    %al,0xba(%bx,%si)
0x80002afa	70	{
[  1b:80002afc]    0x80002d4e <devfile_trunc+25>:	mov    $0x0,%dx
0x80002afc	70	{
[  1b:80002afd]    0x80002d4f <devfile_trunc+26>:	add    %al,(%bx,%si)
0x80002afd	70	{
[  1b:80002afe]    0x80002d50 <devfile_trunc+27>:	add    %al,(%bx,%si)
0x80002afe	70	{
[  1b:80002aff]    0x80002d51 <devfile_trunc+28>:	add    %al,(%bx,%si)
0x80002aff	70	{
[  1b:80002b02]    0x80002d54 <devfile_trunc+31>:	add    (%bx,%si),%al
syscall (a5=0x0, a4=0x0, a3=0x7, a2=0xeebff000, a1=0x0, check=0x1, num=0x4) at syscall.c:21
21		asm volatile("int %1\n"
[  1b:80002b07]    0x80002d59 <devfile_trunc+36>:	(bad)  
0x80002b07	21		asm volatile("int %1\n"
[  1b:80002b0c]    0x80002d5e <devfile_trunc+41>:	ret    
0x80002b0c	21		asm volatile("int %1\n"
[  1b:80002b0f]    0x80002d61 <devfile_flush+2>:	in     $0x83,%ax
0x80002b0f	21		asm volatile("int %1\n"
[  1b:80002b12]    0x80002d64 <devfile_flush+5>:	or     %cl,0x845(%bp,%di)
0x80002b12	21		asm volatile("int %1\n"
[  1b:80002b15]    0x80002d67 <devfile_flush+8>:	or     %cl,0xc40(%bp,%di)
0x80002b15	21		asm volatile("int %1\n"
[  1b:80002b17]    0x80002d69 <devfile_flush+10>:	inc    %ax
0x80002b17	21		asm volatile("int %1\n"
The target architecture is assumed to be i386
=> 0xf0101652:	push   $0x30
0xf0101652 in ?? ()
=> 0xf0101654:	jmp    0xf010165c
0xf0101654 in ?? ()
=> 0xf010165c:	push   %ds
0xf010165c in ?? ()
=> 0xf010165d:	push   %es
0xf010165d in ?? ()
=> 0xf010165e:	pusha  
0xf010165e in ?? ()
=> 0xf010165f:	mov    $0x10,%ax
0xf010165f in ?? ()
=> 0xf0101663:	mov    %eax,%ds
0xf0101663 in ?? ()
=> 0xf0101665:	mov    %eax,%es
0xf0101665 in ?? ()
=> 0xf0101667:	push   %esp
0xf0101667 in ?? ()
=> 0xf0101668:	call   0xf01025a6
0xf0101668 in ?? ()
=> 0xf01025a6:	push   %ebp
0xf01025a6 in ?? ()
=> 0xf01025a7:	mov    %esp,%ebp
0xf01025a7 in ?? ()
=> 0xf01025a9:	push   %edi
0xf01025a9 in ?? ()
=> 0xf01025aa:	push   %esi
0xf01025aa in ?? ()
=> 0xf01025ab:	push   %ebx
0xf01025ab in ?? ()
=> 0xf01025ac:	sub    $0xc,%esp
0xf01025ac in ?? ()
=> 0xf01025af:	cld    
0xf01025af in ?? ()
=> 0xf01025b0:	mov    0x8(%ebp),%eax
0xf01025b0 in ?? ()
=> 0xf01025b3:	movzwl 0x34(%eax),%eax
0xf01025b3 in ?? ()
=> 0xf01025b7:	movzwl %ax,%eax
0xf01025b7 in ?? ()
=> 0xf01025ba:	and    $0x3,%eax
0xf01025ba in ?? ()
=> 0xf01025bd:	cmp    $0x3,%eax
0xf01025bd in ?? ()
=> 0xf01025c0:	jne    0xf0102614
0xf01025c0 in ?? ()
16		//
17		// The last clause tells the assembler that this can
18		// potentially change the condition codes and arbitrary
19		// memory locations.
20	
21		asm volatile("int %1\n"
22			: "=a" (ret)
23			: "i" (T_SYSCALL),
24			  "a" (num),
25			  "d" (a1),
=> 0xf01025c2:	call   0xf010166d
0xf01025c2 in ?? ()
=> 0xf010166d:	push   %ebp
0xf010166d in ?? ()
=> 0xf010166e:	mov    %esp,%ebp
0xf010166e in ?? ()
=> 0xf0101670:	sub    $0x8,%esp
0xf0101670 in ?? ()
=> 0xf0101673:	sub    $0xc,%esp
0xf0101673 in ?? ()
=> 0xf0101676:	push   $0xf012c46c
0xf0101676 in ?? ()
Breakpoint 2 at 0x80003051: file pgfault.c, line 30.
Continuing.
The target architecture is assumed to be i8086
[  1b:80003051]    0x800032a3 <vprintfmt+121>:	add    %cx,0x1045(%bx,%di)

Breakpoint 2, 0x80003051 in set_pgfault_handler (handler=0x800010a9 <bc_pgfault>) at pgfault.c:30
30			if((r = sys_page_alloc(0, (void *)(UXSTACKTOP - PGSIZE), PTE_P|PTE_U|PTE_W)) < 0)
$1 = 0x15
[  1b:80003054]    0x800032a6 <vprintfmt+124>:	adc    %cl,(%bx)
0x80003054	30			if((r = sys_page_alloc(0, (void *)(UXSTACKTOP - PGSIZE), PTE_P|PTE_U|PTE_W)) < 0)
[  1b:80003056]    0x800032a8 <vprintfmt+126>:	mov    $0x6,%dh
0x80003056	30			if((r = sys_page_alloc(0, (void *)(UXSTACKTOP - PGSIZE), PTE_P|PTE_U|PTE_W)) < 0)
[  1b:8000306a]    0x800032bc <vprintfmt+146>:	and    $0x85,%al
32			if((r = sys_env_set_pgfault_upcall(0, _pgfault_upcall)) < 0)
[  1b:8000306d]    0x800032bf <vprintfmt+149>:	dec    %cx
0x8000306d	32			if((r = sys_env_set_pgfault_upcall(0, _pgfault_upcall)) < 0)
[  1b:80003072]    0x800032c4 <vprintfmt+154>:	adc    %al,%dh
0x80003072	32			if((r = sys_env_set_pgfault_upcall(0, _pgfault_upcall)) < 0)
[  1b:80003074]    0x800032c6 <vprintfmt+156>:	inc    %bp
0x80003074	32			if((r = sys_env_set_pgfault_upcall(0, _pgfault_upcall)) < 0)
[  1b:80002c44]    0x80002e96 <open+50>:	add    %dh,-0x8000(%bx,%si)
sys_env_set_pgfault_upcall (envid=0x0, upcall=0x80004431 <_pgfault_upcall>) at syscall.c:102
102	{
[  1b:80002c45]    0x80002e97 <open+51>:	mov    $0x0,%al
0x80002c45	102	{
[  1b:80002c47]    0x80002e99 <open+53>:	sub    $0x6f,%al
0x80002c47	102	{
[  1b:80002c48]    0x80002e9a <open+54>:	call   0x8000260c <strnlen+55>
0x80002c48	102	{
[  1b:80002c49]    0x80002e9b <open+55>:	outsw  %ds:(%si),(%dx)
0x80002c49	102	{
[  1b:80002c4a]    0x80002e9c <open+56>:	idiv   %di
0x80002c4a	102	{
[  1b:80002c4d]    0x80002e9f <open+59>:	mov    0xc(%di),%ax
syscall (a5=0x0, a4=0x0, a3=0x0, a2=0x80004431, a1=0x0, check=0x1, num=0xa) at syscall.c:21
21		asm volatile("int %1\n"
[  1b:80002c52]    0x80002ea4 <open+64>:	mov    $0x0,%al
0x80002c52	21		asm volatile("int %1\n"
[  1b:80002c57]    0x80002ea9 <open+69>:	hlt    
0x80002c57	21		asm volatile("int %1\n"
[  1b:80002c5a]    0x80002eac <open+72>:	add    %al,(%bx,%si)
0x80002c5a	21		asm volatile("int %1\n"
[  1b:80002c5d]    0x80002eaf <open+75>:	call   0x80002ce8 <sys_ipc_recv+63>
0x80002c5d	21		asm volatile("int %1\n"
[  1b:80002c5f]    0x80002eb1 <open+77>:	(bad)  
0x80002c5f	21		asm volatile("int %1\n"
[  1b:80002c61]    0x80002eb3 <open+79>:	decw   -0x7c3d(%bx,%di)
0x80002c61	21		asm volatile("int %1\n"
The target architecture is assumed to be i386
=> 0xf0101652:	push   $0x30
0xf0101652 in ?? ()
=> 0xf0101654:	jmp    0xf010165c
0xf0101654 in ?? ()
=> 0xf010165c:	push   %ds
0xf010165c in ?? ()
=> 0xf010165d:	push   %es
0xf010165d in ?? ()
=> 0xf010165e:	pusha  
0xf010165e in ?? ()
=> 0xf010165f:	mov    $0x10,%ax
0xf010165f in ?? ()
=> 0xf0101663:	mov    %eax,%ds
0xf0101663 in ?? ()
=> 0xf0101665:	mov    %eax,%es
0xf0101665 in ?? ()
=> 0xf0101667:	push   %esp
0xf0101667 in ?? ()
=> 0xf0101668:	call   0xf01025a6
0xf0101668 in ?? ()
=> 0xf01025a6:	push   %ebp
0xf01025a6 in ?? ()
=> 0xf01025a7:	mov    %esp,%ebp
0xf01025a7 in ?? ()
=> 0xf01025a9:	push   %edi
0xf01025a9 in ?? ()
=> 0xf01025aa:	push   %esi
0xf01025aa in ?? ()
=> 0xf01025ab:	push   %ebx
0xf01025ab in ?? ()
=> 0xf01025ac:	sub    $0xc,%esp
0xf01025ac in ?? ()
=> 0xf01025af:	cld    
0xf01025af in ?? ()
=> 0xf01025b0:	mov    0x8(%ebp),%eax
0xf01025b0 in ?? ()
=> 0xf01025b3:	movzwl 0x34(%eax),%eax
0xf01025b3 in ?? ()
=> 0xf01025b7:	movzwl %ax,%eax
0xf01025b7 in ?? ()
=> 0xf01025ba:	and    $0x3,%eax
0xf01025ba in ?? ()
=> 0xf01025bd:	cmp    $0x3,%eax
0xf01025bd in ?? ()
=> 0xf01025c0:	jne    0xf0102614
0xf01025c0 in ?? ()
=> 0xf01025c2:	call   0xf010166d
0xf01025c2 in ?? ()
=> 0xf010166d:	push   %ebp
0xf010166d in ?? ()
=> 0xf010166e:	mov    %esp,%ebp
0xf010166e in ?? ()
=> 0xf0101670:	sub    $0x8,%esp
0xf0101670 in ?? ()
=> 0xf0101673:	sub    $0xc,%esp
0xf0101673 in ?? ()
=> 0xf0101676:	push   $0xf012c46c
0xf0101676 in ?? ()
=> 0xf010167b:	call   0xf0103b11
0xf010167b in ?? ()
=> 0xf0103b11:	push   %ebp
0xf0103b11 in ?? ()
=> 0xf0103b12:	mov    %esp,%ebp
0xf0103b12 in ?? ()
=> 0xf0103b14:	jmp    0xf0103b18
0xf0103b14 in ?? ()
=> 0xf0103b18:	mov    0x8(%ebp),%eax
0xf0103b18 in ?? ()
=> 0xf0103b1b:	push   $0x1
0xf0103b1b in ?? ()
=> 0xf0103b1d:	push   %eax
0xf0103b1d in ?? ()
=> 0xf0103b1e:	call   0xf0103ae8
0xf0103b1e in ?? ()
=> 0xf0103ae8:	push   %ebp
0xf0103ae8 in ?? ()
=> 0xf0103ae9:	mov    %esp,%ebp
0xf0103ae9 in ?? ()
=> 0xf0103aeb:	sub    $0x10,%esp
0xf0103aeb in ?? ()
=> 0xf0103aee:	mov    0x8(%ebp),%edx
0xf0103aee in ?? ()
=> 0xf0103af1:	mov    0xc(%ebp),%eax
0xf0103af1 in ?? ()
=> 0xf0103af4:	mov    0x8(%ebp),%ecx
0xf0103af4 in ?? ()
=> 0xf0103af7:	lock xchg %eax,(%edx)
0xf0103af7 in ?? ()
=> 0xf0103afa:	mov    %eax,-0x4(%ebp)
0xf0103afa in ?? ()
=> 0xf0103afd:	mov    -0x4(%ebp),%eax
0xf0103afd in ?? ()
=> 0xf0103b00:	leave  
0xf0103b00 in ?? ()
=> 0xf0103b01:	ret    
0xf0103b01 in ?? ()
=> 0xf0103b23:	add    $0x8,%esp
0xf0103b23 in ?? ()
=> 0xf0103b26:	test   %eax,%eax
0xf0103b26 in ?? ()
=> 0xf0103b28:	jne    0xf0103b16
0xf0103b28 in ?? ()
=> 0xf0103b2a:	nop
0xf0103b2a in ?? ()
=> 0xf0103b2b:	leave  
0xf0103b2b in ?? ()
=> 0xf0103b2c:	ret    
0xf0103b2c in ?? ()
=> 0xf0101680:	add    $0x10,%esp
0xf0101680 in ?? ()
=> 0xf0101683:	nop
0xf0101683 in ?? ()
=> 0xf0101684:	leave  
0xf0101684 in ?? ()
=> 0xf0101685:	ret    
0xf0101685 in ?? ()
=> 0xf01025c7:	mov    0xf012c054,%eax
0xf01025c7 in ?? ()
=> 0xf01025cc:	mov    0x54(%eax),%eax
0xf01025cc in ?? ()
=> 0xf01025cf:	cmp    $0x1,%eax
0xf01025cf in ?? ()
=> 0xf01025d2:	jne    0xf01025f4
0xf01025d2 in ?? ()
=> 0xf01025f4:	mov    0xf012c054,%edx
0xf01025f4 in ?? ()
=> 0xf01025fa:	mov    0x8(%ebp),%eax
0xf01025fa in ?? ()
=> 0xf01025fd:	mov    %eax,%ebx
0xf01025fd in ?? ()
=> 0xf01025ff:	mov    $0x11,%eax
0xf01025ff in ?? ()
=> 0xf0102604:	mov    %edx,%edi
0xf0102604 in ?? ()
=> 0xf0102606:	mov    %ebx,%esi
0xf0102606 in ?? ()
=> 0xf0102608:	mov    %eax,%ecx
0xf0102608 in ?? ()
=> 0xf010260a:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a in ?? ()
=> 0xf010260a:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a in ?? ()
=> 0xf010260a:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a in ?? ()
=> 0xf010260a:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a in ?? ()
=> 0xf010260a:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a in ?? ()
=> 0xf010260a:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a in ?? ()
=> 0xf010260a:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a in ?? ()
=> 0xf010260a:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a in ?? ()
=> 0xf010260a:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a in ?? ()
=> 0xf010260a:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a in ?? ()
=> 0xf010260a:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a in ?? ()
=> 0xf010260a:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a in ?? ()
=> 0xf010260a:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a in ?? ()
=> 0xf010260a:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a in ?? ()
=> 0xf010260a:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a in ?? ()
=> 0xf010260a:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a in ?? ()
=> 0xf010260a:	rep movsl %ds:(%esi),%es:(%edi)
0xf010260a in ?? ()
=> 0xf010260c:	mov    0xf012c054,%eax
0xf010260c in ?? ()
=> 0xf0102611:	mov    %eax,0x8(%ebp)
0xf0102611 in ?? ()
=> 0xf0102614:	mov    0x8(%ebp),%eax
0xf0102614 in ?? ()
=> 0xf0102617:	mov    %eax,0xf012c048
0xf0102617 in ?? ()
=> 0xf010261c:	sub    $0xc,%esp
0xf010261c in ?? ()
=> 0xf010261f:	pushl  0x8(%ebp)
0xf010261f in ?? ()
=> 0xf0102622:	call   0xf010244f
0xf0102622 in ?? ()
=> 0xf010244f:	push   %ebp
0xf010244f in ?? ()
=> 0xf0102450:	mov    %esp,%ebp
0xf0102450 in ?? ()
=> 0xf0102452:	push   %edi
0xf0102452 in ?? ()
=> 0xf0102453:	push   %esi
0xf0102453 in ?? ()
=> 0xf0102454:	push   %ebx
0xf0102454 in ?? ()
=> 0xf0102455:	sub    $0x1c,%esp
0xf0102455 in ?? ()
=> 0xf0102458:	mov    0x8(%ebp),%eax
0xf0102458 in ?? ()
=> 0xf010245b:	mov    0x28(%eax),%eax
0xf010245b in ?? ()
=> 0xf010245e:	cmp    $0xe,%eax
0xf010245e in ?? ()
Reading symbols from kernel...done.
Error in re-setting breakpoint 1: Function "bc_init" not defined.
=> 0xf0102461 <trap_dispatch+18>:	jne    0xf0102476 <trap_dispatch+39>
0xf0102461	193		if(tf->tf_trapno == T_PGFLT)
=> 0xf0102476 <trap_dispatch+39>:	mov    0x8(%ebp),%eax
198		if(tf->tf_trapno == T_BRKPT)
=> 0xf0102479 <trap_dispatch+42>:	mov    0x28(%eax),%eax
0xf0102479	198		if(tf->tf_trapno == T_BRKPT)
=> 0xf010247c <trap_dispatch+45>:	cmp    $0x3,%eax
0xf010247c	198		if(tf->tf_trapno == T_BRKPT)
=> 0xf010247f <trap_dispatch+48>:	jne    0xf0102494 <trap_dispatch+69>
0xf010247f	198		if(tf->tf_trapno == T_BRKPT)
=> 0xf0102494 <trap_dispatch+69>:	mov    0x8(%ebp),%eax
203		if(tf->tf_trapno == T_SYSCALL)
=> 0xf0102497 <trap_dispatch+72>:	mov    0x28(%eax),%eax
0xf0102497	203		if(tf->tf_trapno == T_SYSCALL)
=> 0xf010249a <trap_dispatch+75>:	cmp    $0x30,%eax
0xf010249a	203		if(tf->tf_trapno == T_SYSCALL)
=> 0xf010249d <trap_dispatch+78>:	jne    0xf01024fb <trap_dispatch+172>
0xf010249d	203		if(tf->tf_trapno == T_SYSCALL)
=> 0xf010249f <trap_dispatch+80>:	mov    0x8(%ebp),%eax
205			cprintf("----Syscall No: 0x%u\n", tf->tf_regs.reg_eax);
=> 0xf01024a2 <trap_dispatch+83>:	mov    0x1c(%eax),%eax
0xf01024a2	205			cprintf("----Syscall No: 0x%u\n", tf->tf_regs.reg_eax);
=> 0xf01024a5 <trap_dispatch+86>:	sub    $0x8,%esp
0xf01024a5	205			cprintf("----Syscall No: 0x%u\n", tf->tf_regs.reg_eax);
=> 0xf01024a8 <trap_dispatch+89>:	push   %eax
0xf01024a8	205			cprintf("----Syscall No: 0x%u\n", tf->tf_regs.reg_eax);
=> 0xf01024a9 <trap_dispatch+90>:	push   $0xf0104b1f
0xf01024a9	205			cprintf("----Syscall No: 0x%u\n", tf->tf_regs.reg_eax);
=> 0xf01024ae <trap_dispatch+95>:	call   0xf0103b8e <cprintf>
0xf01024ae	205			cprintf("----Syscall No: 0x%u\n", tf->tf_regs.reg_eax);
=> 0xf0103b94 <cprintf+6>:	lea    0xc(%ebp),%eax
cprintf (fmt=0xf0104b1f "----Syscall No: 0x%u\n") at stdio.c:56
56		va_start(ap, fmt);
=> 0xf0103b9a <cprintf+12>:	mov    -0x10(%ebp),%eax
57		cnt = vcprintf(fmt, ap);
=> 0xf0103b6b <vcprintf+6>:	movl   $0x0,-0xc(%ebp)
vcprintf (fmt=0xf0104b1f "----Syscall No: 0x%u\n", ap=0xefffff4c "\n") at stdio.c:44
44		int cnt = 0;
=> 0xf0103b72 <vcprintf+13>:	pushl  0xc(%ebp)
46		vprintfmt((void*)putch, &cnt, fmt, ap);
=> 0xf0103cf4 <vprintfmt+8>:	jmp    0xf0103d0d <vprintfmt+33>
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b1f "----Syscall No: 0x%u\n", ap=0xefffff4c "\n") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x2d) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x2d) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x2d) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x2d) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x2d, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x2d) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x2d) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x2d) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x72d) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x41, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x72d) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x2d) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x2d) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b20 "---Syscall No: 0x%u\n", ap=0xefffff4c "\n") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x2d) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x2d) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x2d) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x2d) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x2d, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x2d) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x2d) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x2d) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x72d) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x42, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x72d) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x2d) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x2d) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b21 "--Syscall No: 0x%u\n", ap=0xefffff4c "\n") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x2d) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x2d) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x2d) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x2d) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x2d, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x2d) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x2d) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x2d) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x72d) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x43, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x72d) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x2d) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x2d) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b22 "-Syscall No: 0x%u\n", ap=0xefffff4c "\n") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x2d) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x2d) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x2d) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x2d) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x2d, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x2d) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x2d) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x2d) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x72d) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x44, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x72d) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x2d) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x2d) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b23 "Syscall No: 0x%u\n", ap=0xefffff4c "\n") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x2d) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x2d) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x2d) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x2d) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x2d, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x2d) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x2d) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x2d) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x72d) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x45, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x72d) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x2d) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x2d) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b20 "---Syscall No: 0x%u\n", ap=0xefffff4c "\002") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x2d) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x2d) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x2d) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x2d) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x2d, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x2d) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x2d) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x2d) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x72d) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x46, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x72d) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x2d) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x2d) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b21 "--Syscall No: 0x%u\n", ap=0xefffff4c "\002") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x2d) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x2d) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x2d) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x2d) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x2d, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x2d) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x2d) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x2d) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x72d) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x47, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x72d) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x2d) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x2d) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b22 "-Syscall No: 0x%u\n", ap=0xefffff4c "\002") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x2d) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x2d) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x2d) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x2d) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x2d, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x2d) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x2d) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x2d) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x72d) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x48, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x72d) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x2d) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x2d) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b23 "Syscall No: 0x%u\n", ap=0xefffff4c "\002") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x53, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x53) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x53) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x53) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x53) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x53, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x53) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x53) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x53) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x753) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x753) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x753) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x49, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x753) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x53) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x53) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x53, cnt=0xefffff04) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b24 "yscall No: 0x%u\n", ap=0xefffff4c "\002") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x79, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x79) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x79) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x79) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x79) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x79, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x79) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x79) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x79) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x779) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x779) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x779) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x4a, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x779) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x79) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x79) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x79, cnt=0xefffff04) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b25 "scall No: 0x%u\n", ap=0xefffff4c "\002") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x2d) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x2d) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x2d) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x2d) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x2d, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x2d) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x2d) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x2d) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x72d) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x4b, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x72d) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x2d) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x2d) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b20 "---Syscall No: 0x%u\n", ap=0xefffff4c "") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x2d) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x2d) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x2d) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x2d) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x2d, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x2d) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x2d) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x2d) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x72d) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x4c, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x72d) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x2d) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x2d) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b21 "--Syscall No: 0x%u\n", ap=0xefffff4c "") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x2d) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x2d) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x2d) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x2d) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x2d, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x2d) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x2d) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x2d) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x72d) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x4d, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x72d) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x2d) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x2d) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b22 "-Syscall No: 0x%u\n", ap=0xefffff4c "") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x2d) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x2d) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x2d) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x2d) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x2d, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x2d) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x2d) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x2d) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x72d) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x4e, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x72d) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x2d) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x2d) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b23 "Syscall No: 0x%u\n", ap=0xefffff4c "") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x53, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x53) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x53) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x53) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x53) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x53, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x53) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x53) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x53) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x753) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x753) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x753) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x4f, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x753) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x53) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x53) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x53, cnt=0xefffff04) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b24 "yscall No: 0x%u\n", ap=0xefffff4c "") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x79, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x2d) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x2d) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x2d) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x2d) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x2d, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x2d) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x2d) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x2d) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x72d) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x50, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x72d) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x2d) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x2d) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b20 "---Syscall No: 0x%u\n", ap=0xefffff4c "") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x2d) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x2d) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x2d) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x2d) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x2d, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x2d) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x2d) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x2d) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x72d) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x51, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x72d) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x2d) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x2d) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b21 "--Syscall No: 0x%u\n", ap=0xefffff4c "") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x2d) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x2d) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x2d) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x2d) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x2d, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x2d) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x2d) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x2d) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x72d) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x52, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x72d) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x2d) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x2d) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b22 "-Syscall No: 0x%u\n", ap=0xefffff4c "") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x2d) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x2d) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x2d) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x2d) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x2d, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x2d) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x2d) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x2d) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x72d) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x53, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x72d) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x2d) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x2d) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b23 "Syscall No: 0x%u\n", ap=0xefffff4c "") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x53, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x53) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x53) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x53) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x53) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x53, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x53) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x53) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x53) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x753) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x753) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x753) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x54, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x753) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x53) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x53) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x53, cnt=0xefffff04) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b24 "yscall No: 0x%u\n", ap=0xefffff4c "") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x79, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x79) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x79) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x79) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x79) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x79, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x79) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x79) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x79) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x779) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x779) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x779) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x55, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x779) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x79) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x79) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x79, cnt=0xefffff04) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b25 "scall No: 0x%u\n", ap=0xefffff4c "") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x73, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x2d) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x2d) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x2d) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x2d) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x2d, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x2d) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x2d) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x2d) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x72d) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x56, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x72d) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x2d) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x2d) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b20 "---Syscall No: 0x%u\n", ap=0xefffff4c "") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x2d) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x2d) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x2d) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x2d) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x2d, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x2d) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x2d) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x2d) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x72d) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x57, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x72d) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x2d) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x2d) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b21 "--Syscall No: 0x%u\n", ap=0xefffff4c "") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x2d) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x2d) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x2d) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x2d) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x2d, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x2d) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x2d) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x2d) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x72d) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x58, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x72d) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x2d) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x2d) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b22 "-Syscall No: 0x%u\n", ap=0xefffff4c "") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x2d) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x2d) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x2d) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x2d) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x2d, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x2d) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x2d) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x2d) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x72d) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x59, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x72d) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x2d) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x2d) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b23 "Syscall No: 0x%u\n", ap=0xefffff4c "") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x53, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x53) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x53) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x53) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x53) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x53, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x53) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x53) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x53) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x753) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x753) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x753) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x5a, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x753) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x53) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x53) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x53, cnt=0xefffff04) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b24 "yscall No: 0x%u\n", ap=0xefffff4c "") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x79, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x79) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x79) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x79) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x79) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x79, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x79) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x79) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x79) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x779) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x779) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x779) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x5b, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x779) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x79) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x79) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x79, cnt=0xefffff04) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b25 "scall No: 0x%u\n", ap=0xefffff4c "") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x73, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x57) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x57) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x57) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x57) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x57, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x57) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x57) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x57) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x757) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x757) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x757) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x5c, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x757) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x57) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x57) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x57, cnt=0xeffffed4) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xeffffed4, fmt=0xf0104933 "elcome to the DamnOS!\n", ap=0xefffff1c "L\377\377\357\a") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x65, cnt=0xeffffed4) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x65) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x65) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x65) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x65) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x65, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x65) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x65) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x65) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x765) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x765) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x765) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x5d, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x765) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x65) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x65) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x65, cnt=0xeffffed4) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xeffffed4, fmt=0xf0104934 "lcome to the DamnOS!\n", ap=0xefffff1c "L\377\377\357\a") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x6c, cnt=0xeffffed4) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x6c) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x6c) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x6c) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x6c) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x6c, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x6c) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x6c) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x6c) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x76c) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x76c) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x76c) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x5e, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x76c) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x6c) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x6c) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x6c, cnt=0xeffffed4) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xeffffed4, fmt=0xf0104935 "come to the DamnOS!\n", ap=0xefffff1c "L\377\377\357\a") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x63, cnt=0xeffffed4) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x63) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x63) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x63) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x63) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x63, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x63) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x63) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x63) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x763) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x763) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x763) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x5f, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x763) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x63) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x63) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x63, cnt=0xeffffed4) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xeffffed4, fmt=0xf0104936 "ome to the DamnOS!\n", ap=0xefffff1c "L\377\377\357\a") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x6f, cnt=0xeffffed4) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x6f) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x6f) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x6f) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x6f) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x6f, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x6f) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x6f) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x6f) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x76f) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x76f) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x76f) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x60, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x76f) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x6f) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x6f) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x6f, cnt=0xeffffed4) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xeffffed4, fmt=0xf0104937 "me to the DamnOS!\n", ap=0xefffff1c "L\377\377\357\a") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x6d, cnt=0xeffffed4) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x6d) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x6d) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x6d) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x6d) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x6d, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x6d) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x6d) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x6d) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x76d) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x76d) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x76d) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x61, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x76d) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x6d) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x6d) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x6d, cnt=0xeffffed4) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xeffffed4, fmt=0xf0104938 "e to the DamnOS!\n", ap=0xefffff1c "L\377\377\357\a") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x65, cnt=0xeffffed4) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x65) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x65) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x65) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x65) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x65, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x65) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x65) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x65) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x765) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x765) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x765) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x62, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x765) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x65) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x65) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x65, cnt=0xeffffed4) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xeffffed4, fmt=0xf0104939 " to the DamnOS!\n", ap=0xefffff1c "L\377\377\357\a") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x20, cnt=0xeffffed4) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x20) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x20) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x20) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x20) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x20, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x20) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x20) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x20) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x720) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x720) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x720) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x63, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x720) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x20) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x20) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x20, cnt=0xeffffed4) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xeffffed4, fmt=0xf010493a "to the DamnOS!\n", ap=0xefffff1c "L\377\377\357\a") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x74, cnt=0xeffffed4) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x74) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x74) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x74) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x74) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x74, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x74) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x74) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x74) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x774) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x774) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x774) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x64, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x774) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x74) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x74) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x74, cnt=0xeffffed4) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xeffffed4, fmt=0xf010493b "o the DamnOS!\n", ap=0xefffff1c "L\377\377\357\a") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x6f, cnt=0xeffffed4) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x6f) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x6f) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x6f) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x6f) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x6f, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x6f) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x6f) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x6f) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x76f) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x76f) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x76f) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x65, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x76f) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x6f) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x6f) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x6f, cnt=0xeffffed4) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xeffffed4, fmt=0xf010493c " the DamnOS!\n", ap=0xefffff1c "L\377\377\357\a") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x20, cnt=0xeffffed4) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x20) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x20) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x20) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x20) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x20, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x20) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x20) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x20) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x720) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x720) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x720) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x66, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x720) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x20) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x20) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x20, cnt=0xeffffed4) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xeffffed4, fmt=0xf010493d "the DamnOS!\n", ap=0xefffff1c "L\377\377\357\a") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x74, cnt=0xeffffed4) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x74) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x74) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x74) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x74) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x74, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x74) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x74) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x74) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x774) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x774) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x774) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x67, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x774) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x74) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x74) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x74, cnt=0xeffffed4) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xeffffed4, fmt=0xf010493e "he DamnOS!\n", ap=0xefffff1c "L\377\377\357\a") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x68, cnt=0xeffffed4) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x68) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x68) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x68) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x68) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x68, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x68) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x68) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x68) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x768) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb1 <cga_putc+457>:	mov    -0x14(%ebp),%edx
0xf0100fb1	122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb4 <cga_putc+460>:	out    %al,(%dx)
0xf0100fb4	122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x768) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fba <cga_putc+466>:	mov    %eax,-0x18(%ebp)
0xf0100fba	193		outb(addr_6845, 15);
=> 0xf0100fbd <cga_putc+469>:	movb   $0xf,-0x1e(%ebp)
0xf0100fbd	193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc5 <cga_putc+477>:	mov    -0x18(%ebp),%edx
0xf0100fc5	122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc8 <cga_putc+480>:	out    %al,(%dx)
0xf0100fc8	122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
Continuing.
Remote connection closed
Undefined command: "gdb".  Try "help".

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
dmanfs: No such file or directory.
da,mfs: No such file or directory.
Reading symbols from damnfs...done.
Function "set_page_handler" not defined.
Breakpoint 1 at 0x80003031: file pgfault.c, line 25.
Continuing.
[  1b:80003031]    0x80003283 <vprintfmt+89>:	(bad)  

Breakpoint 1, set_pgfault_handler (handler=0x800010a9 <bc_pgfault>) at pgfault.c:25
25	{
[  1b:80003032]    0x80003284 <vprintfmt+90>:	(bad)  
0x80003032	25	{
[  1b:80003034]    0x80003286 <vprintfmt+92>:	inc    %di
0x80003034	25	{
[  1b:80003037]    0x80003289 <vprintfmt+95>:	in     $0xff,%al
28		if (_pgfault_handler == 0) {
[  1b:8000303e]    0x80003290 <vprintfmt+102>:	add    %al,(%bx,%si)
0x8000303e	28		if (_pgfault_handler == 0) {
[  1b:80003040]    0x80003292 <vprintfmt+104>:	add    %bh,0x0(%bp,%di)
30			if((r = sys_page_alloc(0, (void *)(UXSTACKTOP - PGSIZE), PTE_P|PTE_U|PTE_W)) < 0)
[  1b:80003043]    0x80003295 <vprintfmt+107>:	add    %al,(%bx,%si)
0x80003043	30			if((r = sys_page_alloc(0, (void *)(UXSTACKTOP - PGSIZE), PTE_P|PTE_U|PTE_W)) < 0)
[  1b:80003045]    0x80003297 <vprintfmt+109>:	add    %ch,%bl
0x80003045	30			if((r = sys_page_alloc(0, (void *)(UXSTACKTOP - PGSIZE), PTE_P|PTE_U|PTE_W)) < 0)
[  1b:8000304a]    0x8000329c <vprintfmt+114>:	adc    %al,%dh
0x8000304a	30			if((r = sys_page_alloc(0, (void *)(UXSTACKTOP - PGSIZE), PTE_P|PTE_U|PTE_W)) < 0)
[  1b:8000304c]    0x8000329e <vprintfmt+116>:	inc    %bp
0x8000304c	30			if((r = sys_page_alloc(0, (void *)(UXSTACKTOP - PGSIZE), PTE_P|PTE_U|PTE_W)) < 0)
[  1b:80002af9]    0x80002d4b <devfile_trunc+22>:	mov    $0x0,%al
sys_page_alloc (envid=0x0, va=0xeebff000, perm=0x7) at syscall.c:70
70	{
[  1b:80002afa]    0x80002d4c <devfile_trunc+23>:	add    %al,0xba(%bx,%si)
0x80002afa	70	{
[  1b:80002afc]    0x80002d4e <devfile_trunc+25>:	mov    $0x0,%dx
0x80002afc	70	{
[  1b:80002afd]    0x80002d4f <devfile_trunc+26>:	add    %al,(%bx,%si)
0x80002afd	70	{
[  1b:80002afe]    0x80002d50 <devfile_trunc+27>:	add    %al,(%bx,%si)
0x80002afe	70	{
[  1b:80002aff]    0x80002d51 <devfile_trunc+28>:	add    %al,(%bx,%si)
0x80002aff	70	{
[  1b:80002b02]    0x80002d54 <devfile_trunc+31>:	add    (%bx,%si),%al
syscall (a5=0x0, a4=0x0, a3=0x7, a2=0xeebff000, a1=0x0, check=0x1, num=0x4) at syscall.c:21
21		asm volatile("int %1\n"
[  1b:80002b07]    0x80002d59 <devfile_trunc+36>:	(bad)  
0x80002b07	21		asm volatile("int %1\n"
[  1b:80002b0c]    0x80002d5e <devfile_trunc+41>:	ret    
0x80002b0c	21		asm volatile("int %1\n"
[  1b:80002b0f]    0x80002d61 <devfile_flush+2>:	in     $0x83,%ax
0x80002b0f	21		asm volatile("int %1\n"
[  1b:80002b12]    0x80002d64 <devfile_flush+5>:	or     %cl,0x845(%bp,%di)
0x80002b12	21		asm volatile("int %1\n"
[  1b:80002b15]    0x80002d67 <devfile_flush+8>:	or     %cl,0xc40(%bp,%di)
0x80002b15	21		asm volatile("int %1\n"
[  1b:80002b17]    0x80002d69 <devfile_flush+10>:	inc    %ax
0x80002b17	21		asm volatile("int %1\n"
The target architecture is assumed to be i386
=> 0xf0101652:	push   $0x30
0xf0101652 in ?? ()
=> 0xf0101654:	jmp    0xf010165c
0xf0101654 in ?? ()
=> 0xf010165c:	push   %ds
0xf010165c in ?? ()
=> 0xf010165d:	push   %es
0xf010165d in ?? ()
=> 0xf010165e:	pusha  
0xf010165e in ?? ()
=> 0xf010165f:	mov    $0x10,%ax
0xf010165f in ?? ()
=> 0xf0101663:	mov    %eax,%ds
0xf0101663 in ?? ()
=> 0xf0101665:	mov    %eax,%es
0xf0101665 in ?? ()
=> 0xf0101667:	push   %esp
0xf0101667 in ?? ()
=> 0xf0101668:	call   0xf01025a6
0xf0101668 in ?? ()
=> 0xf01025a6:	push   %ebp
0xf01025a6 in ?? ()
=> 0xf01025a7:	mov    %esp,%ebp
0xf01025a7 in ?? ()
=> 0xf01025a9:	push   %edi
0xf01025a9 in ?? ()
=> 0xf01025aa:	push   %esi
0xf01025aa in ?? ()
=> 0xf01025ab:	push   %ebx
0xf01025ab in ?? ()
=> 0xf01025ac:	sub    $0xc,%esp
0xf01025ac in ?? ()
=> 0xf01025af:	cld    
0xf01025af in ?? ()
=> 0xf01025b0:	mov    0x8(%ebp),%eax
0xf01025b0 in ?? ()
=> 0xf01025b3:	movzwl 0x34(%eax),%eax
0xf01025b3 in ?? ()
Cannot find bounds of current function
Reading symbols from kernel...done.
Error in re-setting breakpoint 1: Function "set_pgfault_handler" not defined.
=> 0xf01025c2 <trap+28>:	call   0xf010166d <lock_kernel>
270			lock_kernel();
=> 0xf0101673 <lock_kernel+6>:	sub    $0xc,%esp
lock_kernel () at ./spinlock.h:23
23		spin_lock(&kernel_lock);
=> 0xf0103b14 <spin_lock+3>:	jmp    0xf0103b18 <spin_lock+7>
spin_lock (lk=0xf012c46c <kernel_lock>) at spinlock.c:28
28		while (xchg(&lk->locked, 1) != 0)
=> 0xf0103aee <xchg+6>:	mov    0x8(%ebp),%edx
xchg (addr=0xf012c46c <kernel_lock>, newval=0x1) at ./x86.h:323
323		asm volatile("lock; xchgl %0, %1" :
=> 0xf0103afd <xchg+21>:	mov    -0x4(%ebp),%eax
327		return result;
=> 0xf0103b00 <xchg+24>:	leave  
328	}
=> 0xf0103b2a <spin_lock+25>:	nop
spin_lock (lk=0xf012c46c <kernel_lock>) at spinlock.c:30
30	}
=> 0xf0101683 <lock_kernel+22>:	nop
lock_kernel () at ./spinlock.h:24
24	}
=> 0xf01025c7 <trap+33>:	mov    0xf012c054,%eax
trap (tf=0xefffffbc) at trap.c:273
273			if (curenv->env_status == ENV_DYING) {
=> 0xf01025f4 <trap+78>:	mov    0xf012c054,%edx
282			curenv->env_tf = *tf;
=> 0xf010260c <trap+102>:	mov    0xf012c054,%eax
284			tf = &curenv->env_tf;
=> 0xf0102614 <trap+110>:	mov    0x8(%ebp),%eax
288		last_tf = tf;
=> 0xf010261c <trap+118>:	sub    $0xc,%esp
291		trap_dispatch(tf);
=> 0xf0102458 <trap_dispatch+9>:	mov    0x8(%ebp),%eax
trap_dispatch (tf=0xf0132000) at trap.c:193
193		if(tf->tf_trapno == T_PGFLT)
=> 0xf0102476 <trap_dispatch+39>:	mov    0x8(%ebp),%eax
198		if(tf->tf_trapno == T_BRKPT)
=> 0xf0102494 <trap_dispatch+69>:	mov    0x8(%ebp),%eax
203		if(tf->tf_trapno == T_SYSCALL)
=> 0xf010249f <trap_dispatch+80>:	mov    0x8(%ebp),%eax
205			cprintf("----Syscall No: 0x%u\n", tf->tf_regs.reg_eax);
=> 0xf0103b94 <cprintf+6>:	lea    0xc(%ebp),%eax
cprintf (fmt=0xf0104b1f "----Syscall No: 0x%u\n") at stdio.c:56
56		va_start(ap, fmt);
=> 0xf0103b9a <cprintf+12>:	mov    -0x10(%ebp),%eax
57		cnt = vcprintf(fmt, ap);
=> 0xf0103b6b <vcprintf+6>:	movl   $0x0,-0xc(%ebp)
vcprintf (fmt=0xf0104b1f "----Syscall No: 0x%u\n", ap=0xefffff4c "\n") at stdio.c:44
44		int cnt = 0;
No symbol "tf" in current context.
=> 0xf0103b72 <vcprintf+13>:	pushl  0xc(%ebp)
46		vprintfmt((void*)putch, &cnt, fmt, ap);
=> 0xf0103cf4 <vprintfmt+8>:	jmp    0xf0103d0d <vprintfmt+33>
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b1f "----Syscall No: 0x%u\n", ap=0xefffff4c "\n") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x2d) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x2d) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x2d) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x2d) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x2d, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x2d) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x2d) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x2d) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x72d) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x41, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x72d) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x2d) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x2d) at console.c:438
438	}
=> 0xf01012d3 <cputchar+21>:	leave  
0xf01012d3	438	}
=> 0xf01012d4 <cputchar+22>:	ret    
0xf01012d4 in cputchar (c=0x2d) at console.c:438
438	}
=> 0xf0103b52 <putch+17>:	add    $0x10,%esp
0xf0103b52 in putch (ch=0x2d, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
38		++(*cnt);
=> 0xf0103b58 <putch+23>:	mov    (%eax),%eax
0xf0103b58	38		++(*cnt);
=> 0xf0103b5a <putch+25>:	lea    0x1(%eax),%edx
0xf0103b5a	38		++(*cnt);
=> 0xf0103b5d <putch+28>:	mov    0xc(%ebp),%eax
0xf0103b5d	38		++(*cnt);
=> 0xf0103b60 <putch+31>:	mov    %edx,(%eax)
0xf0103b60	38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103b63 <putch+34>:	leave  
0xf0103b63	39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b20 "---Syscall No: 0x%u\n", ap=0xefffff4c "\n") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x2d) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x2d) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x2d) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x2d) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x2d, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x2d) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x2d) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x2d) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x72d) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x42, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x72d) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x2d) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x2d) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b21 "--Syscall No: 0x%u\n", ap=0xefffff4c "\n") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x2d) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x2d) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x2d) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x2d) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x2d, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x2d) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x2d) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x2d) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x72d) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x43, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x72d) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x2d) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x2d) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b22 "-Syscall No: 0x%u\n", ap=0xefffff4c "\n") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x2d) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x2d) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x2d) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x2d) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x2d, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x2d) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x2d) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x2d) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100df8 <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100dff <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100eef <cga_putc+263>:	mov    0xf012b5a8,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f13 <cga_putc+299>:	jmp    0xf0100f16 <cga_putc+302>
179			break;
=> 0xf0100f16 <cga_putc+302>:	movzwl 0xf012b5ac,%eax
182		if (crt_pos >= CRT_SIZE) {
=> 0xf0100f7c <cga_putc+404>:	mov    0xf012b5a4,%eax
191		outb(addr_6845, 14);
=> 0xf0100f88 <cga_putc+416>:	movzbl -0x20(%ebp),%eax
outb (data=0xe, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100f90 <cga_putc+424>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:192
192		outb(addr_6845 + 1, crt_pos >> 8);
=> 0xf0100fad <cga_putc+453>:	movzbl -0x1f(%ebp),%eax
outb (data=0x6, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fb5 <cga_putc+461>:	mov    0xf012b5a4,%eax
cga_putc (c=0x72d) at console.c:193
193		outb(addr_6845, 15);
=> 0xf0100fc1 <cga_putc+473>:	movzbl -0x1e(%ebp),%eax
outb (data=0xf, port=0x3d4) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fc9 <cga_putc+481>:	movzwl 0xf012b5ac,%eax
cga_putc (c=0x72d) at console.c:194
194		outb(addr_6845 + 1, crt_pos);
=> 0xf0100fe2 <cga_putc+506>:	movzbl -0x1d(%ebp),%eax
outb (data=0x44, port=0x3d5) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100fea <cga_putc+514>:	nop
cga_putc (c=0x72d) at console.c:195
195	}
=> 0xf010100f <cons_putc+31>:	nop
cons_putc (c=0x2d) at console.c:203
203	}
=> 0xf01012d2 <cputchar+20>:	nop
cputchar (c=0x2d) at console.c:438
438	}
=> 0xf0103b55 <putch+20>:	mov    0xc(%ebp),%eax
putch (ch=0x2d, cnt=0xefffff04) at stdio.c:38
38		++(*cnt);
=> 0xf0103b62 <putch+33>:	nop
39	}
=> 0xf0103d0d <vprintfmt+33>:	mov    0x10(%ebp),%eax
vprintfmt (putch=0xf0103b41 <putch>, putdat=0xefffff04, fmt=0xf0104b23 "Syscall No: 0x%u\n", ap=0xefffff4c "\n") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf6 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103cfe <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b47 <putch+6>:	sub    $0xc,%esp
putch (ch=0x53, cnt=0xefffff04) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c4 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x2d) at console.c:437
437		cons_putc(c);
=> 0xf0100ff6 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x2d) at console.c:201
201		serial_putc(c);
=> 0xf0100b3b <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x2d) at console.c:67
67		for (i = 0;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b54 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b5d <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b61 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x2d) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b67 <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b74 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c35 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c45 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x2d, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c4d <serial_putc+280>:	leave  
serial_putc (c=0x2d) at console.c:88
88	}
=> 0xf0101001 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x2d) at console.c:202
202		cga_putc(c);
=> 0xf0100def <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x2d) at console.c:155
155		if (!(c & ~0xFF))
Breakpoint 2 at 0xf01024b6: file trap.c, line 206.
Continuing.
=> 0xf01024b6 <trap_dispatch+103>:	mov    0x8(%ebp),%eax

Breakpoint 2, trap_dispatch (tf=0xf0132000) at trap.c:206
206			int32_t temp_ret = syscall(tf->tf_regs.reg_eax,
$1 = {tf_regs = {reg_edi = 0x0, reg_esi = 0x0, reg_ebp = 0xeebfdf00, reg_oesp = 0xefffffdc, reg_ebx = 0x0, reg_edx = 0x0, reg_ecx = 0x0, reg_eax = 0x2}, tf_es = 0x23, tf_padding1 = 0x0, tf_ds = 0x23, tf_padding2 = 0x0, tf_trapno = 0x30, tf_err = 0x0, tf_eip = 0x80002ad5, tf_cs = 0x1b, tf_padding3 = 0x0, tf_eflags = 0x3292, tf_esp = 0xeebfdef4, tf_ss = 0x23, tf_padding4 = 0x0}
$2 = 0xf0103b23
=> 0xf01024b9 <trap_dispatch+106>:	mov    0x4(%eax),%edi
0xf01024b9	206			int32_t temp_ret = syscall(tf->tf_regs.reg_eax,
$3 = 0xf0103b23
=> 0xf01024bc <trap_dispatch+109>:	mov    0x8(%ebp),%eax
0xf01024bc	206			int32_t temp_ret = syscall(tf->tf_regs.reg_eax,
=> 0xf01024bf <trap_dispatch+112>:	mov    (%eax),%esi
0xf01024bf	206			int32_t temp_ret = syscall(tf->tf_regs.reg_eax,
$4 = 0xf0103b23
=> 0xf01024c1 <trap_dispatch+114>:	mov    0x8(%ebp),%eax
0xf01024c1	206			int32_t temp_ret = syscall(tf->tf_regs.reg_eax,
=> 0xf01024c4 <trap_dispatch+117>:	mov    0x10(%eax),%ebx
0xf01024c4	206			int32_t temp_ret = syscall(tf->tf_regs.reg_eax,
=> 0xf01024c7 <trap_dispatch+120>:	mov    0x8(%ebp),%eax
0xf01024c7	206			int32_t temp_ret = syscall(tf->tf_regs.reg_eax,
=> 0xf01024ca <trap_dispatch+123>:	mov    0x18(%eax),%ecx
0xf01024ca	206			int32_t temp_ret = syscall(tf->tf_regs.reg_eax,
=> 0xf01024cd <trap_dispatch+126>:	mov    0x8(%ebp),%eax
0xf01024cd	206			int32_t temp_ret = syscall(tf->tf_regs.reg_eax,
=> 0xf01024d0 <trap_dispatch+129>:	mov    0x14(%eax),%edx
0xf01024d0	206			int32_t temp_ret = syscall(tf->tf_regs.reg_eax,
=> 0xf01024d3 <trap_dispatch+132>:	mov    0x8(%ebp),%eax
0xf01024d3	206			int32_t temp_ret = syscall(tf->tf_regs.reg_eax,
=> 0xf01024d6 <trap_dispatch+135>:	mov    0x1c(%eax),%eax
0xf01024d6	206			int32_t temp_ret = syscall(tf->tf_regs.reg_eax,
=> 0xf01024d9 <trap_dispatch+138>:	sub    $0x8,%esp
0xf01024d9	206			int32_t temp_ret = syscall(tf->tf_regs.reg_eax,
=> 0xf01024dc <trap_dispatch+141>:	push   %edi
0xf01024dc	206			int32_t temp_ret = syscall(tf->tf_regs.reg_eax,
=> 0xf01024dd <trap_dispatch+142>:	push   %esi
0xf01024dd	206			int32_t temp_ret = syscall(tf->tf_regs.reg_eax,
=> 0xf01024de <trap_dispatch+143>:	push   %ebx
0xf01024de	206			int32_t temp_ret = syscall(tf->tf_regs.reg_eax,
=> 0xf01024df <trap_dispatch+144>:	push   %ecx
0xf01024df	206			int32_t temp_ret = syscall(tf->tf_regs.reg_eax,
=> 0xf01024e0 <trap_dispatch+145>:	push   %edx
0xf01024e0	206			int32_t temp_ret = syscall(tf->tf_regs.reg_eax,
=> 0xf01024e1 <trap_dispatch+146>:	push   %eax
0xf01024e1	206			int32_t temp_ret = syscall(tf->tf_regs.reg_eax,
=> 0xf01024e2 <trap_dispatch+147>:	call   0xf0102d6d <syscall>
0xf01024e2	206			int32_t temp_ret = syscall(tf->tf_regs.reg_eax,
=> 0xf0102d6d <syscall>:	push   %ebp
syscall (syscallno=0x2, a1=0x0, a2=0x0, a3=0x0, a4=0x0, a5=0x0) at trap.c:779
779	{
=> 0xf0102d6e <syscall+1>:	mov    %esp,%ebp
0xf0102d6e	779	{
=> 0xf0102d70 <syscall+3>:	push   %esi
0xf0102d70	779	{
=> 0xf0102d71 <syscall+4>:	push   %ebx
0xf0102d71	779	{
=> 0xf0102d72 <syscall+5>:	cmpl   $0xd,0x8(%ebp)
786		switch (syscallno) {
=> 0xf0102d76 <syscall+9>:	ja     0xf0102d87 <syscall+26>
0xf0102d76	786		switch (syscallno) {
=> 0xf0102d78 <syscall+11>:	mov    0x8(%ebp),%eax
0xf0102d78	786		switch (syscallno) {
=> 0xf0102d7b <syscall+14>:	shl    $0x2,%eax
0xf0102d7b	786		switch (syscallno) {
=> 0xf0102d7e <syscall+17>:	add    $0xf0104bd0,%eax
0xf0102d7e	786		switch (syscallno) {
No symbol "temp_ret" in current context.
=> 0xf0102d83 <syscall+22>:	mov    (%eax),%eax
0xf0102d83	786		switch (syscallno) {
=> 0xf0102d85 <syscall+24>:	jmp    *%eax
0xf0102d85	786		switch (syscallno) {
=> 0xf0102db7 <syscall+74>:	call   0xf01027d7 <sys_getenvid>
798			return (int32_t)sys_getenvid();
=> 0xf01027d7 <sys_getenvid>:	push   %ebp
sys_getenvid () at trap.c:405
405	{
=> 0xf01027d8 <sys_getenvid+1>:	mov    %esp,%ebp
0xf01027d8	405	{
=> 0xf01027da <sys_getenvid+3>:	mov    0xf012c054,%eax
406		return curenv->env_id;
=> 0xf01027df <sys_getenvid+8>:	mov    0x48(%eax),%eax
0xf01027df	406		return curenv->env_id;
=> 0xf01027e2 <sys_getenvid+11>:	pop    %ebp
407	}
=> 0xf01027e3 <sys_getenvid+12>:	ret    
0xf01027e3 in sys_getenvid () at trap.c:407
407	}
=> 0xf0102dbc <syscall+79>:	jmp    0xf0102ea9 <syscall+316>
0xf0102dbc in syscall (syscallno=0x2, a1=0x0, a2=0x0, a3=0x0, a4=0x0, a5=0x0) at trap.c:798
798			return (int32_t)sys_getenvid();
=> 0xf0102ea9 <syscall+316>:	lea    -0x8(%ebp),%esp
826	}
=> 0xf0102eac <syscall+319>:	pop    %ebx
0xf0102eac	826	}
=> 0xf0102ead <syscall+320>:	pop    %esi
0xf0102ead	826	}
=> 0xf0102eae <syscall+321>:	pop    %ebp
0xf0102eae	826	}
=> 0xf0102eaf <syscall+322>:	ret    
0xf0102eaf in syscall (syscallno=0x2, a1=0x0, a2=0x0, a3=0x0, a4=0x0, a5=0x0) at trap.c:826
826	}
=> 0xf01024e7 <trap_dispatch+152>:	add    $0x20,%esp
0xf01024e7 in trap_dispatch (tf=0xf0132000) at trap.c:206
206			int32_t temp_ret = syscall(tf->tf_regs.reg_eax,
=> 0xf01024ea <trap_dispatch+155>:	mov    %eax,-0x1c(%ebp)
0xf01024ea	206			int32_t temp_ret = syscall(tf->tf_regs.reg_eax,
=> 0xf01024ed <trap_dispatch+158>:	mov    -0x1c(%ebp),%edx
209			tf->tf_regs.reg_eax = temp_ret;
$5 = 0x1000
=> 0xf01024f0 <trap_dispatch+161>:	mov    0x8(%ebp),%eax
0xf01024f0	209			tf->tf_regs.reg_eax = temp_ret;
=> 0xf01024f3 <trap_dispatch+164>:	mov    %edx,0x1c(%eax)
0xf01024f3	209			tf->tf_regs.reg_eax = temp_ret;
=> 0xf01024f6 <trap_dispatch+167>:	jmp    0xf010259e <trap_dispatch+335>
210			return;
=> 0xf010259e <trap_dispatch+335>:	lea    -0xc(%ebp),%esp
253	}
=> 0xf01025a1 <trap_dispatch+338>:	pop    %ebx
0xf01025a1	253	}
=> 0xf01025a2 <trap_dispatch+339>:	pop    %esi
0xf01025a2	253	}
=> 0xf01025a3 <trap_dispatch+340>:	pop    %edi
0xf01025a3	253	}
=> 0xf01025a4 <trap_dispatch+341>:	pop    %ebp
0xf01025a4	253	}
=> 0xf01025a5 <trap_dispatch+342>:	ret    
0xf01025a5 in trap_dispatch (tf=0xf0132000) at trap.c:253
253	}
=> 0xf0102627 <trap+129>:	add    $0x10,%esp
0xf0102627 in trap (tf=0xf0132000) at trap.c:291
291		trap_dispatch(tf);
=> 0xf010262a <trap+132>:	mov    0xf012c054,%eax
296		if (curenv && curenv->env_status == ENV_RUNNING)
=> 0xf010262f <trap+137>:	test   %eax,%eax
0xf010262f	296		if (curenv && curenv->env_status == ENV_RUNNING)
=> 0xf0102631 <trap+139>:	je     0xf010264e <trap+168>
0xf0102631	296		if (curenv && curenv->env_status == ENV_RUNNING)
=> 0xf0102633 <trap+141>:	mov    0xf012c054,%eax
0xf0102633	296		if (curenv && curenv->env_status == ENV_RUNNING)
=> 0xf0102638 <trap+146>:	mov    0x54(%eax),%eax
0xf0102638	296		if (curenv && curenv->env_status == ENV_RUNNING)
=> 0xf010263b <trap+149>:	cmp    $0x3,%eax
0xf010263b	296		if (curenv && curenv->env_status == ENV_RUNNING)
=> 0xf010263e <trap+152>:	jne    0xf010264e <trap+168>
0xf010263e	296		if (curenv && curenv->env_status == ENV_RUNNING)
=> 0xf0102640 <trap+154>:	mov    0xf012c054,%eax
297			env_run(curenv);
=> 0xf0102645 <trap+159>:	sub    $0xc,%esp
0xf0102645	297			env_run(curenv);
=> 0xf0102648 <trap+162>:	push   %eax
0xf0102648	297			env_run(curenv);
=> 0xf0102649 <trap+163>:	call   0xf0103a6c <env_run>
0xf0102649	297			env_run(curenv);
=> 0xf0103a6c <env_run>:	push   %ebp
env_run (e=0xf0132000) at env.c:508
508	{
=> 0xf0103a6d <env_run+1>:	mov    %esp,%ebp
0xf0103a6d	508	{
=> 0xf0103a6f <env_run+3>:	sub    $0x18,%esp
0xf0103a6f	508	{
=> 0xf0103a72 <env_run+6>:	mov    0xf012c054,%eax
526		if (curenv != e)
=> 0xf0103a77 <env_run+11>:	cmp    0x8(%ebp),%eax
0xf0103a77	526		if (curenv != e)
=> 0xf0103a7a <env_run+14>:	je     0xf0103ad7 <env_run+107>
0xf0103a7a	526		if (curenv != e)
Reading symbols from damnfs...done.
Error in re-setting breakpoint 2: No source file named trap.c.
Note: breakpoint 1 (disabled) also set at pc 0x80003031.
Breakpoint 3 at 0x80003031: file pgfault.c, line 25.
Continuing.
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Breakpoint 1 at 0xf0100201: file pmap.c, line 109.
Continuing.
The target architecture is assumed to be i386
=> 0xf0100201 <mem_init>:	push   %ebp

Breakpoint 1, mem_init () at pmap.c:109
109	{
Breakpoint 2 at 0xf0103055: file picirq.c, line 15.
Continuing.
=> 0xf0103055 <pic_init+6>:	movb   $0x1,0xf012c0ac

Breakpoint 2, pic_init () at picirq.c:15
15		didinit = 1;
Cannot access memory at address 0xef400000
Cannot access memory at address 0xef400000
Cannot access memory at address 0xef40000
$1 = 0xef400000
No symbol "UVPT" in current context.
$2 = (pde_t *) 0xf012d000
$3 = 0x0
0xf012d000:	0x00000000	0x00000000	0x00000000	0x00000000
0xf012d010:	0x00000000	0x00000000	0x00000000	0x00000000
0xf012d020:	0x00000000	0x00000000	0x00000000	0x00000000
0xf012d030:	0x00000000	0x00000000	0x00000000	0x00000000
0xf012d040:	0x00000000	0x00000000	0x00000000	0x00000000
0xf012d038:	0x00000000	0x00000000	0x00000000	0x00000000
0xf012d048:	0x00000000	0x00000000	0x00000000	0x00000000
0xf012d058:	0x00000000	0x00000000	0x00000000	0x00000000
0xf012d068:	0x00000000	0x00000000	0x00000000	0x00000000
0xf012d078:	0x00000000	0x00000000	0x00000000	0x00000000
0xf012def8:	0x00000000	0x00003007	0x00004027	0x00005007
0xf012df08:	0x00006007	0x00007007	0x00008007	0x00009007
0xf012df18:	0x0000a007	0x0000b007	0x0000c007	0x0000d007
0xf012df28:	0x0000e007	0x0000f007	0x00010007	0x00011007
0xf012df38:	0x00012007	0x00013007	0x00014007	0x00015007
0x3000:	Cannot access memory at address 0x3000
Invalid number "0x0xf0003000".
0xf0003000:	0x00000000	0x00000000	0x00000000	0x00000000
0xf0003010:	0x00000000	0x00000000	0x00000000	0x00000000
0xf0003020:	0x00000000	0x00000000	0x00000000	0x00000000
0xf0003030:	0x00000000	0x00000000	0x00000000	0x00000000
0xf0003040:	0x00000000	0x00000000	0x00000000	0x00000000
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Breakpoint 1 at 0xf0100201: file pmap.c, line 109.
Undefined command: "b_pic_init".  Try "help".
Breakpoint 2 at 0xf0103063: file picirq.c, line 14.
Continuing.
The target architecture is assumed to be i386
=> 0xf0100201 <mem_init>:	push   %ebp

Breakpoint 1, mem_init () at pmap.c:109
109	{
=> 0xf0100208 <mem_init+7>:	call   0xf0100100 <i386_detect_memory>
113		i386_detect_memory();
=> 0xf0100106 <i386_detect_memory+6>:	push   $0x15
i386_detect_memory () at pmap.c:41
41		npages_basemem = (nvram_read(NVRAM_BASELO) * 1024) / PGSIZE;
=> 0xf01000d9 <nvram_read+4>:	mov    0x8(%ebp),%eax
nvram_read (r=0x15) at pmap.c:31
31		return mc146818_read(r) | (mc146818_read(r + 1) << 8);
=> 0xf01000a4 <mc146818_read+6>:	mov    0x8(%ebp),%eax
mc146818_read (reg=0x15) at pmap.c:10
10		outb(IO_RTC, reg);
=> 0xf01000b4 <mc146818_read+22>:	movzbl -0xa(%ebp),%eax
outb (data=0x15, port=0x70) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01000c3 <mc146818_read+37>:	mov    -0x8(%ebp),%eax
mc146818_read (reg=0x15) at pmap.c:11
11		return inb(IO_RTC+1);
=> 0xf01000c3 <mc146818_read+37>:	mov    -0x8(%ebp),%eax
inb (port=0x71) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf01000cc <mc146818_read+46>:	movzbl -0x9(%ebp),%eax
73		return data;
=> 0xf01000d0 <mc146818_read+50>:	movzbl %al,%eax
mc146818_read (reg=0x15) at pmap.c:11
11		return inb(IO_RTC+1);
=> 0xf01000d3 <mc146818_read+53>:	leave  
12	}
=> 0xf01000a4 <mc146818_read+6>:	mov    0x8(%ebp),%eax
mc146818_read (reg=0x16) at pmap.c:10
10		outb(IO_RTC, reg);
=> 0xf01000b4 <mc146818_read+22>:	movzbl -0xa(%ebp),%eax
outb (data=0x16, port=0x70) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01000c3 <mc146818_read+37>:	mov    -0x8(%ebp),%eax
mc146818_read (reg=0x16) at pmap.c:11
11		return inb(IO_RTC+1);
=> 0xf01000c3 <mc146818_read+37>:	mov    -0x8(%ebp),%eax
inb (port=0x71) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf01000cc <mc146818_read+46>:	movzbl -0x9(%ebp),%eax
73		return data;
=> 0xf01000d0 <mc146818_read+50>:	movzbl %al,%eax
mc146818_read (reg=0x16) at pmap.c:11
11		return inb(IO_RTC+1);
=> 0xf01000d3 <mc146818_read+53>:	leave  
12	}
=> 0xf01000fb <nvram_read+38>:	mov    -0x4(%ebp),%ebx
nvram_read (r=0x15) at pmap.c:32
32	}
=> 0xf0100126 <i386_detect_memory+38>:	push   $0x17
i386_detect_memory () at pmap.c:42
42		npages_extmem = (nvram_read(NVRAM_EXTLO) * 1024) / PGSIZE;
=> 0xf01000d9 <nvram_read+4>:	mov    0x8(%ebp),%eax
nvram_read (r=0x17) at pmap.c:31
31		return mc146818_read(r) | (mc146818_read(r + 1) << 8);
=> 0xf01000a4 <mc146818_read+6>:	mov    0x8(%ebp),%eax
mc146818_read (reg=0x17) at pmap.c:10
10		outb(IO_RTC, reg);
=> 0xf01000b4 <mc146818_read+22>:	movzbl -0xa(%ebp),%eax
outb (data=0x17, port=0x70) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01000c3 <mc146818_read+37>:	mov    -0x8(%ebp),%eax
mc146818_read (reg=0x17) at pmap.c:11
11		return inb(IO_RTC+1);
=> 0xf01000c3 <mc146818_read+37>:	mov    -0x8(%ebp),%eax
inb (port=0x71) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf01000cc <mc146818_read+46>:	movzbl -0x9(%ebp),%eax
73		return data;
=> 0xf01000d0 <mc146818_read+50>:	movzbl %al,%eax
mc146818_read (reg=0x17) at pmap.c:11
11		return inb(IO_RTC+1);
=> 0xf01000d3 <mc146818_read+53>:	leave  
12	}
=> 0xf01000a4 <mc146818_read+6>:	mov    0x8(%ebp),%eax
mc146818_read (reg=0x18) at pmap.c:10
10		outb(IO_RTC, reg);
=> 0xf01000b4 <mc146818_read+22>:	movzbl -0xa(%ebp),%eax
outb (data=0x18, port=0x70) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf01000c3 <mc146818_read+37>:	mov    -0x8(%ebp),%eax
mc146818_read (reg=0x18) at pmap.c:11
11		return inb(IO_RTC+1);
=> 0xf01000c3 <mc146818_read+37>:	mov    -0x8(%ebp),%eax
inb (port=0x71) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf01000cc <mc146818_read+46>:	movzbl -0x9(%ebp),%eax
73		return data;
=> 0xf01000d0 <mc146818_read+50>:	movzbl %al,%eax
mc146818_read (reg=0x18) at pmap.c:11
11		return inb(IO_RTC+1);
=> 0xf01000d3 <mc146818_read+53>:	leave  
12	}
=> 0xf01000fb <nvram_read+38>:	mov    -0x4(%ebp),%ebx
nvram_read (r=0x17) at pmap.c:32
32	}
=> 0xf0100144 <i386_detect_memory+68>:	cmpl   $0x0,-0xc(%ebp)
i386_detect_memory () at pmap.c:46
46		if (npages_extmem)
=> 0xf010014a <i386_detect_memory+74>:	mov    -0xc(%ebp),%eax
47			npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
=> 0xf0100163 <i386_detect_memory+99>:	mov    0xf012c4c0,%eax
51		cprintf("Memory: %dK\n", npages*4);
=> 0xf0103b96 <cprintf+6>:	lea    0xc(%ebp),%eax
cprintf (fmt=0xf0104700 "Memory: %dK\n") at stdio.c:56
56		va_start(ap, fmt);
=> 0xf0103b9c <cprintf+12>:	mov    -0x10(%ebp),%eax
57		cnt = vcprintf(fmt, ap);
=> 0xf0103b6d <vcprintf+6>:	movl   $0x0,-0xc(%ebp)
vcprintf (fmt=0xf0104700 "Memory: %dK\n", ap=0xf010df94 "") at stdio.c:44
44		int cnt = 0;
=> 0xf0103b74 <vcprintf+13>:	pushl  0xc(%ebp)
46		vprintfmt((void*)putch, &cnt, fmt, ap);
=> 0xf0103cf6 <vprintfmt+8>:	jmp    0xf0103d0f <vprintfmt+33>
vprintfmt (putch=0xf0103b43 <putch>, putdat=0xf010df4c, fmt=0xf0104700 "Memory: %dK\n", ap=0xf010df94 "") at stdio.c:268
268			while ((ch = *(unsigned char *) fmt++) != '%') {
=> 0xf0103cf8 <vprintfmt+10>:	test   %ebx,%ebx
269				if (ch == '\0')
=> 0xf0103d00 <vprintfmt+18>:	sub    $0x8,%esp
271				putch(ch, putdat);
=> 0xf0103b49 <putch+6>:	sub    $0xc,%esp
putch (ch=0x4d, cnt=0xf010df4c) at stdio.c:37
37		cputchar(ch);
=> 0xf01012c7 <cputchar+6>:	sub    $0xc,%esp
cputchar (c=0x4d) at console.c:437
437		cons_putc(c);
=> 0xf0100ff9 <cons_putc+6>:	pushl  0x8(%ebp)
cons_putc (c=0x4d) at console.c:201
201		serial_putc(c);
=> 0xf0100b3e <serial_putc+6>:	movl   $0x0,-0x4(%ebp)
serial_putc (c=0x4d) at console.c:67
67		for (i = 0;
=> 0xf0100b57 <serial_putc+31>:	mov    -0x20(%ebp),%eax
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b57 <serial_putc+31>:	mov    -0x20(%ebp),%eax
inb (port=0x3fd) at ./x86.h:72
72		__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
=> 0xf0100b60 <serial_putc+40>:	movzbl -0x21(%ebp),%eax
73		return data;
=> 0xf0100b64 <serial_putc+44>:	movzbl %al,%eax
serial_putc (c=0x4d) at console.c:68
68		     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
=> 0xf0100b6a <serial_putc+50>:	test   %eax,%eax
67		for (i = 0;
=> 0xf0100b77 <serial_putc+63>:	cmpl   $0x8,0x8(%ebp)
72		if (c == '\b') {
=> 0xf0100c38 <serial_putc+256>:	mov    0x8(%ebp),%eax
87		outb(COM1 + COM_TX, c);
=> 0xf0100c48 <serial_putc+272>:	movzbl -0x27(%ebp),%eax
outb (data=0x4d, port=0x3f8) at ./x86.h:122
122		__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
=> 0xf0100c50 <serial_putc+280>:	leave  
serial_putc (c=0x4d) at console.c:88
88	}
=> 0xf0101004 <cons_putc+17>:	sub    $0xc,%esp
cons_putc (c=0x4d) at console.c:202
202		cga_putc(c);
=> 0xf0100df2 <cga_putc+7>:	mov    0x8(%ebp),%eax
cga_putc (c=0x4d) at console.c:155
155		if (!(c & ~0xFF))
=> 0xf0100dfb <cga_putc+16>:	orl    $0x700,0x8(%ebp)
156			c |= 0x0700;
=> 0xf0100e02 <cga_putc+23>:	mov    0x8(%ebp),%eax
158		switch (c & 0xff) {
=> 0xf0100ef2 <cga_putc+263>:	mov    0xf012b608,%ecx
178			crt_buf[crt_pos++] = c;		/* write the character */
=> 0xf0100f16 <cga_putc+299>:	jmp    0xf0100f19 <cga_putc+302>
179			break;
Continuing.
=> 0xf0103063 <pic_init>:	push   %ebp

Breakpoint 2, pic_init () at picirq.c:14
14	{
Undefined command: "gdb".  Try "help".
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Breakpoint 1 at 0xf0103063: file picirq.c, line 14.
Continuing.
The target architecture is assumed to be i386
=> 0xf0103063 <pic_init>:	push   %ebp

Breakpoint 1, pic_init () at picirq.c:14
14	{
0xf012d000:	0x00000000	0x00000000	0x00000000	0x00000000
0xf012d010:	0x00000000	0x00000000	0x00000000	0x00000000
0xf012d020:	0x00000000	0x00000000	0x00000000	0x00000000
0xf012d030:	0x00000000	0x00000000	0x00000000	0x00000000
0xf012d040:	0x00000000	0x00000000	0x00000000	0x00000000
0xf012def4:	0x0012d005	0x00000000	0x00003007	0x00004027
0xf012df04:	0x00005007	0x00006007	0x00007007	0x00008007
0xf012df14:	0x00009007	0x0000a007	0x0000b007	0x0000c007
0xf012df24:	0x0000d007	0x0000e007	0x0000f007	0x00010007
0xf012df34:	0x00011007	0x00012007	0x00013007	0x00014007
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Reading symbols from ls...(no debugging symbols found)...done.
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Reading symbols from ls...done.
History has not yet reached $80001020.
Breakpoint 1 at 0x80001020: file uentry.S, line 24.
Continuing.
[  1b:80001020]    0x80001272 <ls+99>:	shr    $0x16,%ax

Breakpoint 1, _start () at uentry.S:24
24		cmpl $USTACKTOP, %esp
[  1b:80001026]    0x80001278 <ls+105>:	add    %dl,%al
25		jne args_exist
[  1b:80001028]    0x8000127a <ls+107>:	jnp    0x8000126b <ls+92>
30		pushl $0
[  1b:8000102a]    0x8000127c <ls+109>:	mov    $0x0,%ax
31		pushl $0
[  1b:8000102c]    0x8000127e <ls+111>:	add    %al,(%bx,%si)
34		call libmain
[  1b:80002a87]    0x80002cd9 <vprintfmt+510>:	push   %bx
0x80002a87 in writebuf (b=0x0) at stdio.c:144
144			if (result > 0)
[  1b:80002a88]    0x80002cda <vprintfmt+511>:	sub    $0xc,%sp
0x80002a88	144			if (result > 0)
[  1b:80002a8a]    0x80002cdc <vprintfmt+513>:	or     $0xbb,%al
0x80002a8a in writebuf (b=0x0) at stdio.c:144
144			if (result > 0)
[  1b:80002a8b]    0x80002cdd <vprintfmt+514>:	mov    $0x0,%bx
writebuf (b=0x0) at stdio.c:145
145				b->result += result;
[  1b:80002a8c]    0x80002cde <vprintfmt+515>:	add    %al,(%bx,%si)
0x80002a8c in writebuf (b=0x0) at stdio.c:145
145				b->result += result;
[  1b:80002a8f]    0x80002ce1 <vprintfmt+518>:	add    %bh,0xa(%bx,%si)
0x80002a8f	146			if (result != b->idx) // error, or wrote less than supplied
[  1b:80002a92]    0x80002ce4 <vprintfmt+521>:	add    %al,(%bx,%si)
0x80002a92	146			if (result != b->idx) // error, or wrote less than supplied
Continuing.
[  1b:80001020]    0x80001272 <ls+99>:	mov    %ax,0x6008

Breakpoint 1, _start () at uentry.S:24
24		cmpl $USTACKTOP, %esp
Continuing.
[  1b:80001020]    0x80001272 <ls+99>:	sub    $0x20,%sp

Breakpoint 1, _start () at uentry.S:24
24		cmpl $USTACKTOP, %esp
[  1b:80001022]    0x80001274 <ls+101>:	and    %cl,0x85d(%bp,%di)
0x80001022	24		cmpl $USTACKTOP, %esp
19	;// starts us running when we are initially loaded into a new environment.
20	.text
21	.globl _start
22	_start:
23		;// See if we were started with arguments on the stack
24		cmpl $USTACKTOP, %esp
25		jne args_exist
26	
27		;// If not, push dummy argc/argv arguments.
28		;// This happens when we are loaded by the kernel,
0x80001278 <ls+105>:	0xf156e853	0xc483ffff	0x7ff88310	0xec83677f
0x80001288 <ls+121>:	0xf4458d0c	0xf899e850	0xc483ffff	0x85c28910
0x80001298 <ls+137>:	0x835778c0	0x685308ec	0x80006000	0xfff186e8
0x800012a8 <ls+153>:	0x0c458bff	0x006080a3	0xf4558b80	0x000001b8
0x800012b8 <usage+4>:	0xfe36e800	0xc389ffff	0x8510c483	0x831479c0
0x80001020 <_start>:	0xec831474	0x0c75ff08	0x89d2ff50	0x10c483c2
0x80001030 <args_exist+4>:	0xc28909eb	0xefba05eb	0x89ffffff	0xfc5d8bd0
0x80001040 <ls1+13>:	0x8955c3c9	0xec8353e5	0x0c5d8b14	0x50f0458d
0x80001050 <ls1+29>:	0xe80875ff	0xfffffb47	0x8908c483	0x78c085c2
0x80001060 <ls1+45>:	0x08ec834f	0x50f4458d	0xfff0458b	0xfb83e830
   0x80001020 <_start>:	je     0x80001036 <ls1+3>
=> 0x80001022 <_start+2>:	sub    $0x8,%sp
   0x80001025 <_start+5>:	pushw  0xc(%di)
   0x80001028 <_start+8>:	push   %ax
   0x80001029 <_start+9>:	call   *%dx
   0x8000102b <_start+11>:	mov    %ax,%dx
   0x8000102d <args_exist+1>:	add    $0x10,%sp
   0x80001030 <args_exist+4>:	jmp    0x8000103b <ls1+8>
   0x80001032 <args_exist+6>:	mov    %ax,%dx
   0x80001034 <ls1+1>:	jmp    0x8000103b <ls1+8>
   0x80001036 <ls1+3>:	mov    $0xffef,%dx
   0x80001039 <ls1+6>:	(bad)  
   0x8000103a <ls1+7>:	decw   -0x7430(%bx,%di)
   0x8000103e <ls1+11>:	pop    %bp
   0x8000103f <ls1+12>:	cld    
   0x80001040 <ls1+13>:	leave  
   0x80001041 <ls1+14>:	ret    
   0x80001042 <ls1+15>:	push   %bp
   0x80001043 <ls1+16>:	mov    %sp,%bp
   0x80001045 <ls1+18>:	push   %bx
[  1b:80001025]    0x80001277 <ls+104>:	or     %dl,-0x18(%bp,%di)
0x80001025 in _start () at uentry.S:24
24		cmpl $USTACKTOP, %esp
[  1b:80001028]    0x8000127a <ls+107>:	push   %si
_start () at uentry.S:30
30		pushl $0
[  1b:80001029]    0x8000127b <ls+108>:	icebp  
0x80001029 in _start () at uentry.S:30
30		pushl $0
[  1b:eebfd708]    0xeebfd95a:	add    %al,(%bx,%si)
0xeebfd708 in ?? ()
The target architecture is assumed to be i386
=> 0xf010165e:	jmp    0xf0101682
0xf010165e in ?? ()
0x80001020 <_start>:	0xec831474	0x0c75ff08	0x89d2ff50	0x10c483c2
0x80001030 <args_exist+4>:	0xc28909eb	0xefba05eb	0x89ffffff	0xfc5d8bd0
0x80001040 <ls1+13>:	0x8955c3c9	0xec8353e5	0x0c5d8b14	0x50f0458d
0x80001050 <ls1+29>:	0xe80875ff	0xfffffb47	0x8908c483	0x78c085c2
0x80001060 <ls1+45>:	0x08ec834f	0x50f4458d	0xfff0458b	0xfb83e830
   0x80001020 <_start>:	je     0x80001036 <ls1+3>
   0x80001022 <_start+2>:	sub    $0x8,%esp
   0x80001025 <_start+5>:	pushl  0xc(%ebp)
   0x80001028 <_start+8>:	push   %eax
   0x80001029 <_start+9>:	call   *%edx
   0x8000102b <_start+11>:	mov    %eax,%edx
   0x8000102d <args_exist+1>:	add    $0x10,%esp
   0x80001030 <args_exist+4>:	jmp    0x8000103b <ls1+8>
   0x80001032 <args_exist+6>:	mov    %eax,%edx
   0x80001034 <ls1+1>:	jmp    0x8000103b <ls1+8>
   0x80001036 <ls1+3>:	mov    $0xffffffef,%edx
   0x8000103b <ls1+8>:	mov    %edx,%eax
   0x8000103d <ls1+10>:	mov    -0x4(%ebp),%ebx
   0x80001040 <ls1+13>:	leave  
   0x80001041 <ls1+14>:	ret    
   0x80001042 <ls1+15>:	push   %ebp
   0x80001043 <ls1+16>:	mov    %esp,%ebp
   0x80001045 <ls1+18>:	push   %ebx
   0x80001046 <ls1+19>:	sub    $0x14,%esp
   0x80001049 <ls1+22>:	mov    0xc(%ebp),%ebx
   0x80001029 <_start+9>:	call   *%edx
   0x8000102b <_start+11>:	mov    %eax,%edx
   0x8000102d <args_exist+1>:	add    $0x10,%esp
   0x80001030 <args_exist+4>:	jmp    0x8000103b <ls1+8>
   0x80001032 <args_exist+6>:	mov    %eax,%edx
   0x80001034 <ls1+1>:	jmp    0x8000103b <ls1+8>
   0x80001036 <ls1+3>:	mov    $0xffffffef,%edx
   0x8000103b <ls1+8>:	mov    %edx,%eax
   0x8000103d <ls1+10>:	mov    -0x4(%ebp),%ebx
   0x80001040 <ls1+13>:	leave  
   0x80001041 <ls1+14>:	ret    
   0x80001042 <ls1+15>:	push   %ebp
   0x80001043 <ls1+16>:	mov    %esp,%ebp
   0x80001045 <ls1+18>:	push   %ebx
   0x80001046 <ls1+19>:	sub    $0x14,%esp
   0x80001049 <ls1+22>:	mov    0xc(%ebp),%ebx
   0x8000104c <ls1+25>:	lea    -0x10(%ebp),%eax
   0x8000104f <ls1+28>:	push   %eax
   0x80001050 <ls1+29>:	pushl  0x8(%ebp)
   0x80001053 <ls1+32>:	call   0x80000b9f
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Reading symbols from ls...done.
Function "spawn" not defined.
No line 80001020 in the current file.
Breakpoint 1 at 0x80001020: file uentry.S, line 24.
Function "spawn1" not defined.
Continuing.
[  1b:80001020]    0x80001272 <ls+99>:	shr    $0x16,%ax

Breakpoint 1, _start () at uentry.S:24
24		cmpl $USTACKTOP, %esp
[  1b:80001026]    0x80001278 <ls+105>:	add    %dl,%al
25		jne args_exist
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Reading symbols from ls...done.
Function "spawn" not defined.
Breakpoint 1 at 0x80001020: file uentry.S, line 24.
Continuing.
[  1b:80001020]    0x80001272 <ls+99>:	shr    $0x16,%ax

Breakpoint 1, _start () at uentry.S:24
24		cmpl $USTACKTOP, %esp
Continuing.
[  1b:80001020]    0x80001272 <ls+99>:	mov    %ax,0x6008

Breakpoint 1, _start () at uentry.S:24
24		cmpl $USTACKTOP, %esp
Continuing.
[  1b:80001020]    0x80001272 <ls+99>:	sub    $0x20,%sp

Breakpoint 1, _start () at uentry.S:24
24		cmpl $USTACKTOP, %esp
=> 0x80001020 <_start>:	je     0x80001036 <ls1+3>
   0x80001022 <_start+2>:	sub    $0x8,%sp
   0x80001025 <_start+5>:	pushw  0xc(%di)
   0x80001028 <_start+8>:	push   %ax
   0x80001029 <_start+9>:	call   *%dx
   0x8000102b <_start+11>:	mov    %ax,%dx
   0x8000102d <args_exist+1>:	add    $0x10,%sp
   0x80001030 <args_exist+4>:	jmp    0x8000103b <ls1+8>
   0x80001032 <args_exist+6>:	mov    %ax,%dx
   0x80001034 <ls1+1>:	jmp    0x8000103b <ls1+8>
19	;// starts us running when we are initially loaded into a new environment.
20	.text
21	.globl _start
22	_start:
23		;// See if we were started with arguments on the stack
24		cmpl $USTACKTOP, %esp
25		jne args_exist
26	
27		;// If not, push dummy argc/argv arguments.
28		;// This happens when we are loaded by the kernel,
=> 0x80001020 <_start>:	je     0x80001036 <ls1+3>
   0x80001022 <_start+2>:	sub    $0x8,%sp
   0x80001025 <_start+5>:	pushw  0xc(%di)
   0x80001028 <_start+8>:	push   %ax
   0x80001029 <_start+9>:	call   *%dx
   0x8000102b <_start+11>:	mov    %ax,%dx
   0x8000102d <args_exist+1>:	add    $0x10,%sp
   0x80001030 <args_exist+4>:	jmp    0x8000103b <ls1+8>
   0x80001032 <args_exist+6>:	mov    %ax,%dx
[  1b:80001022]    0x80001274 <ls+101>:	and    %cl,0x85d(%bp,%di)
0x80001022	24		cmpl $USTACKTOP, %esp
No symbol "esp" in current context.
A syntax error in expression, near `%esp'.
A syntax error in expression, near `%esp)'.
[34m--------------------------------------------------------------------------[34m[1m[regs]
[0m  [32mEAX:[30m 0x00000000  [32mEBX:[31m 0xEEBFDB24  [32mECX:[31m 0x0000002C  [32mEDX:[31m 0xEEBFD708  [1m[4m[31mo d I t S z A P c 
[0m  [32mESI:[31m 0x00000001  [32mEDI:[30m 0x00000000  [32mEBP:[31m 0xEEBFDAE0  [32mESP:[31m 0xEEBFDFEC  [32mEIP:[31m 0x80001022
  [32mCS:[30m 001B  [32mDS:[30m 0023  [32mES:[30m 0023  [32mFS:[30m 0023  [32mGS:[30m 0023  [32mSS:[30m 0023[0m
[36m[34m[0x0023:0xEEBFDFEC][34m------------------------------------------------------[34m[1m[stack]
[0m[1m0xEEBFE03C : [0mCannot access memory at address 0xeebfe03c
0xeebfdfec:	0x00000001	0xeebfdff4	0xeebfdffc	0x00000000
0xeebfdffc:	0x00736c2f
0xeebfdfec:	0x00000001	0xeebfdff4	0xeebfdffc	0x00000000
0xeebfdffc:	0x00736c2f	Cannot access memory at address 0xeebfe000
0xeebfdff4:	0xeebfdffc	0x00000000	0x00736c2f	Cannot access memory at address 0xeebfe000
0xeebfdffc:	0x00736c2f	Cannot access memory at address 0xeebfe000
0xeebfdffc:	0x2f	0x6c	0x73	0x0	Cannot access memory at address 0xeebfe000
0xeebfdffc:	"/ls"
0xeebfe000:	<error: Cannot access memory at address 0xeebfe000>
0xeebfe000:	<error: Cannot access memory at address 0xeebfe000>
0xeebfe000:	<error: Cannot access memory at address 0xeebfe000>
0xeebfe000:	<error: Cannot access memory at address 0xeebfe000>
0xeebfe000:	<error: Cannot access memory at address 0xeebfe000>
0xeebfe000:	<error: Cannot access memory at address 0xeebfe000>
0xeebfe000:	<error: Cannot access memory at address 0xeebfe000>
0xeebfe000:	<error: Cannot access memory at address 0xeebfe000>
0xeebfe000:	<error: Cannot access memory at address 0xeebfe000>
0xeebfdffc:	"/ls"
[  1b:80001025]    0x80001277 <ls+104>:	or     %dl,-0x18(%bp,%di)
0x80001025 in _start () at uentry.S:24
24		cmpl $USTACKTOP, %esp
[  1b:80001028]    0x8000127a <ls+107>:	push   %si
_start () at uentry.S:30
30		pushl $0
[34m--------------------------------------------------------------------------[34m[1m[regs]
[0m  [32mEAX:[30m 0x00000000  [32mEBX:[30m 0xEEBFDB24  [32mECX:[30m 0x0000002C  [32mEDX:[30m 0xEEBFD708  [1m[4m[31mo d I t S z a P c 
[0m  [32mESI:[30m 0x00000001  [32mEDI:[30m 0x00000000  [32mEBP:[30m 0xEEBFDAE0  [32mESP:[31m 0xEEBFDFE0  [32mEIP:[31m 0x80001028
  [32mCS:[30m 001B  [32mDS:[30m 0023  [32mES:[30m 0023  [32mFS:[30m 0023  [32mGS:[30m 0023  [32mSS:[30m 0023[0m
[36m[34m[0x0023:0xEEBFDFE0][34m------------------------------------------------------[34m[1m[stack]
[0m[1m0xEEBFE030 : [0mCannot access memory at address 0xeebfe030
Undefined info command: "regester".  Try "help info".
eax            0x0	0x0
ecx            0x2c	0x2c
edx            0xeebfd708	0xeebfd708
ebx            0xeebfdb24	0xeebfdb24
esp            0xeebfdfe0	0xeebfdfe0
ebp            0xeebfdae0	0xeebfdae0
esi            0x1	0x1
edi            0x0	0x0
eip            0x80001028	0x80001028 <_start+8>
eflags         0x286	[ PF SF IF ]
cs             0x1b	0x1b
ss             0x23	0x23
ds             0x23	0x23
es             0x23	0x23
fs             0x23	0x23
gs             0x23	0x23
[  1b:80001029]    0x8000127b <ls+108>:	icebp  
0x80001029 in _start () at uentry.S:30
30		pushl $0
Undefined command: "objdump".  Try "help".
Dump of assembler code for function _start:
   0x80001020 <+0>:	je     0x80001036 <ls1+3>
   0x80001022 <+2>:	sub    $0x8,%sp
   0x80001025 <+5>:	pushw  0xc(%di)
   0x80001028 <+8>:	push   %ax
=> 0x80001029 <+9>:	call   *%dx
   0x8000102b <+11>:	mov    %ax,%dx
End of assembler dump.
The target architecture is assumed to be i386
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Reading symbols from ls...done.
Function "0x80001020" not defined.
Breakpoint 1 at 0x80001020: file uentry.S, line 24.
Continuing.
[  1b:80001020]    0x80001272 <ls+99>:	shr    $0x16,%ax

Breakpoint 1, _start () at uentry.S:24
24		cmpl $USTACKTOP, %esp
Continuing.
[  1b:80001020]    0x80001272 <ls+99>:	mov    %ax,0x6008

Breakpoint 1, _start () at uentry.S:24
24		cmpl $USTACKTOP, %esp
Continuing.
[  1b:80001020]    0x80001272 <ls+99>:	sub    $0x20,%sp

Breakpoint 1, _start () at uentry.S:24
24		cmpl $USTACKTOP, %esp
The target architecture is assumed to be i386
[  1b:80001022]    0x80001274 <ls+101>:	and    %cl,-0x17acf7a3(%ebx)
0x80001022	24		cmpl $USTACKTOP, %esp
[  1b:80001025]    0x80001277 <ls+104>:	or     %dl,-0x18(%ebx)
0x80001025 in _start () at uentry.S:24
24		cmpl $USTACKTOP, %esp
[  1b:80001028]    0x8000127a <ls+107>:	push   %esi
_start () at uentry.S:30
30		pushl $0
[  1b:80001029]    0x8000127b <ls+108>:	icebp  
0x80001029 in _start () at uentry.S:30
30		pushl $0
[  1b:eebfd708]    0xeebfd95a:	add    %al,(%eax)
0xeebfd708 in ?? ()
   0x80001029 <_start+9>:	call   *%edx
   0x8000102b <_start+11>:	mov    %eax,%edx
   0x8000102d <args_exist+1>:	add    $0x10,%esp
   0x80001030 <args_exist+4>:	jmp    0x8000103b <ls1+8>
   0x80001032 <args_exist+6>:	mov    %eax,%edx
   0x80001034 <ls1+1>:	jmp    0x8000103b <ls1+8>
   0x80001036 <ls1+3>:	mov    $0xffffffef,%edx
   0x8000103b <ls1+8>:	mov    %edx,%eax
   0x8000103d <ls1+10>:	mov    -0x4(%ebp),%ebx
   0x80001040 <ls1+13>:	leave  
   0x80001041 <ls1+14>:	ret    
   0x80001042 <ls1+15>:	push   %ebp
   0x80001043 <ls1+16>:	mov    %esp,%ebp
   0x80001045 <ls1+18>:	push   %ebx
   0x80001046 <ls1+19>:	sub    $0x14,%esp
   0x80001049 <ls1+22>:	mov    0xc(%ebp),%ebx
   0x8000104c <ls1+25>:	lea    -0x10(%ebp),%eax
   0x8000104f <ls1+28>:	push   %eax
   0x80001050 <ls1+29>:	pushl  0x8(%ebp)
   0x80001053 <ls1+32>:	call   0x80000b9f
eax            0x0	0x0
ecx            0x2c	0x2c
edx            0xeebfd708	0xeebfd708
ebx            0xeebfdb24	0xeebfdb24
esp            0xeebfdfd0	0xeebfdfd0
ebp            0xeebfdae0	0xeebfdae0
esi            0x2	0x2
edi            0x0	0x0
eip            0xeebfd708	0xeebfd708
eflags         0x292	[ AF SF IF ]
cs             0x1b	0x1b
ss             0x23	0x23
ds             0x23	0x23
es             0x23	0x23
fs             0x23	0x23
gs             0x23	0x23
   0x80001020 <_start>:	je     0x80001036 <ls1+3>
   0x80001022 <_start+2>:	sub    $0x8,%esp
   0x80001025 <_start+5>:	pushl  0xc(%ebp)
   0x80001028 <_start+8>:	push   %eax
   0x80001029 <_start+9>:	call   *%edx
   0x8000102b <_start+11>:	mov    %eax,%edx
   0x8000102d <args_exist+1>:	add    $0x10,%esp
   0x80001030 <args_exist+4>:	jmp    0x8000103b <ls1+8>
   0x80001032 <args_exist+6>:	mov    %eax,%edx
   0x80001034 <ls1+1>:	jmp    0x8000103b <ls1+8>
   0x80001036 <ls1+3>:	mov    $0xffffffef,%edx
   0x8000103b <ls1+8>:	mov    %edx,%eax
   0x8000103d <ls1+10>:	mov    -0x4(%ebp),%ebx
   0x80001040 <ls1+13>:	leave  
   0x80001041 <ls1+14>:	ret    
   0x80001042 <ls1+15>:	push   %ebp
   0x80001043 <ls1+16>:	mov    %esp,%ebp
   0x80001045 <ls1+18>:	push   %ebx
   0x80001046 <ls1+19>:	sub    $0x14,%esp
   0x80001049 <ls1+22>:	mov    0xc(%ebp),%ebx
Detaching from program: , Remote target
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
The "remote" target does not support "run".  Try "help target" or "continue".
Continuing.
Remote connection closed

warning: ~/.gdbinit.local: No such file or directory
+ target remote localhost:26000
warning: A handler for the OS ABI "GNU/Linux" is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
[f000:fff0]    0x159ff0:	add    %al,(%bx,%si)
0x0000fff0 in ?? ()
+ symbol-file kernel
Reading symbols from ls...done.
Breakpoint 1 at 0x80001020: file uentry.S, line 24.
Continuing.
[  1b:80001020]    0x80001272 <ls+99>:	shr    $0x16,%ax

Breakpoint 1, _start () at uentry.S:24
24		cmpl $USTACKTOP, %esp
The target architecture is assumed to be i386
[  1b:80001026]    0x80001278 <ls+105>:	add    %dl,%al
25		jne args_exist
[  1b:80001028]    0x8000127a <ls+107>:	jnp    0x8000126b <ls+92>
30		pushl $0
[  1b:8000102a]    0x8000127c <ls+109>:	mov    $0x0,%eax
31		pushl $0
[  1b:8000102c]    0x8000127e <ls+111>:	add    %al,(%eax)
34		call libmain
[  1b:80002a87]    0x80002cd9 <vprintfmt+510>:	push   %ebx
0x80002a87 in writebuf (b=0x0) at stdio.c:144
144			if (result > 0)
[  1b:80002a88]    0x80002cda <vprintfmt+511>:	sub    $0xc,%esp
0x80002a88	144			if (result > 0)
[  1b:80002a8a]    0x80002cdc <vprintfmt+513>:	or     $0xbb,%al
0x80002a8a in writebuf (b=0x0) at stdio.c:144
144			if (result > 0)
[  1b:80002a8b]    0x80002cdd <vprintfmt+514>:	mov    $0x0,%ebx
writebuf (b=0x0) at stdio.c:145
145				b->result += result;
[  1b:80002a8c]    0x80002cde <vprintfmt+515>:	add    %al,(%eax)
0x80002a8c in writebuf (b=0x0) at stdio.c:145
145				b->result += result;
[  1b:80002a8f]    0x80002ce1 <vprintfmt+518>:	add    %bh,0xa(%eax)
0x80002a8f	146			if (result != b->idx) // error, or wrote less than supplied
[  1b:80002a92]    0x80002ce4 <vprintfmt+521>:	add    %al,(%eax)
0x80002a92	146			if (result != b->idx) // error, or wrote less than supplied
[  1b:80002b4b]    0x80002d9d <vprintfmt+706>:	adc    %ch,0x7(%edx)
vprintfmt (putch=0x0, putdat=0x0, fmt=<error reading variable: Cannot access memory at address 0xeebfe000>, ap=<error reading variable: Cannot access memory at address 0xeebfe004>) at stdio.c:283
283			switch (ch = *(unsigned char *) fmt++) {
[  1b:80002b4c]    0x80002d9e <vprintfmt+707>:	push   $0x7
0x80002b4c in vprintfmt (putch=0x0, putdat=0x0, fmt=<error reading variable: Cannot access memory at address 0xeebfe000>, ap=<error reading variable: Cannot access memory at address 0xeebfe004>) at stdio.c:283
283			switch (ch = *(unsigned char *) fmt++) {
[  1b:80002b4e]    0x80002da0 <vprintfmt+709>:	push   $0x8000b000
287				padc = '-';
[  1b:80002b4f]    0x80002da1 <vprintfmt+710>:	add    %dh,-0xa98000(%eax)
0x80002b4f in vprintfmt (putch=0x0, putdat=0x0, fmt=0x0, ap=0x80001031 <args_exist+5> "\353\376U\211\345\203\354\b\241$\244") at stdio.c:287
287				padc = '-';
[  1b:80002b50]    0x80002da2 <vprintfmt+711>:	mov    $0x0,%al
0x80002b50 in vprintfmt (putch=0x0, putdat=0x0, fmt=0x0, ap=0x80001031 <args_exist+5> "\353\376U\211\345\203\354\b\241$\244") at stdio.c:287
287				padc = '-';
[  1b:80002b51]    0x80002da3 <vprintfmt+712>:	add    %al,0x35ff56(%eax)
0x80002b51 in vprintfmt (putch=0x0, putdat=0x0, fmt=0x0, ap=0x80001031 <args_exist+5> "\353\376U\211\345\203\354\b\241$\244") at stdio.c:287
287				padc = '-';
[  1b:80002b56]    0x80002da8 <vprintfmt+717>:	add    %ah,0x66e88000(%eax)
0x80002b56	283			switch (ch = *(unsigned char *) fmt++) {
[  1b:80002b5b]    0x80002dad <vprintfmt+722>:	data16 add (%eax),%al
0x80002b5b	283			switch (ch = *(unsigned char *) fmt++) {
[  1b:80002b5d]    0x80002daf <vprintfmt+724>:	add    %al,(%eax)
0x80002b5d	283			switch (ch = *(unsigned char *) fmt++) {
[  1b:80002b5f]    0x80002db1 <vprintfmt+726>:	add    $0xc,%esp
0x80002b5f	283			switch (ch = *(unsigned char *) fmt++) {
[  1b:80002b61]    0x80002db3 <vprintfmt+728>:	or     $0x6a,%al
0x80002b61	283			switch (ch = *(unsigned char *) fmt++) {
[  1b:80002b63]    0x80002db5 <vprintfmt+730>:	add    %dl,0x6a(%ebx)
0x80002b63	283			switch (ch = *(unsigned char *) fmt++) {
The target architecture is assumed to be i386
=> 0xf0101678:	push   $0x30
0xf0101678 in ?? ()
=> 0xf010167a:	jmp    0xf0101682
0xf010167a in ?? ()
=> 0xf0101682:	push   %ds
0xf0101682 in ?? ()
=> 0xf0101683:	push   %es
0xf0101683 in ?? ()
=> 0xf0101684:	pusha  
0xf0101684 in ?? ()
=> 0xf0101685:	mov    $0x10,%ax
0xf0101685 in ?? ()
=> 0xf0101689:	mov    %eax,%ds
0xf0101689 in ?? ()
=> 0xf010168b:	mov    %eax,%es
0xf010168b in ?? ()
=> 0xf010168d:	push   %esp
0xf010168d in ?? ()
=> 0xf010168e:	call   0xf01025b5
0xf010168e in ?? ()
Continuing.
The target architecture is assumed to be i8086
[  1b:80001020]    0x80001272 <ls+99>:	mov    %ax,0x6008

Breakpoint 1, _start () at uentry.S:24
24		cmpl $USTACKTOP, %esp
Continuing.
[  1b:80001020]    0x80001272 <ls+99>:	sub    $0x20,%sp

Breakpoint 1, _start () at uentry.S:24
24		cmpl $USTACKTOP, %esp
[  1b:80001022]    0x80001274 <ls+101>:	and    %cl,0x85d(%bp,%di)
0x80001022	24		cmpl $USTACKTOP, %esp
[  1b:80001025]    0x80001277 <ls+104>:	or     %dl,-0x18(%bp,%di)
0x80001025 in _start () at uentry.S:24
24		cmpl $USTACKTOP, %esp
[  1b:80001028]    0x8000127a <ls+107>:	push   %si
_start () at uentry.S:30
30		pushl $0
[  1b:80001029]    0x8000127b <ls+108>:	icebp  
0x80001029 in _start () at uentry.S:30
30		pushl $0
[  1b:eebfd708]    0xeebfd95a:	add    %al,(%bx,%si)
0xeebfd708 in ?? ()
The target architecture is assumed to be i386
=> 0xf010165e:	jmp    0xf0101682
0xf010165e in ?? ()
=> 0xf0101682:	push   %ds
0xf0101682 in ?? ()
=> 0xf0101683:	push   %es
0xf0101683 in ?? ()
=> 0xf0101684:	pusha  
0xf0101684 in ?? ()
=> 0xf0101685:	mov    $0x10,%ax
0xf0101685 in ?? ()
=> 0xf0101689:	mov    %eax,%ds
0xf0101689 in ?? ()
=> 0xf010168b:	mov    %eax,%es
0xf010168b in ?? ()
=> 0xf010168d:	push   %esp
0xf010168d in ?? ()
=> 0xf010168e:	call   0xf01025b5
0xf010168e in ?? ()
=> 0xf01025b5:	push   %ebp
0xf01025b5 in ?? ()
=> 0xf01025b6:	mov    %esp,%ebp
0xf01025b6 in ?? ()
=> 0xf01025b8:	push   %edi
0xf01025b8 in ?? ()
=> 0xf01025b9:	push   %esi
0xf01025b9 in ?? ()
=> 0xf01025ba:	push   %ebx
0xf01025ba in ?? ()
=> 0xf01025bb:	sub    $0xc,%esp
0xf01025bb in ?? ()
=> 0xf01025be:	cld    
0xf01025be in ?? ()
=> 0xf01025bf:	mov    0x8(%ebp),%eax
0xf01025bf in ?? ()
=> 0xf01025c2:	movzwl 0x34(%eax),%eax
0xf01025c2 in ?? ()
=> 0xf01025c6:	movzwl %ax,%eax
0xf01025c6 in ?? ()
=> 0xf01025c9:	and    $0x3,%eax
0xf01025c9 in ?? ()
=> 0xf01025cc:	cmp    $0x3,%eax
0xf01025cc in ?? ()
=> 0xf01025cf:	jne    0xf0102623
0xf01025cf in ?? ()
=> 0xf01025d1:	call   0xf0101693
0xf01025d1 in ?? ()
=> 0xf0101693:	push   %ebp
0xf0101693 in ?? ()
=> 0xf0101694:	mov    %esp,%ebp
0xf0101694 in ?? ()
=> 0xf0101696:	sub    $0x8,%esp
0xf0101696 in ?? ()
=> 0xf0101699:	sub    $0xc,%esp
0xf0101699 in ?? ()
=> 0xf010169c:	push   $0xf01425ec
0xf010169c in ?? ()
=> 0xf01016a1:	call   0xf0103afc
0xf01016a1 in ?? ()
=> 0xf0103afc:	push   %ebp
0xf0103afc in ?? ()
=> 0xf0103afd:	mov    %esp,%ebp
0xf0103afd in ?? ()
=> 0xf0103aff:	jmp    0xf0103b03
0xf0103aff in ?? ()
=> 0xf0103b03:	mov    0x8(%ebp),%eax
0xf0103b03 in ?? ()
=> 0xf0103b06:	push   $0x1
0xf0103b06 in ?? ()
=> 0xf0103b08:	push   %eax
0xf0103b08 in ?? ()
=> 0xf0103b09:	call   0xf0103ad3
0xf0103b09 in ?? ()
=> 0xf0103ad3:	push   %ebp
0xf0103ad3 in ?? ()
=> 0xf0103ad4:	mov    %esp,%ebp
0xf0103ad4 in ?? ()
=> 0xf0103ad6:	sub    $0x10,%esp
0xf0103ad6 in ?? ()
=> 0xf0103ad9:	mov    0x8(%ebp),%edx
0xf0103ad9 in ?? ()
=> 0xf0103adc:	mov    0xc(%ebp),%eax
0xf0103adc in ?? ()
=> 0xf0103adf:	mov    0x8(%ebp),%ecx
0xf0103adf in ?? ()
=> 0xf0103ae2:	lock xchg %eax,(%edx)
0xf0103ae2 in ?? ()
=> 0xf0103ae5:	mov    %eax,-0x4(%ebp)
0xf0103ae5 in ?? ()
=> 0xf0103ae8:	mov    -0x4(%ebp),%eax
0xf0103ae8 in ?? ()
=> 0xf0103aeb:	leave  
0xf0103aeb in ?? ()
=> 0xf0103aec:	ret    
0xf0103aec in ?? ()
=> 0xf0103b0e:	add    $0x8,%esp
0xf0103b0e in ?? ()
=> 0xf0103b11:	test   %eax,%eax
0xf0103b11 in ?? ()
=> 0xf0103b13:	jne    0xf0103b01
0xf0103b13 in ?? ()
=> 0xf0103b15:	nop
0xf0103b15 in ?? ()
=> 0xf0103b16:	leave  
0xf0103b16 in ?? ()
=> 0xf0103b17:	ret    
0xf0103b17 in ?? ()
=> 0xf01016a6:	add    $0x10,%esp
0xf01016a6 in ?? ()
=> 0xf01016a9:	nop
0xf01016a9 in ?? ()
=> 0xf01016aa:	leave  
0xf01016aa in ?? ()
=> 0xf01016ab:	ret    
0xf01016ab in ?? ()
=> 0xf01025d6:	mov    0xf01421d4,%eax
0xf01025d6 in ?? ()
=> 0xf01025db:	mov    0x54(%eax),%eax
0xf01025db in ?? ()
=> 0xf01025de:	cmp    $0x1,%eax
0xf01025de in ?? ()
=> 0xf01025e1:	jne    0xf0102603
0xf01025e1 in ?? ()
=> 0xf0102603:	mov    0xf01421d4,%edx
0xf0102603 in ?? ()
Cannot find bounds of current function
Cannot find bounds of current function
=> 0xf0102609:	mov    0x8(%ebp),%eax
0xf0102609 in ?? ()
=> 0xf010260c:	mov    %eax,%ebx
0xf010260c in ?? ()
=> 0xf010260e:	mov    $0x11,%eax
0xf010260e in ?? ()
=> 0xf0102613:	mov    %edx,%edi
0xf0102613 in ?? ()
=> 0xf0102615:	mov    %ebx,%esi
0xf0102615 in ?? ()
=> 0xf0102617:	mov    %eax,%ecx
0xf0102617 in ?? ()
=> 0xf0102619:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102619 in ?? ()
=> 0xf0102619:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102619 in ?? ()
=> 0xf0102619:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102619 in ?? ()
=> 0xf0102619:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102619 in ?? ()
=> 0xf0102619:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102619 in ?? ()
=> 0xf0102619:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102619 in ?? ()
=> 0xf0102619:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102619 in ?? ()
=> 0xf0102619:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102619 in ?? ()
=> 0xf0102619:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102619 in ?? ()
=> 0xf0102619:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102619 in ?? ()
=> 0xf0102619:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102619 in ?? ()
=> 0xf0102619:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102619 in ?? ()
=> 0xf0102619:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102619 in ?? ()
=> 0xf0102619:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102619 in ?? ()
=> 0xf0102619:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102619 in ?? ()
=> 0xf0102619:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102619 in ?? ()
=> 0xf0102619:	rep movsl %ds:(%esi),%es:(%edi)
0xf0102619 in ?? ()
=> 0xf010261b:	mov    0xf01421d4,%eax
0xf010261b in ?? ()
=> 0xf0102620:	mov    %eax,0x8(%ebp)
0xf0102620 in ?? ()
=> 0xf0102623:	mov    0x8(%ebp),%eax
0xf0102623 in ?? ()
=> 0xf0102626:	mov    %eax,0xf01421c8
0xf0102626 in ?? ()
=> 0xf010262b:	sub    $0xc,%esp
0xf010262b in ?? ()
=> 0xf010262e:	pushl  0x8(%ebp)
0xf010262e in ?? ()
=> 0xf0102631:	call   0xf0102475
0xf0102631 in ?? ()
=> 0xf0102475:	push   %ebp
0xf0102475 in ?? ()
=> 0xf0102476:	mov    %esp,%ebp
0xf0102476 in ?? ()
=> 0xf0102478:	push   %edi
0xf0102478 in ?? ()
=> 0xf0102479:	push   %esi
0xf0102479 in ?? ()
=> 0xf010247a:	push   %ebx
0xf010247a in ?? ()
=> 0xf010247b:	sub    $0x1c,%esp
0xf010247b in ?? ()
=> 0xf010247e:	mov    0x8(%ebp),%eax
0xf010247e in ?? ()
=> 0xf0102481:	mov    0x28(%eax),%eax
0xf0102481 in ?? ()
=> 0xf0102484:	cmp    $0xe,%eax
0xf0102484 in ?? ()
=> 0xf0102487:	jne    0xf010249c
0xf0102487 in ?? ()
=> 0xf0102489:	sub    $0xc,%esp
0xf0102489 in ?? ()
=> 0xf010248c:	pushl  0x8(%ebp)
0xf010248c in ?? ()
=> 0xf010248f:	call   0xf0102662
0xf010248f in ?? ()
=> 0xf0102662:	push   %ebp
0xf0102662 in ?? ()
=> 0xf0102663:	mov    %esp,%ebp
0xf0102663 in ?? ()
=> 0xf0102665:	sub    $0x18,%esp
0xf0102665 in ?? ()
=> 0xf0102668:	mov    %cr2,%eax
0xf0102668 in ?? ()
=> 0xf010266b:	mov    %eax,-0x18(%ebp)
0xf010266b in ?? ()
=> 0xf010266e:	mov    -0x18(%ebp),%eax
0xf010266e in ?? ()
=> 0xf0102671:	mov    %eax,-0x10(%ebp)
0xf0102671 in ?? ()
=> 0xf0102674:	mov    0x8(%ebp),%eax
0xf0102674 in ?? ()
=> 0xf0102677:	movzwl 0x34(%eax),%eax
0xf0102677 in ?? ()
=> 0xf010267b:	movzwl %ax,%eax
0xf010267b in ?? ()
=> 0xf010267e:	and    $0x3,%eax
0xf010267e in ?? ()
=> 0xf0102681:	test   %eax,%eax
0xf0102681 in ?? ()
=> 0xf0102683:	jne    0xf010269c
0xf0102683 in ?? ()
=> 0xf010269c:	mov    0xf01421d4,%eax
0xf010269c in ?? ()
=> 0xf01026a1:	mov    0x64(%eax),%eax
0xf01026a1 in ?? ()
=> 0xf01026a4:	test   %eax,%eax
0xf01026a4 in ?? ()
=> 0xf01026a6:	je     0xf0102778
0xf01026a6 in ?? ()
=> 0xf0102778:	mov    0x8(%ebp),%eax
0xf0102778 in ?? ()
=> 0xf010277b:	mov    0x30(%eax),%edx
0xf010277b in ?? ()
=> 0xf010277e:	mov    0xf01421d4,%eax
0xf010277e in ?? ()
=> 0xf0102783:	mov    0x48(%eax),%eax
0xf0102783 in ?? ()
=> 0xf0102786:	push   %edx
0xf0102786 in ?? ()
=> 0xf0102787:	pushl  -0x10(%ebp)
0xf0102787 in ?? ()
=> 0xf010278a:	push   %eax
0xf010278a in ?? ()
=> 0xf010278b:	push   $0xf0104b74
0xf010278b in ?? ()
=> 0xf0102790:	call   0xf0103b79
0xf0102790 in ?? ()
=> 0xf0103b79:	push   %ebp
0xf0103b79 in ?? ()
=> 0xf0103b7a:	mov    %esp,%ebp
0xf0103b7a in ?? ()
=> 0xf0103b7c:	sub    $0x18,%esp
0xf0103b7c in ?? ()
=> 0xf0103b7f:	lea    0xc(%ebp),%eax
0xf0103b7f in ?? ()
=> 0xf0103b82:	mov    %eax,-0x10(%ebp)
0xf0103b82 in ?? ()
=> 0xf0103b85:	mov    -0x10(%ebp),%eax
0xf0103b85 in ?? ()
=> 0xf0103b88:	sub    $0x8,%esp
0xf0103b88 in ?? ()
=> 0xf0103b8b:	push   %eax
0xf0103b8b in ?? ()
=> 0xf0103b8c:	pushl  0x8(%ebp)
0xf0103b8c in ?? ()
=> 0xf0103b8f:	call   0xf0103b50
0xf0103b8f in ?? ()
=> 0xf0103b50:	push   %ebp
0xf0103b50 in ?? ()
=> 0xf0103b51:	mov    %esp,%ebp
0xf0103b51 in ?? ()
=> 0xf0103b53:	sub    $0x18,%esp
0xf0103b53 in ?? ()
=> 0xf0103b56:	movl   $0x0,-0xc(%ebp)
0xf0103b56 in ?? ()
=> 0xf0103b5d:	pushl  0xc(%ebp)
0xf0103b5d in ?? ()
=> 0xf0103b60:	pushl  0x8(%ebp)
0xf0103b60 in ?? ()
=> 0xf0103b63:	lea    -0xc(%ebp),%eax
0xf0103b63 in ?? ()
=> 0xf0103b66:	push   %eax
0xf0103b66 in ?? ()
=> 0xf0103b67:	push   $0xf0103b2c
0xf0103b67 in ?? ()
=> 0xf0103b6c:	call   0xf0103cd7
0xf0103b6c in ?? ()
=> 0xf0103cd7:	push   %ebp
0xf0103cd7 in ?? ()
=> 0xf0103cd8:	mov    %esp,%ebp
0xf0103cd8 in ?? ()
=> 0xf0103cda:	push   %esi
0xf0103cda in ?? ()
=> 0xf0103cdb:	push   %ebx
0xf0103cdb in ?? ()
=> 0xf0103cdc:	sub    $0x20,%esp
0xf0103cdc in ?? ()
=> 0xf0103cdf:	jmp    0xf0103cf8
0xf0103cdf in ?? ()
=> 0xf0103cf8:	mov    0x10(%ebp),%eax
0xf0103cf8 in ?? ()
=> 0xf0103cfb:	lea    0x1(%eax),%edx
0xf0103cfb in ?? ()
=> 0xf0103cfe:	mov    %edx,0x10(%ebp)
0xf0103cfe in ?? ()
=> 0xf0103d01:	movzbl (%eax),%eax
0xf0103d01 in ?? ()
=> 0xf0103d04:	movzbl %al,%ebx
0xf0103d04 in ?? ()
=> 0xf0103d07:	cmp    $0x25,%ebx
0xf0103d07 in ?? ()
=> 0xf0103d0a:	jne    0xf0103ce1
0xf0103d0a in ?? ()
=> 0xf0103ce1:	test   %ebx,%ebx
0xf0103ce1 in ?? ()
=> 0xf0103ce3:	je     0xf0104070
0xf0103ce3 in ?? ()
=> 0xf0103ce9:	sub    $0x8,%esp
0xf0103ce9 in ?? ()
=> 0xf0103cec:	pushl  0xc(%ebp)
0xf0103cec in ?? ()
=> 0xf0103cef:	push   %ebx
0xf0103cef in ?? ()
=> 0xf0103cf0:	mov    0x8(%ebp),%eax
0xf0103cf0 in ?? ()
=> 0xf0103cf3:	call   *%eax
0xf0103cf3 in ?? ()
=> 0xf0103b2c:	push   %ebp
0xf0103b2c in ?? ()
=> 0xf0103b2d:	mov    %esp,%ebp
0xf0103b2d in ?? ()
=> 0xf0103b2f:	sub    $0x8,%esp
0xf0103b2f in ?? ()
=> 0xf0103b32:	sub    $0xc,%esp
0xf0103b32 in ?? ()
=> 0xf0103b35:	pushl  0x8(%ebp)
0xf0103b35 in ?? ()
=> 0xf0103b38:	call   0xf01012e5
0xf0103b38 in ?? ()
=> 0xf01012e5:	push   %ebp
0xf01012e5 in ?? ()
=> 0xf01012e6:	mov    %esp,%ebp
0xf01012e6 in ?? ()
=> 0xf01012e8:	sub    $0x8,%esp
0xf01012e8 in ?? ()
=> 0xf01012eb:	sub    $0xc,%esp
0xf01012eb in ?? ()
=> 0xf01012ee:	pushl  0x8(%ebp)
0xf01012ee in ?? ()
=> 0xf01012f1:	call   0xf0101017
0xf01012f1 in ?? ()
=> 0xf0101017:	push   %ebp
0xf0101017 in ?? ()
=> 0xf0101018:	mov    %esp,%ebp
0xf0101018 in ?? ()
=> 0xf010101a:	sub    $0x8,%esp
0xf010101a in ?? ()
=> 0xf010101d:	pushl  0x8(%ebp)
0xf010101d in ?? ()
=> 0xf0101020:	call   0xf0100b5c
0xf0101020 in ?? ()
=> 0xf0100b5c:	push   %ebp
0xf0100b5c in ?? ()
=> 0xf0100b5d:	mov    %esp,%ebp
0xf0100b5d in ?? ()
=> 0xf0100b5f:	sub    $0x30,%esp
0xf0100b5f in ?? ()
=> 0xf0100b62:	movl   $0x0,-0x4(%ebp)
0xf0100b62 in ?? ()
=> 0xf0100b69:	jmp    0xf0100b74
0xf0100b69 in ?? ()
=> 0xf0100b74:	movl   $0x3fd,-0x20(%ebp)
0xf0100b74 in ?? ()
=> 0xf0100b7b:	mov    -0x20(%ebp),%eax
0xf0100b7b in ?? ()
=> 0xf0100b7e:	mov    %eax,%edx
0xf0100b7e in ?? ()
=> 0xf0100b80:	in     (%dx),%al
0xf0100b80 in ?? ()
=> 0xf0100b81:	mov    %al,-0x21(%ebp)
0xf0100b81 in ?? ()
=> 0xf0100b84:	movzbl -0x21(%ebp),%eax
0xf0100b84 in ?? ()
=> 0xf0100b88:	movzbl %al,%eax
0xf0100b88 in ?? ()
=> 0xf0100b8b:	and    $0x20,%eax
0xf0100b8b in ?? ()
=> 0xf0100b8e:	test   %eax,%eax
0xf0100b8e in ?? ()
=> 0xf0100b90:	jne    0xf0100b9b
0xf0100b90 in ?? ()
=> 0xf0100b9b:	cmpl   $0x8,0x8(%ebp)
0xf0100b9b in ?? ()
=> 0xf0100b9f:	jne    0xf0100c5c
0xf0100b9f in ?? ()
=> 0xf0100c5c:	mov    0x8(%ebp),%eax
0xf0100c5c in ?? ()
=> 0xf0100c5f:	movzbl %al,%eax
0xf0100c5f in ?? ()
=> 0xf0100c62:	movl   $0x3f8,-0x1c(%ebp)
0xf0100c62 in ?? ()
=> 0xf0100c69:	mov    %al,-0x27(%ebp)
0xf0100c69 in ?? ()
=> 0xf0100c6c:	movzbl -0x27(%ebp),%eax
0xf0100c6c in ?? ()
=> 0xf0100c70:	mov    -0x1c(%ebp),%edx
0xf0100c70 in ?? ()
=> 0xf0100c73:	out    %al,(%dx)
0xf0100c73 in ?? ()
=> 0xf0100c74:	leave  
0xf0100c74 in ?? ()
=> 0xf0100c75:	ret    
0xf0100c75 in ?? ()
=> 0xf0101025:	add    $0x4,%esp
0xf0101025 in ?? ()
=> 0xf0101028:	sub    $0xc,%esp
0xf0101028 in ?? ()
=> 0xf010102b:	pushl  0x8(%ebp)
0xf010102b in ?? ()
=> 0xf010102e:	call   0xf0100e0f
0xf010102e in ?? ()
=> 0xf0100e0f:	push   %ebp
0xf0100e0f in ?? ()
=> 0xf0100e10:	mov    %esp,%ebp
0xf0100e10 in ?? ()
=> 0xf0100e12:	push   %ebx
0xf0100e12 in ?? ()
=> 0xf0100e13:	sub    $0x24,%esp
0xf0100e13 in ?? ()
=> 0xf0100e16:	mov    0x8(%ebp),%eax
0xf0100e16 in ?? ()
=> 0xf0100e19:	mov    $0x0,%al
0xf0100e19 in ?? ()
=> 0xf0100e1b:	test   %eax,%eax
0xf0100e1b in ?? ()
=> 0xf0100e1d:	jne    0xf0100e26
0xf0100e1d in ?? ()
=> 0xf0100e1f:	orl    $0x700,0x8(%ebp)
0xf0100e1f in ?? ()
=> 0xf0100e26:	mov    0x8(%ebp),%eax
0xf0100e26 in ?? ()
=> 0xf0100e29:	movzbl %al,%eax
0xf0100e29 in ?? ()
=> 0xf0100e2c:	cmp    $0x9,%eax
0xf0100e2c in ?? ()
=> 0xf0100e2f:	je     0xf0100ee0
0xf0100e2f in ?? ()
=> 0xf0100e35:	cmp    $0x9,%eax
0xf0100e35 in ?? ()
=> 0xf0100e38:	jg     0xf0100e44
0xf0100e38 in ?? ()
=> 0xf0100e44:	cmp    $0xa,%eax
0xf0100e44 in ?? ()
=> 0xf0100e47:	je     0xf0100e96
0xf0100e47 in ?? ()
=> 0xf0100e49:	cmp    $0xd,%eax
0xf0100e49 in ?? ()
=> 0xf0100e4c:	je     0xf0100ea6
0xf0100e4c in ?? ()
=> 0xf0100e4e:	jmp    0xf0100f16
0xf0100e4e in ?? ()
=> 0xf0100f16:	mov    0xf0141728,%ecx
0xf0100f16 in ?? ()
=> 0xf0100f1c:	movzwl 0xf014172c,%eax
0xf0100f1c in ?? ()
=> 0xf0100f23:	lea    0x1(%eax),%edx
0xf0100f23 in ?? ()
=> 0xf0100f26:	mov    %dx,0xf014172c
0xf0100f26 in ?? ()
=> 0xf0100f2d:	movzwl %ax,%eax
0xf0100f2d in ?? ()
=> 0xf0100f30:	add    %eax,%eax
0xf0100f30 in ?? ()
=> 0xf0100f32:	add    %ecx,%eax
0xf0100f32 in ?? ()
=> 0xf0100f34:	mov    0x8(%ebp),%edx
0xf0100f34 in ?? ()
=> 0xf0100f37:	mov    %dx,(%eax)
0xf0100f37 in ?? ()
=> 0xf0100f3a:	jmp    0xf0100f3d
0xf0100f3a in ?? ()
=> 0xf0100f3d:	movzwl 0xf014172c,%eax
0xf0100f3d in ?? ()
=> 0xf0100f44:	cmp    $0x7cf,%ax
0xf0100f44 in ?? ()
=> 0xf0100f48:	jbe    0xf0100fa3
0xf0100f48 in ?? ()
=> 0xf0100fa3:	mov    0xf0141724,%eax
0xf0100fa3 in ?? ()
=> 0xf0100fa8:	mov    %eax,-0x10(%ebp)
0xf0100fa8 in ?? ()
=> 0xf0100fab:	movb   $0xe,-0x20(%ebp)
0xf0100fab in ?? ()
=> 0xf0100faf:	movzbl -0x20(%ebp),%eax
0xf0100faf in ?? ()
=> 0xf0100fb3:	mov    -0x10(%ebp),%edx
0xf0100fb3 in ?? ()
=> 0xf0100fb6:	out    %al,(%dx)
0xf0100fb6 in ?? ()
=> 0xf0100fb7:	movzwl 0xf014172c,%eax
0xf0100fb7 in ?? ()
=> 0xf0100fbe:	shr    $0x8,%ax
0xf0100fbe in ?? ()
=> 0xf0100fc2:	movzbl %al,%eax
0xf0100fc2 in ?? ()
=> 0xf0100fc5:	mov    0xf0141724,%edx
0xf0100fc5 in ?? ()
=> 0xf0100fcb:	add    $0x1,%edx
0xf0100fcb in ?? ()
=> 0xf0100fce:	mov    %edx,-0x14(%ebp)
0xf0100fce in ?? ()
=> 0xf0100fd1:	mov    %al,-0x1f(%ebp)
0xf0100fd1 in ?? ()
=> 0xf0100fd4:	movzbl -0x1f(%ebp),%eax
0xf0100fd4 in ?? ()
=> 0xf0100fd8:	mov    -0x14(%ebp),%edx
0xf0100fd8 in ?? ()
=> 0xf0100fdb:	out    %al,(%dx)
0xf0100fdb in ?? ()
=> 0xf0100fdc:	mov    0xf0141724,%eax
0xf0100fdc in ?? ()
=> 0xf0100fe1:	mov    %eax,-0x18(%ebp)
0xf0100fe1 in ?? ()
=> 0xf0100fe4:	movb   $0xf,-0x1e(%ebp)
0xf0100fe4 in ?? ()
=> 0xf0100fe8:	movzbl -0x1e(%ebp),%eax
0xf0100fe8 in ?? ()
=> 0xf0100fec:	mov    -0x18(%ebp),%edx
0xf0100fec in ?? ()
=> 0xf0100fef:	out    %al,(%dx)
0xf0100fef in ?? ()
=> 0xf0100ff0:	movzwl 0xf014172c,%eax
0xf0100ff0 in ?? ()
=> 0xf0100ff7:	movzbl %al,%eax
0xf0100ff7 in ?? ()
=> 0xf0100ffa:	mov    0xf0141724,%edx
0xf0100ffa in ?? ()
=> 0xf0101000:	add    $0x1,%edx
0xf0101000 in ?? ()
=> 0xf0101003:	mov    %edx,-0x1c(%ebp)
0xf0101003 in ?? ()
=> 0xf0101006:	mov    %al,-0x1d(%ebp)
0xf0101006 in ?? ()
=> 0xf0101009:	movzbl -0x1d(%ebp),%eax
0xf0101009 in ?? ()
=> 0xf010100d:	mov    -0x1c(%ebp),%edx
0xf010100d in ?? ()
=> 0xf0101010:	out    %al,(%dx)
0xf0101010 in ?? ()
=> 0xf0101011:	nop
0xf0101011 in ?? ()
=> 0xf0101012:	mov    -0x4(%ebp),%ebx
0xf0101012 in ?? ()
=> 0xf0101015:	leave  
0xf0101015 in ?? ()
=> 0xf0101016:	ret    
0xf0101016 in ?? ()
=> 0xf0101033:	add    $0x10,%esp
0xf0101033 in ?? ()
=> 0xf0101036:	nop
0xf0101036 in ?? ()
=> 0xf0101037:	leave  
0xf0101037 in ?? ()
=> 0xf0101038:	ret    
0xf0101038 in ?? ()
=> 0xf01012f6:	add    $0x10,%esp
0xf01012f6 in ?? ()
=> 0xf01012f9:	nop
0xf01012f9 in ?? ()
=> 0xf01012fa:	leave  
0xf01012fa in ?? ()
=> 0xf01012fb:	ret    
0xf01012fb in ?? ()
=> 0xf0103b3d:	add    $0x10,%esp
0xf0103b3d in ?? ()
=> 0xf0103b40:	mov    0xc(%ebp),%eax
0xf0103b40 in ?? ()
=> 0xf0103b43:	mov    (%eax),%eax
0xf0103b43 in ?? ()
=> 0xf0103b45:	lea    0x1(%eax),%edx
0xf0103b45 in ?? ()
=> 0xf0103b48:	mov    0xc(%ebp),%eax
0xf0103b48 in ?? ()
=> 0xf0103b4b:	mov    %edx,(%eax)
0xf0103b4b in ?? ()
=> 0xf0103b4d:	nop
0xf0103b4d in ?? ()
=> 0xf0103b4e:	leave  
0xf0103b4e in ?? ()
=> 0xf0103b4f:	ret    
0xf0103b4f in ?? ()
=> 0xf0103cf5:	add    $0x10,%esp
0xf0103cf5 in ?? ()
=> 0xf0103cf8:	mov    0x10(%ebp),%eax
0xf0103cf8 in ?? ()
=> 0xf0103cfb:	lea    0x1(%eax),%edx
0xf0103cfb in ?? ()
=> 0xf0103cfe:	mov    %edx,0x10(%ebp)
0xf0103cfe in ?? ()
=> 0xf0103d01:	movzbl (%eax),%eax
0xf0103d01 in ?? ()
=> 0xf0103d04:	movzbl %al,%ebx
0xf0103d04 in ?? ()
=> 0xf0103d07:	cmp    $0x25,%ebx
0xf0103d07 in ?? ()
=> 0xf0103d0a:	jne    0xf0103ce1
0xf0103d0a in ?? ()
=> 0xf0103d0c:	movb   $0x20,-0x25(%ebp)
0xf0103d0c in ?? ()
=> 0xf0103d10:	movl   $0xffffffff,-0x1c(%ebp)
0xf0103d10 in ?? ()
=> 0xf0103d17:	movl   $0xffffffff,-0x20(%ebp)
0xf0103d17 in ?? ()
=> 0xf0103d1e:	movl   $0x0,-0x18(%ebp)
0xf0103d1e in ?? ()
=> 0xf0103d25:	movl   $0x0,-0x24(%ebp)
0xf0103d25 in ?? ()
=> 0xf0103d2c:	mov    0x10(%ebp),%eax
0xf0103d2c in ?? ()
=> 0xf0103d2f:	lea    0x1(%eax),%edx
0xf0103d2f in ?? ()
=> 0xf0103d32:	mov    %edx,0x10(%ebp)
0xf0103d32 in ?? ()
=> 0xf0103d35:	movzbl (%eax),%eax
0xf0103d35 in ?? ()
=> 0xf0103d38:	movzbl %al,%ebx
0xf0103d38 in ?? ()
=> 0xf0103d3b:	lea    -0x23(%ebx),%eax
0xf0103d3b in ?? ()
=> 0xf0103d3e:	cmp    $0x55,%eax
0xf0103d3e in ?? ()
=> 0xf0103d41:	ja     0xf0104043
0xf0103d41 in ?? ()
=> 0xf0103d47:	mov    -0xfefb014(,%eax,4),%eax
0xf0103d47 in ?? ()
=> 0xf0103d4e:	jmp    *%eax
0xf0103d4e in ?? ()
=> 0xf0103d56:	movb   $0x30,-0x25(%ebp)
0xf0103d56 in ?? ()
=> 0xf0103d5a:	jmp    0xf0103d2c
0xf0103d5a in ?? ()
=> 0xf0103d2c:	mov    0x10(%ebp),%eax
0xf0103d2c in ?? ()
=> 0xf0103d2f:	lea    0x1(%eax),%edx
0xf0103d2f in ?? ()
=> 0xf0103d32:	mov    %edx,0x10(%ebp)
0xf0103d32 in ?? ()
=> 0xf0103d35:	movzbl (%eax),%eax
0xf0103d35 in ?? ()
=> 0xf0103d38:	movzbl %al,%ebx
0xf0103d38 in ?? ()
=> 0xf0103d3b:	lea    -0x23(%ebx),%eax
0xf0103d3b in ?? ()
=> 0xf0103d3e:	cmp    $0x55,%eax
0xf0103d3e in ?? ()
=> 0xf0103d41:	ja     0xf0104043
0xf0103d41 in ?? ()
=> 0xf0103d47:	mov    -0xfefb014(,%eax,4),%eax
0xf0103d47 in ?? ()
=> 0xf0103d4e:	jmp    *%eax
0xf0103d4e in ?? ()
=> 0xf0103d5c:	movl   $0x0,-0x20(%ebp)
0xf0103d5c in ?? ()
=> 0xf0103d63:	mov    -0x20(%ebp),%edx
0xf0103d63 in ?? ()
=> 0xf0103d66:	mov    %edx,%eax
0xf0103d66 in ?? ()
=> 0xf0103d68:	shl    $0x2,%eax
0xf0103d68 in ?? ()
=> 0xf0103d6b:	add    %edx,%eax
0xf0103d6b in ?? ()
=> 0xf0103d6d:	add    %eax,%eax
0xf0103d6d in ?? ()
=> 0xf0103d6f:	add    %ebx,%eax
0xf0103d6f in ?? ()
=> 0xf0103d71:	sub    $0x30,%eax
0xf0103d71 in ?? ()
=> 0xf0103d74:	mov    %eax,-0x20(%ebp)
0xf0103d74 in ?? ()
=> 0xf0103d77:	mov    0x10(%ebp),%eax
0xf0103d77 in ?? ()
=> 0xf0103d7a:	movzbl (%eax),%eax
0xf0103d7a in ?? ()
=> 0xf0103d7d:	movsbl %al,%ebx
0xf0103d7d in ?? ()
=> 0xf0103d80:	cmp    $0x2f,%ebx
0xf0103d80 in ?? ()
=> 0xf0103d83:	jle    0xf0103dbe
0xf0103d83 in ?? ()
=> 0xf0103d85:	cmp    $0x39,%ebx
0xf0103d85 in ?? ()
=> 0xf0103d88:	jg     0xf0103dbe
0xf0103d88 in ?? ()
=> 0xf0103dbe:	nop
0xf0103dbe in ?? ()
=> 0xf0103dbf:	cmpl   $0x0,-0x1c(%ebp)
0xf0103dbf in ?? ()
=> 0xf0103dc3:	jns    0xf0103d2c
0xf0103dc3 in ?? ()
=> 0xf0103dc9:	mov    -0x20(%ebp),%eax
0xf0103dc9 in ?? ()
=> 0xf0103dcc:	mov    %eax,-0x1c(%ebp)
0xf0103dcc in ?? ()
=> 0xf0103dcf:	movl   $0xffffffff,-0x20(%ebp)
0xf0103dcf in ?? ()
=> 0xf0103dd6:	jmp    0xf0103d2c
0xf0103dd6 in ?? ()
=> 0xf0103d2c:	mov    0x10(%ebp),%eax
0xf0103d2c in ?? ()
=> 0xf0103d2f:	lea    0x1(%eax),%edx
0xf0103d2f in ?? ()
=> 0xf0103d32:	mov    %edx,0x10(%ebp)
0xf0103d32 in ?? ()
=> 0xf0103d35:	movzbl (%eax),%eax
0xf0103d35 in ?? ()
=> 0xf0103d38:	movzbl %al,%ebx
0xf0103d38 in ?? ()
=> 0xf0103d3b:	lea    -0x23(%ebx),%eax
0xf0103d3b in ?? ()
=> 0xf0103d3e:	cmp    $0x55,%eax
0xf0103d3e in ?? ()
=> 0xf0103d41:	ja     0xf0104043
0xf0103d41 in ?? ()
Undefined command: "xq".  Try "help".
Detaching from program: , Remote target
Remote connection closed
